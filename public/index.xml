<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ryan Yang</title>
    <link>https://www.yangcs.net:443/</link>
    <description>Recent content on Ryan Yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 23 Jan 2018 08:26:58 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux全局智能分流方案</title>
      <link>https://www.yangcs.net:443/posts/linux%E5%85%A8%E5%B1%80%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 23 Jan 2018 08:26:58 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/linux%E5%85%A8%E5%B1%80%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81%E6%96%B9%E6%A1%88/</guid>
      <description>&lt;p&gt;
&lt;strong&gt;本来我是决定不再写这样的文章了的。但是呢，最近连续配置了两次 &lt;code&gt;ArchLinux&lt;/code&gt;，在配置这种东西的时候连续撞到了同样的坑，加上这段时间经常有人问我关于 &lt;code&gt;Linux&lt;/code&gt; 下的 &lt;code&gt;shadowsocks&lt;/code&gt; 的问题，所以我想了想还是写一篇记录一下吧，也免得自己以后再忘记了。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这里有两种方案，都可以实现全局智能分流。第一种方案的思路是使用 &lt;code&gt;ipset&lt;/code&gt; 载入 &lt;code&gt;chnroute&lt;/code&gt; 的 &lt;code&gt;IP&lt;/code&gt; 列表并使用 &lt;code&gt;iptables&lt;/code&gt; 实现带自动分流国内外流量的全局代理。为什么不用 &lt;code&gt;PAC&lt;/code&gt; 呢？因为 &lt;code&gt;PAC&lt;/code&gt; 这种东西只对浏览器有用。难道你在浏览器之外就不需要科学上网了吗？反正我是不信的……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=Blue&gt;本教程所用系统为 &lt;code&gt;Archlinux&lt;/code&gt;，其他发型版类似，请自行参考相关资料。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-通过-iptables-实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. 通过 iptables 实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-1-安装相关软件&#34;&gt;1.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;shadowsocks-libev&lt;/li&gt;
&lt;li&gt;ipset&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S shadowsocks-libev ipset
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-配置shadowsocks-libev-略过&#34;&gt;1.2 配置shadowsocks-libev（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;1-3-获取中国ip段&#34;&gt;1.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-4-创建启动和关闭脚本&#34;&gt;1.4 创建启动和关闭脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /home/yang/bin/shadowsocks/ss-up.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

SOCKS_SERVER=$SERVER_IP # SOCKS 服务器的 IP 地址
# Setup the ipset
ipset -N chnroute hash:net maxelem 65536

for ip in $(cat &#39;/home/yang/bin/路由表/cn_rules.conf&#39;); do
  ipset add chnroute $ip
done

# 在nat表中新增一个链，名叫：SHADOWSOCKS
iptables -t nat -N SHADOWSOCKS

# Allow connection to the server
iptables -t nat -A SHADOWSOCKS -d $SOCKS_SERVER -j RETURN

# Allow connection to reserved networks
iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN

# Allow connection to chinese IPs
iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A SHADOWSOCKS -p icmp -m set --match-set chnroute dst -j RETURN

# Redirect to Shadowsocks
# 把1081改成你的shadowsocks本地端口
iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-port 1081
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A SHADOWSOCKS -p icmp -j REDIRECT --to-port 1081

# 将SHADOWSOCKS链中所有的规则追加到OUTPUT链中
iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A OUTPUT -p icmp -j SHADOWSOCKS

# 内网流量流经 shadowsocks 规则链
iptables -t nat -A PREROUTING -s 192.168/16 -j SHADOWSOCKS
# 内网流量源NAT
iptables -t nat -A POSTROUTING -s 192.168/16 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这是在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前执行的脚本，用来设置 &lt;code&gt;iptables&lt;/code&gt; 规则，对全局应用代理并将 &lt;code&gt;chnroute&lt;/code&gt; 导入 &lt;code&gt;ipset&lt;/code&gt; 来实现自动分流。注意要把服务器 &lt;code&gt;IP&lt;/code&gt; 和本地端口相关的代码全部替换成你自己的。
&amp;emsp;&amp;emsp;这里就有一个坑了，就是在把 &lt;code&gt;chnroute.txt&lt;/code&gt; 加入 &lt;code&gt;ipset&lt;/code&gt; 的时候。因为 &lt;code&gt;chnroute.txt&lt;/code&gt; 是一个 &lt;code&gt;IP&lt;/code&gt; 段列表，而中国持有的 &lt;code&gt;IP&lt;/code&gt; 数量上还是比较大的，所以如果使用 &lt;code&gt;hash:ip&lt;/code&gt; 来导入的话会使内存溢出。我在第二次重新配置的时候就撞进了这个大坑……
&amp;emsp;&amp;emsp;但是你也不能尝试把整个列表导入 &lt;code&gt;iptables&lt;/code&gt;。虽然导入 &lt;code&gt;iptables&lt;/code&gt; 不会导致内存溢出，但是 &lt;code&gt;iptables&lt;/code&gt; 是线性查表，即使你全部导入进去，也会因为低下的性能而抓狂。
&lt;br \&gt;
然后再创建 &lt;code&gt;/home/yang/bin/shadowsocks/ss-down.sh&lt;/code&gt;, 这是用来清除上述规则的脚本，比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# iptables -t nat -D OUTPUT -p icmp -j SHADOWSOCKS
iptables -t nat -D OUTPUT -p tcp -j SHADOWSOCKS
iptables -t nat -F SHADOWSOCKS
iptables -t nat -X SHADOWSOCKS
ipset destroy chnroute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x ss-up.sh
$ chmod +x ss-down.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-5-配置ss-redir服务&#34;&gt;1.5 配置ss-redir服务&lt;/h3&gt;

&lt;p&gt;首先，默认的 &lt;code&gt;ss-local&lt;/code&gt; 并不能用来作为 &lt;code&gt;iptables&lt;/code&gt; 流量转发的目标，因为它是 &lt;code&gt;socks5&lt;/code&gt; 代理而非透明代理。我们至少要把 &lt;code&gt;systemd&lt;/code&gt; 执行的程序改成 &lt;code&gt;ss-redir&lt;/code&gt;。其次，上述两个脚本还不能自动执行，必须让 &lt;code&gt;systemd&lt;/code&gt; 分别在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前和关闭之后将脚本执行，这样才能自动配置好 &lt;code&gt;iptables&lt;/code&gt; 规则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/lib/systemd/system/shadowsocks-libev@.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]
Description=Shadowsocks-Libev Client Service
After=network.target

[Service]
User=root
CapabilityBoundingSet=~CAP_SYS_ADMIN
ExecStart=
ExecStartPre=/home/yang/bin/shadowsocks/ss-up.sh
ExecStart=/usr/bin/ss-redir -u -c /etc/%i.json
ExecStopPost=/home/yang/bin/shadowsocks/ss-down.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-6-配置智能-dns-服务&#34;&gt;1.6 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;完成了以上工作之后是不是就可以实现全局科学上网了呢？答案是否定的，我们还有最后一项工作需要完成，那就是解决 &lt;code&gt;DNS&lt;/code&gt; 污染问题。如果你不知道什么是 &lt;code&gt;DNS&lt;/code&gt; 污染，我可以简单地给你普及一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 污染是一种让一般用户由于得到虚假目标主机 &lt;code&gt;IP&lt;/code&gt; 而不能与其通信的方法，是一种 &lt;code&gt;DNS&lt;/code&gt; 缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的 &lt;code&gt;DNS&lt;/code&gt; 查询没有任何认证机制，而且 &lt;code&gt;DNS&lt;/code&gt; 查询通常基于的 &lt;code&gt;UDP&lt;/code&gt; 是无连接不可靠的协议，因此 &lt;code&gt;DNS&lt;/code&gt; 的查询非常容易被篡改，通过对 &lt;code&gt;UDP&lt;/code&gt; 端口 53 上的 &lt;code&gt;DNS&lt;/code&gt; 查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 污染症状：目前一些被禁止访问的网站很多就是通过 &lt;code&gt;DNS&lt;/code&gt; 污染来实现的，例如 &lt;code&gt;YouTube&lt;/code&gt;、&lt;code&gt;Facebook&lt;/code&gt; 等网站。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应对dns污染的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;DNS&lt;/code&gt; 污染，可以说，个人用户很难单单靠设置解决，通常可以使用 &lt;code&gt;VPN&lt;/code&gt; 或者域名远程解析的方法解决，但这大多需要购买付费的 &lt;code&gt;VPN&lt;/code&gt; 或 &lt;code&gt;SSH&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;Hosts&lt;/code&gt; 的方法，手动设置域名正确的 &lt;code&gt;IP&lt;/code&gt; 地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dns&lt;/code&gt; 加密解析：&lt;a href=&#34;https://dnscrypt.org/&#34;&gt;DNSCrypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;忽略 &lt;code&gt;DNS&lt;/code&gt; 投毒污染小工具：&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy&#34;&gt;Pcap_DNSProxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们选择用 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 来解决这个问题，以前用的是 &lt;code&gt;Pdnsd + Dnsmasq&lt;/code&gt; 组合， 后来发现 &lt;code&gt;TCP&lt;/code&gt; 请求效率太低加上家里网络与那些国外的 &lt;code&gt;DNS&lt;/code&gt; 丢包实在是严重， 所以打算用 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 代替 &lt;code&gt;Pdnsd&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 的详细介绍，可以参考:
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy&lt;/a&gt;
安装过程可以参考：
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe_Linux.zh-Hans.txt&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe_Linux.zh-Hans.txt&lt;/a&gt;
更详细的使用说明可以参考：
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe.zh-Hans.txt&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe.zh-Hans.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要重点强调一些需要注意的配置项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DNS&lt;/code&gt; - 境外域名解析参数区域（这是最关键的一项配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[DNS]
# 这里一定要填 IPv4 + TCP！！！表示只使用 TCP 协议向境外远程 DNS 服务器发出请求
Outgoing Protocol = IPv4 + TCP
# 建议当系统使用全局代理功能时启用，程序将除境内服务器外的所有请求直接交给系统而不作任何过滤等处理，系统会将请求自动发往远程服务器进行解析
Direct Request = IPv4
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Local DNS&lt;/code&gt; - 境内域名解析参数区域&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Local DNS]
# 发送请求到境内 DNS 服务器时所使用的协议
Local Protocol = IPv4 + UDP
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Addresses&lt;/code&gt; - 普通模式地址区域&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Addresses]
...
...
# IPv4 主要境外 DNS 服务器地址
IPv4 Main DNS Address = 8.8.4.4:53
# IPv4 备用境外 DNS 服务器地址
IPv4 Alternate DNS Address = 8.8.8.8:53|208.67.220.220:443|208.67.222.222:5353
# IPv4 主要境内 DNS 服务器地址，用于境内域名解析，推荐使用 onedns
IPv4 Local Main DNS Address = 112.124.47.27:53
# IPv4 备用境内 DNS 服务器地址，用于境内域名解析
IPv4 Local Alternate DNS Address = 114.215.126.16:53
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-7-配置系统-dns-服务器设置&#34;&gt;1.7 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可参见 &lt;a href=&#34;https://developers.google.com/speed/public-dns/docs/using&#34;&gt;https://developers.google.com/speed/public-dns/docs/using&lt;/a&gt; 中 &lt;code&gt;Changing your DNS servers settings&lt;/code&gt; 中 &lt;code&gt;Linux&lt;/code&gt; 一节&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;图形界面以 &lt;code&gt;GNOME 3&lt;/code&gt; 为例：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开所有程序列表，并 -&amp;gt; 设置 – 硬件分类 – 网络&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果要对当前的网络配置进行编辑 -&amp;gt; 单击齿轮按钮&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选中 &lt;code&gt;IPv4&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 栏目中，将自动拨向关闭&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在服务器中填入 &lt;code&gt;127.0.0.1&lt;/code&gt; （或103.214.195.99:7300）并应用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选中 &lt;code&gt;IPv6&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 栏目中，将自动拨向关闭&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在服务器中填入 ::1 并应用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请务必确保只填入这两个地址，填入其它地址可能会导致系统选择其它 DNS 服务器绕过程序的代理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启网络连接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改系统文件修改 DNS 服务器设置：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自动获取地址(DHCP)时：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以 &lt;code&gt;root&lt;/code&gt; 权限进入 &lt;code&gt;/etc/dhcp&lt;/code&gt; 或 &lt;code&gt;/etc/dhcp3&lt;/code&gt; 目录（视乎 dhclient.conf 文件位置）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改 &lt;code&gt;dhclient.conf&lt;/code&gt; 文件，修改或添加 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 一项即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 一项被 # 注释则需要把注释去掉以使配置生效，不需要添加新的条目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;dhclient.conf&lt;/code&gt; 文件可能存在多个 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 项，是各个网络接口的配置项目，直接修改总的配置项目即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;service network(/networking) restart&lt;/code&gt; 或 &lt;code&gt;ifdown/ifup&lt;/code&gt; 或 &lt;code&gt;ifconfig stop/start&lt;/code&gt; 重启网络服务/网络端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非自动获取地址(DHCP)时：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以 &lt;code&gt;root&lt;/code&gt; 权限进入 &lt;code&gt;/etc&lt;/code&gt; 目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改 &lt;code&gt;resolv.conf&lt;/code&gt; 文件里的 &lt;code&gt;nameserver&lt;/code&gt; 即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果重启后配置被覆盖，则需要修改或新建 &lt;code&gt;/etc/resolvconf/resolv.conf.d&lt;/code&gt; 文件，内容和 &lt;code&gt;resolv.conf&lt;/code&gt; 一样&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;service network(/networking) restart&lt;/code&gt; 或 &lt;code&gt;ifdown/ifup&lt;/code&gt; 或 &lt;code&gt;ifconfig stop/start&lt;/code&gt; 重启网络服务/网络端口&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-8-打开流量转发&#34;&gt;1.8 打开流量转发&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /etc/sysctl.d/30-ipforward.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;net.ipv4.ip_forward=1

net.ipv6.conf.all.forwarding = 1

net.ipv4.tcp_congestion_control=westwood

net.ipv4.tcp_syn_retries = 5

net.ipv4.tcp_synack_retries = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑完成后，执行以下命令使变动立即生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -p
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-通过-nftables-实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. 通过 nftables 实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-1-安装相关软件&#34;&gt;2.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;shadowsocks-libev&lt;/li&gt;
&lt;li&gt;nftables&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S shadowsocks-libev nftables
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-配置shadowsocks-libev-略过&#34;&gt;2.2 配置shadowsocks-libev（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;2-3-获取中国ip段&#34;&gt;2.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
cat cn_rules.conf|sed &#39;:label;N;s/\n/, /;b label&#39;|sed &#39;s/$/&amp;amp; }/g&#39;|sed &#39;s/^/{ &amp;amp;/g&#39; &amp;gt; /home/yang/bin/路由表/cn_rules1.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-创建启动和关闭脚本&#34;&gt;2.4 创建启动和关闭脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /home/yang/bin/shadowsocks/nftables-up.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#! /bin/bash

nft_pre=&amp;quot;/usr/sbin/nft add rule nat prerouting&amp;quot;
nft_out=&amp;quot;/usr/sbin/nft add rule nat output&amp;quot;
chnroute=$(cat &#39;/home/yang/bin/路由表/cn_rules1.conf&#39;)

/usr/bin/nft -f /etc/nftables.conf

${nft_pre} tcp dport 8385 return
${nft_pre} ip daddr 139.162.87.98 return
${nft_pre} ip daddr { 0.0.0.0/8, 10.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, 224.0.0.0/4, 240.0.0.0/4, 172.16.39.0/24} return
${nft_pre} ip daddr $chnroute return
${nft_pre} tcp sport { 32768-61000} redirect to 1081
#${nft_pre} ip protocol icmp redirect to 1081
# 内网流量源NAT
nft add rule nat postrouting ip saddr 192.168.0.0/12 masquerade

${nft_out} tcp dport 8385 return
${nft_out} ip daddr 139.162.87.98 return
${nft_out} ip daddr { 0.0.0.0/8, 10.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, 224.0.0.0/4, 240.0.0.0/4, 172.16.39.0/24} return
${nft_out} ip daddr $chnroute return
# /proc/sys/net/ipv4/ip_local_port_range，本地发起的连接的端口范围
${nft_out} tcp sport { 32768-61000} redirect to 1081
${nft_out} ip protocol icmp redirect to 1081
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这是在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前执行的脚本，用来设置 &lt;code&gt;nftables&lt;/code&gt; 规则。
然后再创建 &lt;code&gt;/home/yang/bin/shadowsocks/nftables-down.sh&lt;/code&gt;, 这是用来清除上述规则的脚本，比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

sudo nft flush table nat
#sudo nft flush table filter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x nftables-up.sh
$ chmod +x nftables-down.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-配置ss-redir服务&#34;&gt;2.5 配置ss-redir服务&lt;/h3&gt;

&lt;p&gt;首先，默认的 &lt;code&gt;ss-local&lt;/code&gt; 并不能用来作为 &lt;code&gt;nftables&lt;/code&gt; 流量转发的目标，因为它是 &lt;code&gt;socks5&lt;/code&gt; 代理而非透明代理。我们至少要把 &lt;code&gt;systemd&lt;/code&gt; 执行的程序改成 &lt;code&gt;ss-redir&lt;/code&gt;。其次，上述两个脚本还不能自动执行，必须让 &lt;code&gt;systemd&lt;/code&gt; 分别在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前和关闭之后将脚本执行，这样才能自动配置好 &lt;code&gt;nftables&lt;/code&gt; 规则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/lib/systemd/system/shadowsocks-libev@.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]
Description=Shadowsocks-Libev Client Service
After=network.target

[Service]
User=root
CapabilityBoundingSet=~CAP_SYS_ADMIN
ExecStart=
ExecStartPre=/home/yang/bin/shadowsocks/nftables-up.sh
ExecStart=/usr/bin/ss-redir -u -c /etc/%i.json
ExecStopPost=/home/yang/bin/shadowsocks/nftables-down.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start nftables
$ systemctl start shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable nftables
$ systemctl enable shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-6-配置智能-dns-服务&#34;&gt;2.6 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;2-7-配置系统-dns-服务器设置&#34;&gt;2.7 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;2-8-打开流量转发&#34;&gt;2.8 打开流量转发&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-3-通过策略路由实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;3. 通过策略路由实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;3-1-安装相关软件&#34;&gt;3.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;badvpn&lt;/li&gt;
&lt;li&gt;shadowsocks&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S badvpn shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-配置shadowsocks-略过&#34;&gt;3.2 配置shadowsocks（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;3-3-获取中国ip段&#34;&gt;3.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-4-配置智能-dns-服务&#34;&gt;3.4 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;3-5-配置系统-dns-服务器设置&#34;&gt;3.5 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;3-6-写路由表启动和终止脚本&#34;&gt;3.6 写路由表启动和终止脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/local/bin/socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
SOCKS_SERVER=$SERVER_IP # SOCKS 服务器的 IP 地址
SOCKS_PORT=1081 # 本地SOCKS 服务器的端口
GATEWAY_IP=$(ip route|grep &amp;quot;default&amp;quot;|awk &#39;{print $3}&#39;) # 家用网关（路由器）的 IP 地址，你也可以手动指定
TUN_NETWORK_DEV=tun0 # 选一个不冲突的 tun 设备号
TUN_NETWORK_PREFIX=10.0.0 # 选一个不冲突的内网 IP 段的前缀


start_fwd() {
ip tuntap del dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
# 添加虚拟网卡
ip tuntap add dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
# 给虚拟网卡绑定IP地址
ip addr add &amp;quot;$TUN_NETWORK_PREFIX.1/24&amp;quot; dev &amp;quot;$TUN_NETWORK_DEV&amp;quot;
# 启动虚拟网卡
ip link set &amp;quot;$TUN_NETWORK_DEV&amp;quot; up
ip route del default via &amp;quot;$GATEWAY_IP&amp;quot;
ip route add &amp;quot;$SOCKS_SERVER&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
# 特殊ip段走家用网关（路由器）的 IP 地址（如局域网联机）
# ip route add &amp;quot;172.16.39.0/24&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
# 国内网段走家用网关（路由器）的 IP 地址
for i in $(cat /home/yang/bin/路由表/cn_rules.conf)
do
ip route add &amp;quot;$i&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
done
# 将默认网关设为虚拟网卡的IP地址
ip route add 0.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
ip route add 128.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
# 将socks5转为vpn
badvpn-tun2socks --tundev &amp;quot;$TUN_NETWORK_DEV&amp;quot; --netif-ipaddr &amp;quot;$TUN_NETWORK_PREFIX.2&amp;quot; --netif-netmask 255.255.255.0 --socks-server-addr &amp;quot;127.0.0.1:$SOCKS_PORT&amp;quot;
TUN2SOCKS_PID=&amp;quot;$!&amp;quot;
}


stop_fwd() {
ip route del 128.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
ip route del 0.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
for i in $(cat /home/yang/bin/路由表/cn_rules.conf)
do
ip route del &amp;quot;$i&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
done
ip route del &amp;quot;172.16.39.0/24&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
ip route del &amp;quot;$SOCKS_SERVER&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
ip route add default via &amp;quot;$GATEWAY_IP&amp;quot;
ip link set &amp;quot;$TUN_NETWORK_DEV&amp;quot; down
ip addr del &amp;quot;$TUN_NETWORK_PREFIX.1/24&amp;quot; dev &amp;quot;$TUN_NETWORK_DEV&amp;quot;
ip tuntap del dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
}



start_fwd
trap stop_fwd INT TERM
wait &amp;quot;$TUN2SOCKS_PID&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /etc/systemd/system/socksfwd.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]

Description=Transparent SOCKS5 forwarding

After=network-online.target

[Service]

Type=simple

ExecStart=/usr/local/bin/socksfwd

LimitNOFILE=1048576


[Install]

WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-7-打开流量转发&#34;&gt;3.7 打开流量转发&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /etc/sysctl.d/30-ipforward.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;net.ipv4.ip_forward=1

net.ipv6.conf.all.forwarding = 1

net.ipv4.tcp_congestion_control=westwood

net.ipv4.tcp_syn_retries = 5

net.ipv4.tcp_synack_retries = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑完成后，执行以下命令使变动立即生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -p
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Device Mapper系列 (3)：Docker 中使用 devicemapper 存储驱动</title>
      <link>https://www.yangcs.net:443/posts/second/</link>
      <pubDate>Mon, 22 Jan 2018 16:17:11 +0800</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/second/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-准备条件-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;准备条件&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 存储驱动是 &lt;code&gt;RHEL&lt;/code&gt;, &lt;code&gt;CentOS&lt;/code&gt; 和 &lt;code&gt;Oracle Linux&lt;/code&gt; 系统上唯一一个支持 &lt;code&gt;Docker EE&lt;/code&gt; 和 &lt;code&gt;Commercially Supported Docker Engine&lt;/code&gt; (CS-Engine) 的存储驱动，具体参考 &lt;a href=&#34;https://success.docker.com/Policies/Compatibility_Matrix&#34;&gt;Product compatibility matrix&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 在 &lt;code&gt;CentOS&lt;/code&gt;, &lt;code&gt;Fedora&lt;/code&gt;, &lt;code&gt;Ubuntu&lt;/code&gt; 和 &lt;code&gt;Debian&lt;/code&gt; 上也支持 &lt;code&gt;Docker CE&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果你更改了 &lt;code&gt;Docker&lt;/code&gt; 的存储驱动，那么你之前在本地创建的所有容器都将无法访问。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-配置docker使用devicemapper-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;配置Docker使用devicemapper&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Docker 主机运行 &lt;code&gt;devicemapper&lt;/code&gt; 存储驱动时，默认的配置模式为 &lt;code&gt;loop-lvm&lt;/code&gt;。此模式使用空闲的文件来构建用于镜像和容器快照的精简存储池。该模式设计为无需额外配置开箱即用(out-of-the-box)。不过生产部署不应该以 &lt;code&gt;loop-lvm&lt;/code&gt; 模式运行。&lt;/p&gt;

&lt;h3 id=&#34;2-1-生产环境配置direct-lvm模式&#34;&gt;&lt;strong&gt;2.1 生产环境配置direct-lvm模式&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;CentOS7 从 &lt;code&gt;Docker 17.06&lt;/code&gt; 开始支持通过 Docker 自动配置  &lt;code&gt;direct-lvm&lt;/code&gt;，所以推荐使用该工具配置。当然也可以手动配置 &lt;code&gt;lvm&lt;/code&gt;，添加相关配置选项，不过过程较为繁琐一点。&lt;/p&gt;

&lt;h4 id=&#34;自动配置-direct-lvm-模式&#34;&gt;&lt;strong&gt;自动配置 direct-lvm 模式&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;该方法只适用于一个块设备，如果你有多个块设备，请通过手动配置 &lt;code&gt;direct-lvm&lt;/code&gt; 模式。&lt;/p&gt;

&lt;p&gt;示例配置文件位置 &lt;code&gt;/usr/lib/docker-storage-setup/docker-storage-setup&lt;/code&gt;，可以查看其中相关配置的详细说明，或者通过 &lt;code&gt;man docker-storage-setup&lt;/code&gt; 获取帮助，以下介绍几个关键的选项：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;参数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;解释&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;是否必须&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;默认值&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dm.directlvm_device&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;准备配置 direct-lvm 的块设备的路径&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;是&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dm.directlvm_device=&amp;ldquo;/dev/xvdf&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_percent&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定义创建 data thin pool 的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;95&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_percent=95&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_metapercent&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定义创建 metadata thin pool 的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_metapercent=1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_autoextend_threshold&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定义自动扩容的百分比，100 表示 disable，最小为 50，参考 &lt;a href=&#34;http://man7.org/linux/man-pages/man7/lvmthin.7.html&#34;&gt;lvmthin — LVM thin provisioning&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_autoextend_threshold=80&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_autoextend_percent&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;定义每次扩容的大小，100 表示 disable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dm.thinp_autoextend_percent=20&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;dm.directlvm_device_force&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;当块设备已经存在文件系统时，是否格式化块设备&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;否&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;false&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;dm.directlvm_device_force=true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;编辑 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;，设置好参数后重新启动 Docker 使更改生效。下面是一个示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{
  &amp;quot;storage-driver&amp;quot;: &amp;quot;devicemapper&amp;quot;,
  &amp;quot;storage-opts&amp;quot;: [
    &amp;quot;dm.directlvm_device=/dev/xdf&amp;quot;,
    &amp;quot;dm.thinp_percent=95&amp;quot;,
    &amp;quot;dm.thinp_metapercent=1&amp;quot;,
    &amp;quot;dm.thinp_autoextend_threshold=80&amp;quot;,
    &amp;quot;dm.thinp_autoextend_percent=20&amp;quot;,
    &amp;quot;dm.directlvm_device_force=false&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于存储的更多参数请参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/dockerd/#storage-driver-options&#34;&gt;Stable&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/edge/engine/reference/commandline/dockerd/#storage-driver-options&#34;&gt;Edge&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;手动配置-direct-lvm-模式&#34;&gt;&lt;strong&gt;手动配置 direct-lvm 模式&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;下面的步骤创建一个逻辑卷，配置用作存储池的后端。我们假设你有在 &lt;code&gt;/dev/xvdf&lt;/code&gt; 的充足空闲空间的块设备。也假设你的 Docker daemon 已停止。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.登录你要配置的 &lt;code&gt;Docker&lt;/code&gt; 主机并停止 &lt;code&gt;Docker daemon&lt;/code&gt;。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.安装LVM2软件包。LVM2软件包含管理Linux上逻辑卷的用户空间工具集。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RHEL / CentOS:&lt;/strong&gt; &lt;code&gt;device-mapper-persistent-data&lt;/code&gt;, &lt;code&gt;lvm2&lt;/code&gt; 以及相关依赖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ubuntu / Debian:&lt;/strong&gt; &lt;code&gt;thin-provisioning-tools&lt;/code&gt;, &lt;code&gt;lvm2&lt;/code&gt; 以及相关依赖&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.创建物理卷。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pvcreate /dev/xvdf

Physical volume &amp;quot;/dev/xvdf&amp;quot; successfully created.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;4.创建一个 “docker” 卷组。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vgcreate docker /dev/xvdf

Volume group &amp;quot;docker&amp;quot; successfully created
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;5.创建一个名为thinpool的存储池。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在此示例中，设置池大小为 “docker” 卷组大小的 &lt;code&gt;95％&lt;/code&gt;。 其余的空闲空间可以用来自动扩展数据或元数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lvcreate --wipesignatures y -n thinpool docker -l 95%VG

Logical volume &amp;quot;thinpool&amp;quot; created.

$ lvcreate --wipesignatures y -n thinpoolmeta docker -l 1%VG

Logical volume &amp;quot;thinpoolmeta&amp;quot; created.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;6.将存储池转换为 &lt;code&gt;thinpool&lt;/code&gt; 格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lvconvert -y \
--zero n \
-c 512K \
--thinpool docker/thinpool \
--poolmetadata docker/thinpoolmeta

WARNING: Converting logical volume docker/thinpool and docker/thinpoolmeta to
thin pool&#39;s data and metadata volumes with metadata wiping.
THIS WILL DESTROY CONTENT OF LOGICAL VOLUME (filesystem etc.)
Converted docker/thinpool to thin pool.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;7.通过 &lt;code&gt;lvm profile&lt;/code&gt; 配置存储池的自动扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vi /etc/lvm/profile/docker-thinpool.profile
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;8.设置参数 &lt;code&gt;thin_pool_autoextend_threshold&lt;/code&gt; 和 &lt;code&gt;thin_pool_autoextend_percent&lt;/code&gt; 的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;设置 &lt;code&gt;thin_pool_autoextend_threshold&lt;/code&gt; 值。这个值应该是之前设置存储池余下空间的百分比(100 = disabled)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;thin_pool_autoextend_threshold = 80
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;设置当存储池自动扩容时，增加存储池的空间百分比（100 =禁用）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;thin_pool_autoextend_percent = 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查你的 &lt;code&gt;docker-thinpool.profile&lt;/code&gt; 的设置。一个示例 &lt;code&gt;/etc/lvm/profile/docker-thinpool.profile&lt;/code&gt; 应该类似如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;activation {
  thin_pool_autoextend_threshold=80
  thin_pool_autoextend_percent=20
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;9.应用新的 &lt;code&gt;lvm&lt;/code&gt; 配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lvchange --metadataprofile docker-thinpool docker/thinpool

Logical volume docker/thinpool changed.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;10.查看卷的信息，验证 lv 是否受监控。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lvs -o+seg_monitor

LV       VG     Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert Monitor
thinpool docker twi-a-t--- 95.00g             0.00   0.01                             monitored
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;11.备份 &lt;code&gt;Docker&lt;/code&gt; 存储。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir /var/lib/docker.bk
$ mv /var/lib/docker/* /var/lib/docker.bk
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;12.配置一些特定的 &lt;code&gt;devicemapper&lt;/code&gt; 选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /etc/docker/daemon.json

{
    &amp;quot;storage-driver&amp;quot;: &amp;quot;devicemapper&amp;quot;,
    &amp;quot;storage-opts&amp;quot;: [
    &amp;quot;dm.thinpooldev=/dev/mapper/docker-thinpool&amp;quot;,
    &amp;quot;dm.use_deferred_removal=true&amp;quot;,
    &amp;quot;dm.use_deferred_deletion=true&amp;quot;
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#34;&gt;
&lt;strong&gt;【注意事项】&lt;/strong&gt;

Note: Always set both dm.use_deferred_removal=true and dm.use_deferred_deletion=true to prevent unintentionally leaking mount points.
&lt;br /&gt;
启用上述2个参数来阻止可能意外产生的挂载点泄漏问题
&lt;/p&gt;

&lt;h4 id=&#34;检查主机上的-devicemapper-结构&#34;&gt;&lt;strong&gt;检查主机上的 &lt;code&gt;devicemapper&lt;/code&gt; 结构&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;你可以使用 &lt;code&gt;lsblk&lt;/code&gt; 命令来查看以上创建的设备文件和存储池。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lsblk
NAME               MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
xvda               202:0    0    8G  0 disk
└─xvda1            202:1    0    8G  0 part /
xvdf               202:80   0   10G  0 disk
├─vg--docker-data          253:0    0   90G  0 lvm
│ └─docker-202:1-1032-pool 253:2    0   10G  0 dm
└─vg--docker-metadata      253:1    0    4G  0 lvm
  └─docker-202:1-1032-pool 253:2    0   10G  0 dm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图显示由 &lt;code&gt;lsblk&lt;/code&gt; 命令输出的之前镜像的详细信息。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/devicemapper-in-practice-pic4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;可以看出，名为 &lt;code&gt;Docker-202:1-1032-pool&lt;/code&gt; 的 pool 横跨在 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;metadata&lt;/code&gt; 设备之上。pool 的命名规则为：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Docker-主设备号:二级设备号-inode号-pool&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-3-管理-devicemapper-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;3. &lt;strong&gt;管理 devicemapper&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;3-1-监控-thin-pool&#34;&gt;3.1 &lt;strong&gt;监控 thin pool&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;不要过于依赖 &lt;code&gt;lvm&lt;/code&gt; 的自动扩展，通常情况下 &lt;code&gt;Volume Group&lt;/code&gt; 会自动扩展，但有时候 &lt;code&gt;volume&lt;/code&gt; 还是会被塞满，你可以通过命令 &lt;code&gt;lvs&lt;/code&gt; 或 &lt;code&gt;lvs -a&lt;/code&gt; 来监控 volume 剩余的空间。也可以考虑使用 &lt;code&gt;nagios&lt;/code&gt; 等监控工具来进行监控。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;可以查看 &lt;code&gt;lvm&lt;/code&gt; 日志，了解 &lt;code&gt;thin pool&lt;/code&gt; 在自动扩容触及阈值时的状态：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ journalctl -fu dm-event.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#34;&gt;
如果你在使用精简池（thin pool）的过程中频繁遇到问题，你可以在 &lt;code&gt;/etc/docker.daemon.json&lt;/code&gt; 中设置参数 &lt;code&gt;dm.min_free_space&lt;/code&gt; 的值（表示百分比）。例如将其设置为 10，以确保当可用空间达到或接近 10％ 时操作失败，并发出警告。参考 &lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/dockerd/#storage-driver-options&#34;&gt;storage driver options in the Engine daemon reference&lt;/a&gt;.
&lt;/p&gt;

&lt;h3 id=&#34;3-2-为正在运行的设备增加容量&#34;&gt;3.2 &lt;strong&gt;为正在运行的设备增加容量&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如果 lv 的存储空间已满，并且 vg 处于满负荷状态，你可以为正在运行的 &lt;code&gt;thin-pool&lt;/code&gt; 设备增加存储卷的容量，具体过程取决于您是使用 &lt;code&gt;loop-lvm&lt;/code&gt; 精简池还是使用 &lt;code&gt;direct-lvm&lt;/code&gt; 精简池。&lt;/p&gt;

&lt;h4 id=&#34;调整-loop-lvm-精简池的大小&#34;&gt;&lt;strong&gt;调整 &lt;code&gt;loop-lvm&lt;/code&gt; 精简池的大小&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;调整 &lt;code&gt;loop-lvm&lt;/code&gt; 精简池的最简单方法是使用 &lt;code&gt;device_tool&lt;/code&gt; 工具，你也可以使用操作系统自带的工具。&lt;/p&gt;

&lt;h5 id=&#34;a-使用-device-tool-工具&#34;&gt;a. &lt;strong&gt;使用 &lt;code&gt;device_tool&lt;/code&gt; 工具&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;在 &lt;code&gt;docker&lt;/code&gt; 官方 &lt;code&gt;github&lt;/code&gt; 仓库的 &lt;code&gt;contrib/&lt;/code&gt; 目录中有一个社区贡献的脚本 &lt;a href=&#34;https://raw.githubusercontent.com/docker/docker-ce/master/components/engine/contrib/docker-device-tool/device_tool.go&#34;&gt;device_tool.go&lt;/a&gt;，你可以通过此工具免去繁琐的步骤来调整 &lt;code&gt;loop-lvm&lt;/code&gt; 精简池的大小。这个工具不能保证 100% 有效，最好不要在生产环境中使用 &lt;code&gt;loop-lvm&lt;/code&gt; 模式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;clone&lt;/code&gt; 整个仓库 &lt;a href=&#34;https://github.com/docker/docker-ce&#34;&gt;docker-ce&lt;/a&gt;，切换到目录 &lt;code&gt;contrib/docker-device-tool&lt;/code&gt; ，按照 &lt;code&gt;README.md&lt;/code&gt; 中的说明编译该工具。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用该工具。例如调整 &lt;code&gt;thin pool&lt;/code&gt; 的大小为 200GB。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./device_tool resize 200GB
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;b-使用操作系统工具&#34;&gt;b. &lt;strong&gt;使用操作系统工具&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;如果你不想使用 &lt;code&gt;device_tool&lt;/code&gt; 工具，可以通过操作系统工具手动调整 &lt;code&gt;loop-lvm&lt;/code&gt; 精简池的大小。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;loop-lvm&lt;/code&gt; 模式中，Docker 使用的 Device Mapper 设备默认使用 loopback 设备，后端为自动生成的稀疏文件，如下:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -lsh /var/lib/docker/devicemapper/devicemapper/
总用量 510M
508M -rw-------. 1 root root 100G 10月 30 00:00 data
1.9M -rw-------. 1 root root 2.0G 10月 30 00:00 metadata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt; [存放数据] 和 &lt;code&gt;metadata&lt;/code&gt; [存放元数据] 的大小从输出可以看出初始化默认为 100G 和 2G 大小，都是稀疏文件，使用多少占用多少。&lt;/p&gt;

&lt;p&gt;Docker 在初始化的过程中，创建 data 和 metadata 这两个稀疏文件，并分别附加到回环设备 &lt;code&gt;/dev/loop0&lt;/code&gt; 和 &lt;code&gt;/dev/loop1&lt;/code&gt; 上，然后基于回环设备创建 thin pool。 默认一个 container 最大存放数据不超过 10G。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;查看 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;metadata&lt;/code&gt; 的文件路径：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker info |grep &#39;loop file&#39;

 Data loop file: /var/lib/docker/devicemapper/data
 Metadata loop file: /var/lib/docker/devicemapper/metadata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照以下步骤来增加精简池的大小。在这个例子中，thin-pool 原来的容量为 100GB，增加到200GB。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看 data 和 metadata 的大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -lh /var/lib/docker/devicemapper/

total 1175492
-rw------- 1 root root 100G Mar 30 05:22 data
-rw------- 1 root root 2.0G Mar 31 11:17 metadata
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 truncate 命令将数据文件的大小增加到 200G。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ truncate -s 200G /var/lib/docker/devicemapper/data
&lt;/code&gt;&lt;/pre&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#34;&gt;
注意：减小数据文件的大小有可能会对数据造成破坏，请慎重考虑。
&lt;/p&gt; 
  &lt;/li&gt;

&lt;li&gt;&lt;p&gt;验证文件大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -lh /var/lib/docker/devicemapper/

total 1.2G
-rw------- 1 root root 200G Apr 14 08:47 data
-rw------- 1 root root 2.0G Apr 19 13:27 metadata
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;loopback&lt;/code&gt; 文件的大小已经改变，但还没有保存到内存中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在内存中列出环回设备的大小，重新加载该设备，然后再次列出大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo $[ $(sudo blockdev --getsize64 /dev/loop0) / 1024 / 1024 / 1024 ]

100

$ losetup -c /dev/loop0

$ echo $[ $(sudo blockdev --getsize64 /dev/loop0) / 1024 / 1024 / 1024 ]

200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新加载之后，&lt;code&gt;loopback&lt;/code&gt; 设备的大小变为 200GB。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重新加载 &lt;code&gt;devicemapper thin pool&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查看 thin pool 的名称&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dmsetup status | grep &#39; thin-pool &#39; | awk -F &#39;: &#39; {&#39;print $1&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;查看当前卷的信息表&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dmsetup table docker-8:1-123141-pool
  
0 209715200 thin-pool 7:1 7:0 128 32768 1 skip_block_zeroing
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第二个数字是设备的大小，表示有多少个 512－bytes 的扇区。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;128 是最小的可分配的 sector 数。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;32768 是最少可用 sector 的 water mark，也就是一个 threshold。&lt;/li&gt;
&lt;li&gt;1 代表有一个附加参数。&lt;/li&gt;
&lt;li&gt;skip_block_zeroing是个附加参数，表示略过用0填充的块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用输出的第二个字段计算扩展后的 &lt;code&gt;thin pool&lt;/code&gt; 总大小，该字段表示有多少个扇区。100G 的文件含有 209715200 个扇区，扩展到 200G 后，扇区数为 419430400。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用新的扇区数重新加载 thin pool。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dmsetup suspend docker-8:1-123141-pool
  
$ dmsetup reload docker-8:1-123141-pool --table &#39;0 419430400 thin-pool 7:1 7:0 128 32768 1 skip_block_zeroing&#39;
  
$ dmsetup resume docker-8:1-123141-pool
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;调整-direct-lvm-精简池的大小&#34;&gt;&lt;strong&gt;调整 &lt;code&gt;direct-lvm&lt;/code&gt; 精简池的大小&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;要调整 &lt;code&gt;direct-lvm&lt;/code&gt; 精简池的大小，需要添加一块新的块设备到 Docker 的宿主机。并记下内核分配给它的设备名称。例如新的块设备名称为 &lt;code&gt;/dev/xvdg&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;按照以下步骤来增加 &lt;code&gt;direct-lvm&lt;/code&gt; 精简池的大小，请根据实际情况替换以下部分参数。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看卷组的信息。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;pvdisplay&lt;/code&gt; 命令查看精简池当前正在使用的物理块设备以及卷组的名称&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pvdisplay |grep &#39;VG Name&#39;

PV Name               /dev/xvdf
VG Name               docker
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;扩展卷组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vgextend docker /dev/xvdg

Physical volume &amp;quot;/dev/xvdg&amp;quot; successfully created.
Volume group &amp;quot;docker&amp;quot; successfully extended
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;扩展逻辑卷 &lt;code&gt;docker/thinpool&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lvextend -l+100%FREE -n docker/thinpool
     
 Size of logical volume docker/thinpool_tdata changed from 95.00 GiB (24319 extents) to 198.00 GiB (50688 extents).
Logical volume docker/thinpool_tdata successfully resized.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该命令使用了存储卷的全部空间，没有配置自动扩展。如果要扩展 metadata 精简池，请使用 &lt;code&gt;docker/thinpool_tmeta&lt;/code&gt; 替换 &lt;code&gt;docker/thinpool&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;验证新的 &lt;code&gt;thin pool&lt;/code&gt; 的大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker info
    
......
Storage Driver: devicemapper
 Pool Name: docker-thinpool
 Pool Blocksize: 524.3 kB
 Base Device Size: 10.74 GB
 Backing Filesystem: xfs
 Data file:
 Metadata file:
 Data Space Used: 212.3 MB
 Data Space Total: 212.6 GB
 Data Space Available: 212.4 GB
 Metadata Space Used: 286.7 kB
 Metadata Space Total: 1.07 GB
 Metadata Space Available: 1.069 GB
&amp;lt;output truncated&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;Data Space Available&lt;/code&gt; 字段的值查看 &lt;code&gt;thin pool&lt;/code&gt; 的大小。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;重启操作系统后重新激活-devicemapper&#34;&gt;&lt;strong&gt;重启操作系统后重新激活 devicemapper&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;如果重启系统后发现 docker 服务启动失败，你会看到像 “Non existing device” 这样的报错信息。这时需要重新激活逻辑卷。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lvchange -ay docker/thinpool
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-4-devicemapper-存储驱动的工作原理-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;4. &lt;strong&gt;devicemapper 存储驱动的工作原理&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#34;&gt;
&lt;strong&gt;注意&lt;/strong&gt;：不要直接操作 &lt;code&gt;/var/lib/docker/&lt;/code&gt; 中的任何文件或目录，这些文件和目录由 docker 自动管理。
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;查看设备和存储池：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lsblk

NAME                    MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
xvda                    202:0    0    8G  0 disk
└─xvda1                 202:1    0    8G  0 part /
xvdf                    202:80   0  100G  0 disk
├─docker-thinpool_tmeta 253:0    0 1020M  0 lvm
│ └─docker-thinpool     253:2    0   95G  0 lvm
└─docker-thinpool_tdata 253:1    0   95G  0 lvm
  └─docker-thinpool     253:2    0   95G  0 lvm
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;查看 docker 正在使用的挂载点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mount |grep devicemapper
/dev/xvda1 on /var/lib/docker/devicemapper type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;devicemapper&lt;/code&gt; 后，Docker 将镜像和层级内容存储在 thin pool 中，并将它们挂载到 &lt;code&gt;/var/lib/docker/devicemapper/&lt;/code&gt; 目录中暴露给容器使用。&lt;/p&gt;

&lt;h3 id=&#34;4-1-磁盘上的镜像和容器层&#34;&gt;4.1 &lt;strong&gt;磁盘上的镜像和容器层&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/var/lib/docker/devicemapper/metadata/&lt;/code&gt; 目录中包含了有关 devicemapper 配置本身的元数据，以及卷、快照和每个卷的块或者快照同存储池中块的映射信息。&lt;code&gt;devicemapper&lt;/code&gt; 使用了快照技术，元数据中也包含了这些快照的信息，以 json 格式保存在文本中。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/lib/devicemapper/mnt/&lt;/code&gt; 目录包含了所有镜像和容器层的挂载点。镜像层的挂载点表现为空目录，容器层的挂载点显示的是容器内部的文件系统。&lt;/p&gt;

&lt;h3 id=&#34;4-2-镜像分层与共享&#34;&gt;4.2 &lt;strong&gt;镜像分层与共享&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 存储驱动使用专用块设备而不是格式化的文件系统，通过在块级别上对文件进行操作，能够在写时复制（CoW）期间实现最佳性能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 驱动将所有的镜像和容器存储到 &lt;code&gt;/var/lib/docker/devicemapper/&lt;/code&gt; 目录，该目录由一个或多个块级设备、环回设备（仅测试）或物理硬盘组成。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;devicemapper&lt;/code&gt; 创建一个镜像的过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 存储驱动创建一个精简池(thin pool)。这个池是从块设备或循环挂载的文件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下一步是创建一个 base 设备。一个 base 设备是具有文件系统的精简设备。你可以通过运行 &lt;code&gt;docker info&lt;/code&gt; 命令检查 &lt;code&gt;Backing filesystem&lt;/code&gt; 来查看使用的是哪个文件系统。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每一个新镜像(和镜像数据层)是这个 base 设备的一个快照。这些是精简置备写时拷贝快照。这意味着它们初始为空，只在往它们写入数据时才消耗池中的空间。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 &lt;code&gt;devicemapper&lt;/code&gt; 驱动时，容器数据层是从其创建的镜像的快照。与镜像一样，容器快照是精简置备写时拷贝快照。容器快照存储着容器的所有更改。当数据写入容器时，&lt;code&gt;devicemapper&lt;/code&gt; 从存储池按需分配空间。&lt;/p&gt;

&lt;p&gt;下图显示一个具有一个base设备和两个镜像的精简池。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/devicemapper-in-practice-pic1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如果你仔细查看图表你会发现快照一个连着一个。每一个镜像数据层是它下面数据层的一个快照。每个镜像的最底端数据层是存储池中 &lt;code&gt;base&lt;/code&gt; 设备的快照。此 &lt;code&gt;base&lt;/code&gt; 设备是 &lt;code&gt;Device Mapper&lt;/code&gt; 的工件，而不是 Docker 镜像数据层。&lt;/p&gt;

&lt;p&gt;一个容器是从其创建的镜像的一个快照。下图显示两个容器： 一个基于 &lt;code&gt;Ubuntu&lt;/code&gt; 镜像和另一个基于 &lt;code&gt;Busybox&lt;/code&gt; 镜像。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/devicemapper-in-practice-pic2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-5-devicemapper-读写数据的过程-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;5. &lt;strong&gt;devicemapper 读写数据的过程&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;5-1-读数据&#34;&gt;5.1 &lt;strong&gt;读数据&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们来看下使用 &lt;code&gt;devicemapper&lt;/code&gt; 存储驱动如何进行读文件。下图显示在示例容器中读取一个单独的块 [0x44f] 的过程。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/devicemapper-in-practice-pic3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个应用程序请求读取容器中 &lt;code&gt;0x44f&lt;/code&gt; 数据块。由于容器是一个镜像的一个精简快照，它没有那个数据，只有一个指向镜像存储的地方的指针。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;存储驱动根据指针，到镜像快照的 &lt;code&gt;a005e&lt;/code&gt; 镜像层寻找 &lt;code&gt;0xf33&lt;/code&gt; 块区。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 从镜像快照复制数据块 &lt;code&gt;0xf33&lt;/code&gt; 的内容到容器内存中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;存储驱动最后将数据返回给请求的应用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;5-2-写数据&#34;&gt;5.2 &lt;strong&gt;写数据&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写入新数据：&lt;/strong&gt;使用 &lt;code&gt;devicemapper&lt;/code&gt; 驱动，通过按需分配（allocate-on-demand）操作来实现写入新数据到容器，所有的新数据都被写入容器的可写层中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#34;&gt;
例如要写入 56KB 的新数据到容器：

  &amp;emsp;1. 一个应用程序请求写入56KB的新数据到容器。

  &amp;emsp;2. 按需分配操作给容器快照分配一个新的64KB数据块。如果写操作大于64KB，就分配多个新数据块给容器快照。

  &amp;emsp;3. 新的数据写入到新分配的数据块。
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;覆盖存在的数据：&lt;/strong&gt;更新存在的数据使用写时拷贝（copy-on-write）操作，先从最近的镜像层中读取与该文件相关的数据块；然后分配新的空白数据块给容器快照并复制数据到这些数据块；最后更新好的数据写入到新分配的数据块。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除数据：&lt;/strong&gt;当从容器的可写层中删除文件或目录时，或者从镜像层中删除其父层镜像中已存在的文件时，&lt;code&gt;devicemapper&lt;/code&gt; 存储驱动会截获对该文件或目录的进一步读取尝试，并响应该文件或目录不存在。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;写入新数据并删除旧数据：&lt;/strong&gt;当你向容器中写入新数据并删除旧数据时，所有这些操作都发生在容器的可写层。如果你使用的是 &lt;code&gt;direct-lvm&lt;/code&gt; 模式，删除的数据块将会被释放；如果你使用的是 &lt;code&gt;loop-lvm&lt;/code&gt; 模式，那么这些数据块就不会被释放。因此不建议在生产环境中使用 &lt;code&gt;loop-lvm&lt;/code&gt; 模式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-6-device-mapper-对-docker-性能的影响-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;6. &lt;strong&gt;Device Mapper 对 Docker 性能的影响&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;了解按需分配和写时拷贝操作对整体容器性能的影响很重要。&lt;/p&gt;

&lt;h3 id=&#34;6-1-按需分配对性能的影响&#34;&gt;6.1 &lt;strong&gt;按需分配对性能的影响&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 存储驱动通过按需分配操作给容器分配新的数据块。这意味着每次应用程序写入容器内的某处时，一个或多个空数据块从存储池中分配并映射到容器中。&lt;/p&gt;

&lt;p&gt;所有数据块为 &lt;code&gt;64KB&lt;/code&gt;。 写小于 &lt;code&gt;64KB&lt;/code&gt; 的数据仍然分配一个 &lt;code&gt;64KB&lt;/code&gt; 数据块。写入超过 &lt;code&gt;64KB&lt;/code&gt; 的数据分配多个 &lt;code&gt;64KB&lt;/code&gt; 数据块。所以，特别是当发生很多小的写操作时，就会比较影响容器的性能。不过一旦数据块分配给容器，后续的读和写可以直接在该数据块上操作。&lt;/p&gt;

&lt;h3 id=&#34;6-2-写时拷贝对性能的影响&#34;&gt;6.2 &lt;strong&gt;写时拷贝对性能的影响&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;每当容器首次更新现有数据时，&lt;code&gt;devicemapper&lt;/code&gt; 存储驱动必须执行写时拷贝操作。这会从镜像快照复制数据到容器快照。此过程对容器性能产生显着影响。因此，更新一个 &lt;code&gt;1GB&lt;/code&gt; 文件的 &lt;code&gt;32KB&lt;/code&gt; 数据只复制一个 &lt;code&gt;64KB&lt;/code&gt; 数据块到容器快照。这比在文件级别操作需要复制整个 &lt;code&gt;1GB&lt;/code&gt; 文件到容器数据层有明显的性能优势。&lt;/p&gt;

&lt;p&gt;不过在实践中，当容器执行很多小于 &lt;code&gt;64KB&lt;/code&gt; 的写操作时，&lt;code&gt;devicemapper&lt;/code&gt; 的性能会比 &lt;code&gt;AUFS&lt;/code&gt; 要差。&lt;/p&gt;

&lt;h3 id=&#34;6-3-其他注意事项&#34;&gt;6.3 &lt;strong&gt;其他注意事项&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;还有其他一些影响 &lt;code&gt;devicemapper&lt;/code&gt; 存储驱动性能的因素。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Docker 使用的 devicemapper 存储驱动的默认模式是 &lt;code&gt;loop-lvm&lt;/code&gt;。这个模式使用空闲文件来构建存储池，性能非常低。不建议用到生产环境。推荐用在生产环境的模式是 &lt;code&gt;direct-lvm&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存取速度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果希望获得更佳的性能，可以将数据文件和元数据文件放在 &lt;code&gt;SSD&lt;/code&gt; 这样的高速存储上。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存使用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 并不是一个有效使用内存的存储驱动。当一个容器运行 n 个时，它的文件也会被拷贝 n 份到内存中，这对 &lt;code&gt;docker&lt;/code&gt; 宿主机的内存使用会造成明显影响。因此，不建议在 &lt;code&gt;PaaS&lt;/code&gt; 或者资源密集场合使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于写操作较大的，可以采用挂载 &lt;code&gt;data volumes&lt;/code&gt;。使用 &lt;code&gt;data volumes&lt;/code&gt; 可以绕过存储驱动，从而避免 &lt;code&gt;thin provisioning&lt;/code&gt; 和 &lt;code&gt;copy-on-write&lt;/code&gt; 引入的额外开销。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/f233d871/&#34;&gt;Device Mapper系列 (1)：Device Mapper 技术&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/5be9f42/&#34;&gt;Device Mapper系列 (2)：Thin Provisioning 实践&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/7635fcc/&#34;&gt;Device Mapper系列 (3)：Docker 中使用 devicemapper 存储驱动&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Device Mapper系列 (2)：Thin Provisioning 实践</title>
      <link>https://www.yangcs.net:443/posts/first/</link>
      <pubDate>Mon, 22 Jan 2018 16:00:22 +0800</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/first/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-thin-provisioning-snapshot-演示-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;Thin Provisioning Snapshot 演示&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;上一篇我们介绍了 &lt;code&gt;Device Mapper&lt;/code&gt; 框架的技术原理及其核心概念，下面，我们用一系列的命令来演示一下 Device Mapper 的 &lt;code&gt;Thin Provisioning Snapshot&lt;/code&gt; 是怎么玩的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;首先，我们需要先建两个文件，一个是data.img，一个是meta.data.img：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dd if=/dev/zero of=/tmp/data.img bs=1K count=1 seek=10M

1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000621428 s, 1.6 MB/s

$ dd if=/dev/zero of=/tmp/meta.data.img bs=1K count=1 seek=1G

1+0 records in
1+0 records out
1024 bytes (1.0 kB) copied, 0.000140858 s, 7.3 MB/s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意命令中 &lt;code&gt;seek&lt;/code&gt; 选项，其表示为略过 &lt;code&gt;of&lt;/code&gt; 选项指定的输出文件的前 10G 个 output 的 &lt;code&gt;bloksize&lt;/code&gt; 的空间后再写入内容。&lt;/p&gt;

&lt;p&gt;因为 bs 是 1 个字节，所以也就是 10G 的尺寸，但其实在硬盘上是没有占有空间的，占有空间只有 1k 的内容。当向其写入内容时，才会在硬盘上为其分配空间。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们可以用 &lt;code&gt;ls&lt;/code&gt; 命令看一下，实际分配了 12K 和 4K。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -lsh /tmp/data.img

12K -rw-r--r--. 1 root root 11G Aug 25 23:01 /tmp/data.img

$ ls -slh /tmp/meta.data.img

4.0K -rw-r--r--. 1 root root 101M Aug 25 23:17 /tmp/meta.data.img
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;然后，我们为这个文件创建一个 &lt;code&gt;loopback&lt;/code&gt; 设备。（loop2015 和 loop2016 是我乱取的两个名字）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ losetup /dev/loop2015 /tmp/data.img
$ losetup /dev/loop2016 /tmp/meta.data.img

$ losetup -a

/dev/loop2015: [64768]:103991768 (/tmp/data.img)
/dev/loop2016: [64768]:103991765 (/tmp/meta.data.img)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;现在，我们为这个设备建一个 &lt;code&gt;Thin Provisioning&lt;/code&gt; 的 Pool，用 &lt;code&gt;dmsetup&lt;/code&gt; 命令：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dmsetup create hchen-thin-pool \
  --table &amp;quot;0 20971522 thin-pool /dev/loop2016 /dev/loop2015 \
  128 65536 1 skip_block_zeroing&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的参数解释如下（更多信息可参看 &lt;code&gt;Thin Provisioning&lt;/code&gt; 的 man page）:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dmsetup create&lt;/code&gt; 是用来创建 thin pool 的命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hchen-thin-pool&lt;/code&gt; 是自定义的一个 pool 名，不冲突就好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;–-table&lt;/code&gt; 是这个 pool 的参数设置

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 代表起的 sector 位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;20971522&lt;/code&gt; 代表结尾的 sector 号，前面说过，一个 sector 是 512 字节，所以，20971522 个正好是 10GB&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/loop2016&lt;/code&gt; 是 meta 文件的设备（前面我们建好了）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/loop2015&lt;/code&gt; 是 data 文件的设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;128&lt;/code&gt; 是最小的可分配的 sector 数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;65536&lt;/code&gt; 是最少可用 sector 的 water mark，也就是一个 threshold&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 代表有一个附加参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skip_block_zeroing&lt;/code&gt; 是个附加参数，表示略过用 0 填充的块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;然后，我们就可以看到一个 &lt;code&gt;Device Mapper&lt;/code&gt; 的设备了：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ll /dev/mapper/hchen-thin-pool

lrwxrwxrwx. 1 root root 7 Aug 25 23:24 /dev/mapper/hchen-thin-pool -&amp;gt; ../dm-4
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;接下来，我们的初始还没有完成，还要创建一个 &lt;code&gt;Thin Provisioning&lt;/code&gt; 的 Volume：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dmsetup message /dev/mapper/hchen-thin-pool 0 &amp;quot;create_thin 0&amp;quot;

$ dmsetup create hchen-thin-volumn-001 \
  --table &amp;quot;0 2097152 thin /dev/mapper/hchen-thin-pool 0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中：
+ 第一个命令中的 &lt;code&gt;create_thin&lt;/code&gt; 是关键字，后面的 0 表示这个 Volume 的 device 的  id。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第二个命令，是真正的为这个 Volumn 创建一个可以 mount 的设备，名字叫 &lt;code&gt;hchen-thin-volumn-001&lt;/code&gt;。&lt;code&gt;2097152&lt;/code&gt; 只有 1GB。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;好了，在 mount 前，我们还要格式化一下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkfs.ext4 /dev/mapper/hchen-thin-volumn-001

mke2fs 1.42.9 (28-Dec-2013)
Discarding device blocks: done
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=16 blocks, Stripe width=16 blocks
65536 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
32768, 98304, 163840, 229376
 
Allocating group tables: done
Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;好了，我们可以 mount 了（下面的命令中，我还创建了一个文件）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-zsh&#34;&gt;$ mkdir -p /mnt/base

$ mount /dev/mapper/hchen-thin-volumn-001 /mnt/base

$ echo &amp;quot;hello world, I am a base&amp;quot; &amp;gt; /mnt/base/id.txt

$ cat /mnt/base/id.txt

hello world, I am a base
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;好了，接下来，我们来看看 snapshot 怎么搞：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dmsetup message /dev/mapper/hchen-thin-pool 0 &amp;quot;create_snap 1 0&amp;quot;

$ dmsetup create mysnap1 \
  --table &amp;quot;0 2097152 thin /dev/mapper/hchen-thin-pool 1&amp;quot;
  
$ ll /dev/mapper/mysnap1

lrwxrwxrwx. 1 root root 7 Aug 25 23:49 /dev/mapper/mysnap1 -&amp;gt; ../dm-5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令中：
+ 第一条命令是向 &lt;code&gt;hchen-thin-pool&lt;/code&gt; 发一个 &lt;code&gt;create_snap&lt;/code&gt; 的消息，后面跟两个 &lt;code&gt;id&lt;/code&gt;，第一个是新的 dev id，第二个是要从哪个已有的 dev id 上做 &lt;code&gt;snapshot&lt;/code&gt;（0 这个 dev id 是我们前面就创建了了）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第二条命令是创建一个 &lt;code&gt;mysnap1&lt;/code&gt; 的 device，并可以被 mount。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;下面我们来看看：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir -p /mnt/mysnap1

$ mount /dev/mapper/mysnap1 /mnt/mysnap1

$ ll /mnt/mysnap1/

total 20
-rw-r--r--. 1 root root 25 Aug 25 23:46 id.txt
drwx------. 2 root root 16384 Aug 25 23:43 lost+found

$ cat /mnt/mysnap1/id.txt

hello world, I am a base
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我们来修改一下 &lt;code&gt;/mnt/mysnap1/id.txt&lt;/code&gt;，并加上一个 &lt;code&gt;snap1.txt&lt;/code&gt; 的文件：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo &amp;quot;I am snap1&amp;quot; &amp;gt;&amp;gt; /mnt/mysnap1/id.txt

$ echo &amp;quot;I am snap1&amp;quot; &amp;gt; /mnt/mysnap1/snap1.txt

$ cat /mnt/mysnap1/id.txt

hello world, I am a base
I am snap1

$ cat /mnt/mysnap1/snap1.txt

I am snap1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我们再看一下 &lt;code&gt;/mnt/base&lt;/code&gt;，你会发现没有什么变化：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls /mnt/base

id.txt      lost+found

$ cat /mnt/base/id.txt

hello world, I am a base
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，我相信你看到了分层镜像的样子了。&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-docker-的-devicemapper-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;Docker 的 devicemapper&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;上面基本上就是 Docker 的玩法了，我们可以看一下 docker 的 loopback 设备：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ losetup -a

/dev/loop0: [64768]:38050288 (/var/lib/docker/devicemapper/devicemapper/data)
/dev/loop1: [64768]:38050289 (/var/lib/docker/devicemapper/devicemapper/metadata)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;其中 data &lt;code&gt;100GB&lt;/code&gt;，metadata &lt;code&gt;2.0GB&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -alsh /var/lib/docker/devicemapper/devicemapper

506M -rw-------. 1 root root 100G Sep 10 20:15 data
1.1M -rw-------. 1 root root 2.0G Sep 10 20:15 metadata
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;下面是相关的 &lt;code&gt;thin-pool&lt;/code&gt;。其中，有个当一大串 hash 串的 device 是正在启动的容器：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ll /dev/mapper/dock*

lrwxrwxrwx. 1 root root 7 Aug 25 07:57 /dev/mapper/docker-253:0-104108535-pool -&amp;gt; ../dm-2
lrwxrwxrwx. 1 root root 7 Aug 25 11:13 /dev/mapper/docker-253:0-104108535-deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf -&amp;gt; ../dm-3
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我们可以看一下它的 &lt;code&gt;device id&lt;/code&gt;（Docker 都把它们记下来了）：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /var/lib/docker/devicemapper/metadata/deefcd630a60aa5ad3e69249f58a68e717324be4258296653406ff062f605edf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;device_id&lt;/code&gt; 是 24，size 是 &lt;code&gt;10737418240&lt;/code&gt;，除以 512，就是 &lt;code&gt;20971520&lt;/code&gt; 个 &lt;code&gt;sector&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我们用这些信息来做个 &lt;code&gt;snapshot&lt;/code&gt; 看看（注：我用了一个比较大的 dev id – 1024）：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dmsetup message &amp;quot;/dev/mapper/docker-253:0-104108535-pool&amp;quot; 0 \
  &amp;quot;create_snap 1024 24&amp;quot;
  
$ dmsetup create dockersnap --table \
  &amp;quot;0 20971520 thin /dev/mapper/docker-253:0-104108535-pool 1024&amp;quot;
  
$ mkdir /mnt/docker

$ mount /dev/mapper/dockersnap /mnt/docker/

$ ls /mnt/docker/

id lost+found rootfs

$ ls /mnt/docker/rootfs/

bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;我们在 docker 的容器里用 &lt;code&gt;findmnt&lt;/code&gt; 命令也可以看到相关的 mount 的情况（因为太长，下面只是摘要）：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ findmnt

TARGET                SOURCE               
/                 /dev/mapper/docker-253:0-104108535-deefcd630a60[/rootfs]
/etc/resolv.conf  /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/resolv.conf]
/etc/hostname     /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hostname]
/etc/hosts        /dev/mapper/centos-root[/var/lib/docker/containers/deefcd630a60/hosts]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/f233d871/&#34;&gt;Device Mapper系列 (1)：Device Mapper 技术&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/5be9f42/&#34;&gt;Device Mapper系列 (2)：Thin Provisioning 实践&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/7635fcc/&#34;&gt;Device Mapper系列 (3)：Docker 中使用 devicemapper 存储驱动&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Device Mapper系列 (1)：Device Mapper 技术</title>
      <link>https://www.yangcs.net:443/posts/devicemapper-theory/</link>
      <pubDate>Sun, 21 Jan 2018 09:28:41 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/devicemapper-theory/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-device-mapper-简介-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;Device Mapper 简介&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#34;&gt;
&amp;emsp;&amp;emsp; &lt;code&gt;Device Mapper&lt;/code&gt; 是 linux 的内核用来将块设备映射到虚拟块设备的 framework，它支持许多高级卷管理技术。docker 的 devicemapper 存储驱动程序利用此框架的&lt;code&gt;自动精简配置&lt;/code&gt;(thin provisioning) 和快照功能来管理 docker 镜像和容器。本文将 Device Mapper 存储驱动称为 &lt;code&gt;devicemapper&lt;/code&gt;，将它的内核框架称为 &lt;code&gt;Device Mapper&lt;/code&gt;。
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&amp;emsp;&amp;emsp;&lt;code&gt;Device Mapper&lt;/code&gt; 不同于 AUFS、ext4、NFS 等，因为它并不是一个文件系统（File System），而是 Linux 内核映射块设备的一种技术框架。提供的一种从逻辑设备（虚拟设备）到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;当前比较流行的 Linux 下的逻辑卷管理器如 &lt;code&gt;LVM2&lt;/code&gt;（Linux Volume Manager 2 version)、&lt;code&gt;EVMS&lt;/code&gt;(Enterprise Volume Management System)、&lt;code&gt;dmraid&lt;/code&gt;(Device Mapper Raid Tool)等都是基于该机制实现的。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;值得一提的是 &lt;code&gt;Device Mapper&lt;/code&gt; 工作在块级别（block），并不工作在文件级别（file）。&lt;code&gt;Device Mapper&lt;/code&gt; 自 Linux 2.6.9 后编入 Linux 内核，所有基于 Linux 内核 2.6.9 以后的发行版都内置 &lt;code&gt;Device Mapper&lt;/code&gt;，但你需要进行一些额外的配置才能在 &lt;code&gt;docker&lt;/code&gt; 中使用它。比如在 &lt;code&gt;RHEL&lt;/code&gt; 和 &lt;code&gt;CentOS&lt;/code&gt; 系统中，&lt;code&gt;docker&lt;/code&gt; 默认使用的存储驱动是 &lt;code&gt;overlay&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;devicemapper&lt;/code&gt; 存储驱动使用专用于 &lt;code&gt;docker&lt;/code&gt; 的块设备，它运行在块级别上而不是文件级别。使用块设备比直接使用文件系统性能更好，通过向 &lt;code&gt;Docker&lt;/code&gt; 的宿主机添加物理存储可以扩展块设备的存储空间。&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-用户空间和内核空间-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;用户空间和内核空间&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Device Mapper主要分为用户空间部分和内核空间部分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用户空间相关部分主要负责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等，包含 &lt;code&gt;device mapper&lt;/code&gt; 库和 &lt;code&gt;dmsetup&lt;/code&gt; 工具。对用户空间创建删除 &lt;code&gt;device mapper&lt;/code&gt; 设备的操作进行封装。&lt;/p&gt;

&lt;p&gt;内核中主要提供完成这些用户空间策略所需要的机制，负责具体过滤和重定向 IO 请求。通过不同的驱动插件，转发 IO 请求至目的设备上。附上 &lt;code&gt;Device Mapper&lt;/code&gt; 架构图。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/device.mapper.2.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-3-device-mapper-技术分析-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;3. &lt;strong&gt;Device Mapper 技术分析&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;Device Mapper&lt;/code&gt;&lt;/strong&gt; 作为 Linux 块设备映射技术框架，向外部提供逻辑设备。包含三个重要概念，映射设备（mapped device），映射表（map table），目标设备（target device）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;映射设备即对外提供的逻辑设备，映射设备向下寻找必须找到支撑的目标设备。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;映射表存储映射设备和目标设备的映射关系。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;目标设备可以是映射设备或者物理设备，如果目标设备是一块映射设备，则属于嵌套，理论上可以无限迭代下去。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简而言之，&lt;code&gt;Device Mapper&lt;/code&gt; 对外提供一个虚拟设备供使用，而这块虚拟设备可以通过映射表找到相应的地址，该地址可以指向一块物理设备，也可以指向一个虚拟设备。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/device.mapper.3.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;映射表，是由用户空间创建，传递到内核空间。映射表里有映射设备逻辑的起始地址、范围、和表示在目标设备所在物理设备的地址偏移量以及Target 类型等信息（注：这些地址和偏移量都是以磁盘的扇区为单位的，即 512 个字节大小，所以，当你看到 128 的时候，其实表示的是 128*512=64K）。&lt;/p&gt;

&lt;p&gt;映射驱动在内核空间是插件，&lt;code&gt;Device Mapper&lt;/code&gt; 在内核中通过一个一个模块化的 &lt;code&gt;Target Driver&lt;/code&gt; 插件实现对 IO 请求的过滤或者重新定向等工作，当前已经实现的插件包括软 Raid、加密、多路径、镜像、快照等，这体现了在 Linux 内核设计中策略和机制分离的原则。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Device Mapper&lt;/code&gt; 中的 IO 流处理，从虚拟设备（逻辑设备）根据映射表并指定特定的映射驱动转发到目标设备上。&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-4-docker-中的-device-mapper-核心技术-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;4. &lt;strong&gt;Docker 中的 Device Mapper 核心技术&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Docker 的 &lt;code&gt;devicemapper&lt;/code&gt; 驱动有三个核心概念，&lt;code&gt;copy on-write（写复制）&lt;/code&gt;，&lt;code&gt;thin-provisioning（精简配置）&lt;/code&gt;。&lt;code&gt;snapshot（快照）&lt;/code&gt;，首先简单介绍一下这三种技术。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;CoW（copy on write）写复制&lt;/code&gt;&lt;/strong&gt;：一些文件系统提供的写时复制策略。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;aufs&lt;/code&gt; 的 cow 原理如下：&lt;/p&gt;

&lt;p&gt;当容器需要修改一个文件，而该文件位于低层 &lt;code&gt;branch&lt;/code&gt; 时，顶层 &lt;code&gt;branch&lt;/code&gt; 会直接复制低层 &lt;code&gt;branch&lt;/code&gt; 的文件至顶层再进行修改，而低层的文件不变，这种方式即是 CoW 技术（写复制）。&lt;/p&gt;

&lt;p&gt;当容器删除一个低层 &lt;code&gt;branch&lt;/code&gt; 文件时，只是在顶层 &lt;code&gt;branch&lt;/code&gt; 对该文件进行重命名并隐藏，实际并未删除文件，只是不可见。&lt;/p&gt;

&lt;p&gt;下图所示，容器层所见 file1 文件为镜像层文件，当需要修改 file1 时，会从镜像层把文件复制到容器层，然后进行修改，从而保证镜像层数据的完整性和复用性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/cow-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下图所示，当需要删除 file1 时，由于 file1 是镜像层文件，容器层会创建一个 .wh 前置的隐藏文件，从而实现对 file1 的隐藏，实际并未删除 file1，从而保证镜像层数据的完整性和复用性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/cow-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;devicemapper&lt;/code&gt; 支持在块级别（block）写复制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Snapshot（快照技术）&lt;/code&gt;&lt;/strong&gt;：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。而从具体的技术细节来讲，快照是指向保存在存储设备中的数据的引用标记或指针。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Thin-provisioning（精简配置）&lt;/code&gt;&lt;/strong&gt;，直译为精简配置。&lt;code&gt;Thin-provisioning&lt;/code&gt; 是动态分配，需要多少分配多少，区别于传统分配固定空间从而造成的资源浪费。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它是什么意思呢？你可以联想一下我们计算机中的内存管理中用到的——“虚拟内存技术”——操作系统给每个进程 N 多 N 多用不完的内址地址（32 位下，每个进程可以有最多 2GB 的内存空间），但是呢，我们知道，物理内存是没有那么多的，如果按照进程内存和物理内存一一映射来玩的话，那么，我们得要多少的物理内存啊。所以，操作系统引入了虚拟内存的设计，意思是，我逻辑上给你无限多的内存，但是实际上是实报实销，因为我知道你一定用不了那么多，于是，达到了内存使用率提高的效果。（今天云计算中很多所谓的虚拟化其实完全都是在用和“虚拟内存”相似的 &lt;code&gt;Thin Provisioning&lt;/code&gt; 的技术，所谓的超配，或是超卖）。&lt;/p&gt;

&lt;p&gt;好了，话题拉回来，我们这里说的是存储。看下面两个图，第一个是 &lt;code&gt;Fat Provisioning&lt;/code&gt;，第二个是 &lt;code&gt;Thin Provisioning&lt;/code&gt;，其很好的说明了是个怎么一回事（和虚拟内存是一个概念）。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/thin-provisioning-1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/thin-provisioning-2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#34;&gt;
那么，Docker 是怎么使用 &lt;code&gt;Thin Provisioning&lt;/code&gt; 这个技术做到像 UnionFS 那样的分层镜像的呢？答案是，Docker 使用了 &lt;code&gt;Thin Provisioning&lt;/code&gt; 的 &lt;code&gt;Snapshot&lt;/code&gt; 的技术。下面一篇我们来介绍一下 &lt;code&gt;Thin Provisioning&lt;/code&gt; 的 &lt;code&gt;Snapshot&lt;/code&gt;。
&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/f233d871/&#34;&gt;Device Mapper系列 (1)：Device Mapper 技术&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/5be9f42/&#34;&gt;Device Mapper系列 (2)：Thin Provisioning 实践&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;a href=&#34;https://www.yangcs.net/posts/7635fcc/&#34;&gt;Device Mapper系列 (3)：Docker 中使用 devicemapper 存储驱动&lt;/a&gt;&lt;/center&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python3 系列之迭代器 &amp; 生成器</title>
      <link>https://www.yangcs.net:443/posts/python3-iterator-and-generator/</link>
      <pubDate>Thu, 27 Jul 2017 18:38:59 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/python3-iterator-and-generator/</guid>
      <description>&lt;p&gt;
&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=0 height=0 src=&#34;//music.163.com/outchain/player?type=2&amp;id=27876900&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-迭代器-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;迭代器&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#34;&gt;
迭代器是访问集合元素的一种方式，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件。
&lt;/p&gt;

&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;访问者不需要关心迭代器内部的结构，仅需通过 &lt;code&gt;next()&lt;/code&gt; 方法不断去取下一个内容&lt;/li&gt;
&lt;li&gt;不能随机访问集合中的某个值，只能从头到尾依次访问&lt;/li&gt;
&lt;li&gt;访问到一半时不能往回退&lt;/li&gt;
&lt;li&gt;便于循环比较大的数据集合，节省内存&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;生成一个迭代器&#34;&gt;生成一个迭代器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; names = iter([&#39;alex&#39;, &#39;jack&#39;, &#39;list&#39;])
&amp;gt;&amp;gt;&amp;gt; print(names)
&amp;lt;list_iterator object at 0x7f92dc158b70&amp;gt;

# 不能通过下标形式访问特定元素
&amp;gt;&amp;gt;&amp;gt; names[1]
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    names[1]
TypeError: &#39;list_iterator&#39; object is not subscriptable

# 只能从头到尾依次取出
&amp;gt;&amp;gt;&amp;gt; print(names.__next__())
alex
&amp;gt;&amp;gt;&amp;gt; print(names.__next__())
jack
&amp;gt;&amp;gt;&amp;gt; print(names.__next__())
list

# 如果再想往后取就会报错，因为已经迭代完了
&amp;gt;&amp;gt;&amp;gt; print(names.__next__())
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    print(names.__next__())
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-生成器-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;生成器&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;一个函数调用时返回一个迭代器，那这个函数就叫做生成器（generator），如果函数中包含 &lt;code&gt;yield&lt;/code&gt; 语法，那这个函数就会变成生成器。&lt;/p&gt;

&lt;h3 id=&#34;yield-语法的作用&#34;&gt;yield 语法的作用&lt;/h3&gt;

&lt;p&gt;使函数中断，并保存中断状态，中断后，代码可以继续往下执行，过一段时间还可以再重新调用这个函数，从上次 &lt;code&gt;yield&lt;/code&gt; 的下一句开始执行。&lt;/p&gt;

&lt;h3 id=&#34;生成一个生成器&#34;&gt;生成一个生成器&lt;/h3&gt;

&lt;p&gt;定义一个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def cash_money(amount):
    while amount &amp;gt; 0:
        amount -= 100
        yield 100
        print(&amp;quot;又来取钱啦！&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来调用一下这个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; atm = cash_money(500)
&amp;gt;&amp;gt;&amp;gt; print(atm)
&amp;lt;generator object cash_money at 0x7f92dc086bf8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;奇怪，不是执行了吗，为什么没有输出？很显然，这里并没有执行，我们可以看一下它的类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; type(atm)
&amp;lt;class &#39;generator&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就不仅仅是一个函数了，它现在是一个生成器，不能按照函数的执行方法去理解它，因为它的返回值是一个迭代器。下面我们来调用一下这个迭代器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; print(atm.__next__())
100
&amp;gt;&amp;gt;&amp;gt; print(atm.__next__())
又来取钱啦！
100
&amp;gt;&amp;gt;&amp;gt; print(atm.__next__())
又来取钱啦！
100
&amp;gt;&amp;gt;&amp;gt; print(atm.__next__())
又来取钱啦！
Traceback (most recent call last):
  File &amp;quot;&amp;lt;input&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
    print(atm.__next__())
StopIteration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这个东西有什么用呢？很多人可能不明白，那我来给你解释一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当你调用一个正常的函数的时候，你只要一调用它，你就得等着它的返回，如果它没执行完，不给你返回，你只能干等着，没法干别的事。它要是执行10分钟，你就得在那边卡住，因为你的程序是串行从上到下。&lt;/p&gt;

&lt;p&gt;举个例子，你写了一个程序，向银行发一个请求说你要取5万块钱，但是银行的接口说这是一个比较大额的数目，大概需要半个小时才能审核通过，半个小时之后才能告诉你能不能取。所以这半个小时你只能等着，不等着它一会儿回来就找不到你了，等它返回了之后，你再根据返回的结果执行下一步动作。假设现在银行升级了，审核需要两天，你的程序就得等两天，你没法不等，因为你的程序设计就是串行的。如果你这么干，你就被老板开除了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以我们应该有一种需求：当我要调用另外应该程序的接口时，那个接口需要执行很长时间，我能不能不等它，先去干点别的事情，等它处理好了再告诉我。这就是一个异步的需求。&lt;/p&gt;

&lt;p&gt;下面再来实验一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; atm = cash_money(500)
&amp;gt;&amp;gt;&amp;gt; print(atm.__next__())
100
&amp;gt;&amp;gt;&amp;gt; print(atm.__next__())
又来取钱啦！
100

# 如果我现在停了下来，函数并没有真正结束，里面还有三百块钱没取。现在我不想取了，钱够花了，我想先去干点别的事情，一会儿回来再取
# 干什么好呢？叫个大保健吧。。。
&amp;gt;&amp;gt;&amp;gt; print(&amp;quot;叫个大保健。。。&amp;quot;)

# 现在两百块钱花完了，还可以再回来取钱
&amp;gt;&amp;gt;&amp;gt; print(atm.__next__())
又来取钱啦！
100
# 现在函数并不是从头执行，而是从上一次的断点继续执行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们开始定义的函数是一个 &lt;code&gt;while&lt;/code&gt; 循环，当你进入一个循环后，按理说除非你从这个循环退出，不然你没法跳出这个循环。但这里的情况是我可以循环一会儿就跳出，过一会儿再进入循环，可以随意切入切出，这个非常了不起！你用正常的程序写一个循环是很难做到这一点的，好好感受一下它的魅力吧！&lt;/p&gt;

&lt;h3 id=&#34;使用yield实现单线程中的异步并发效果&#34;&gt;使用yield实现单线程中的异步并发效果&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ cat yield异步.py
#!/usr/bin/env python
# encoding: utf-8
import time
def consumer(name):
    print(&amp;quot;{}准备吃包子啦&amp;quot;.format(name))
    while True:
        baozi = yield
        print(&amp;quot;包子{0}来了，被{1}吃了！&amp;quot;.format(baozi, name))

def producer(name):
    c = consumer(&#39;A&#39;)
    c2 = consumer(&#39;B&#39;)
    c.__next__()
    c2.__next__()
    print(&amp;quot;老子开始准备做包子啦！&amp;quot;)
    for i in range(3):
        time.sleep(1)
        print(&amp;quot;做了两个包子！&amp;quot;)
        c.send(i)
        c2.send(i)

producer(&amp;quot;alex&amp;quot;)

$ python3 yield异步.py
A准备吃包子啦
B准备吃包子啦
老子开始准备做包子啦！
做了两个包子！
包子0来了，被A吃了！
包子0来了，被B吃了！
做了两个包子！
包子1来了，被A吃了！
包子1来了，被B吃了！
做了两个包子！
包子2来了，被A吃了！
包子2来了，被B吃了！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里定义了一个消费者和生产者模型，生产者通过 &lt;code&gt;send&lt;/code&gt; 传递参数给 &lt;code&gt;yield&lt;/code&gt; 表达式，这时传递的参数会作为 &lt;code&gt;yield&lt;/code&gt; 表达式的值，虽然这是一个单线程的串行函数，但这里表现出来的是一种异步的效果。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;我理解的生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。&lt;/li&gt;
&lt;li&gt;带有 yield 的函数不再是一个普通函数，而是一个生成器generator，可用于迭代，工作原理同上。&lt;/li&gt;
&lt;li&gt;yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。&lt;/li&gt;
&lt;li&gt;简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>2017 年的小目标</title>
      <link>https://www.yangcs.net:443/posts/2017-targets/</link>
      <pubDate>Wed, 26 Jul 2017 19:09:28 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/2017-targets/</guid>
      <description>&lt;p&gt;
&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=0 height=0 src=&#34;http://o7z41ciog.bkt.clouddn.com/Linkin%20Park%20-%20In%20The%20End.mp3&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/l.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#34;&gt;
去年的今天，我正在求职面试的道路上自虐，转眼一年又过去了。今天上午，趁着苏州的雾霾刚被吹散，我赶紧取出刚加热的牛奶，跑到路边小摊买了份手抓饼、两个水煮蛋和一杯南瓜粥，匆匆踏上了地铁，到公司已经9点了。
&lt;/p&gt;

&lt;p&gt;回顾2016，主要完成了以下几个小目标：&lt;/p&gt;

&lt;p&gt;1、作为一名专业与计算机毫不相干的大学应届毕业生，成功成为一名云计算公司的工程师 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;2、断断续续写了几篇文章，记录自己的学习过程和感想 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;3、利用右脑图像记忆法背诵《宋词三百首》 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;4、找个女朋友 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;5、买辆车 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;6、买房子 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;7、赚500万 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;8、上任CEO &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;9、收购万达 &amp;mdash;- &lt;del&gt;已完成&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;10、改掉装逼的毛病 &amp;mdash;- 未完成&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当然啦，后面几条都是开玩笑！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2017准备给自己定几个小目标：&lt;/p&gt;

&lt;p&gt;1、准备去魔都上海发展，向大牛学习；&lt;/p&gt;

&lt;p&gt;2、继续练习英文，以达到可以泡洋妞的水平；&lt;/p&gt;

&lt;p&gt;3、深入研究人工智能技术；&lt;/p&gt;

&lt;p&gt;4、把一块腹肌练成6块；&lt;/p&gt;

&lt;p&gt;小目标暂定4个，如果都实现了，再追加一个小目标，比如挣他一个亿。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://www.yangcs.net:443/about/</link>
      <pubDate>Sat, 18 Mar 2017 20:53:54 +0800</pubDate>
      
      <guid>https://www.yangcs.net:443/about/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/jimmysong/image/upload/images/jimmysong-wechat-qrcode.jpg&#34; alt=&#34;wechat_qrcode&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;info&#34;&gt;Info&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Jimmy Song（宋净超）&lt;/li&gt;
&lt;li&gt;Beijing, China 🇨🇳&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.whut.edu.cn&#34;&gt;Wuhan University of Technology（武汉理工大学）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Major in Software Engineering&lt;/li&gt;
&lt;li&gt;Career

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.iflytek.com&#34;&gt;iFlytek&lt;/a&gt; （科大讯飞)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.talkingdata.com&#34;&gt;TalkingData&lt;/a&gt;: current&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;books&#34;&gt;Books&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Translations&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/cloud-native-go&#34;&gt;Cloud Native Go 构建基于Go和React的云原生Web应用与微服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/posts/cloud-native-python/&#34;&gt;Cloud Native Python 使用Python和React构建云原生应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Gitbooks&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook/&#34;&gt;kubernetes-handbook&lt;/a&gt; - kubernetes中文指南/实践手册&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/hugo-handbook&#34;&gt;hugo-handbook&lt;/a&gt; - Building static website with hugo&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;github&#34;&gt;GitHub&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/awesome-cloud-native&#34;&gt;awesome-cloud-native&lt;/a&gt; - Awesome cloud native architectures&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/cheatsheets&#34;&gt;cheatsheets&lt;/a&gt; -  A modest collection of cheatsheets I&amp;rsquo;ve written.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/cloudinary-go&#34;&gt;cloudinary-go&lt;/a&gt; - A Go client library and CLI tool to upload static assets to Cloudinary service.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34;&gt;magpie&lt;/a&gt; - Deploying and managing a Hadoop Yarn cluster with Docker Swarm.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/spark-on-k8s&#34;&gt;Spark on kubernetes&lt;/a&gt; - Running spark on kubernetes with native kubernetes scheduler&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;activities&#34;&gt;Activities&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Jun 19,2016 | Beijing | Ghostcloud四城联动大型巡讲活动 | &lt;a href=&#34;https://www.bagevent.com/event/97318&#34;&gt;让Docker听到中国的声音&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Aug 15,2016 | Shanghai | MSA-summit（全球微服务架构技术大会） | &lt;a href=&#34;http://msa-summit.com/&#34;&gt;基于Docker的大数据集群虚拟化实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Oct 13,2016 | Hangzhou | The Computing Conference（云栖大会）| &lt;a href=&#34;https://yunqi.aliyun.com/2016/hangzhou/schedule?spm=5176.8098788.535884.3.7cdb1f673uSp7Q&#34;&gt;大规模容器集群的管理与调度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Oct 20,2016 | Shanghai | Qcon | &lt;a href=&#34;http://2016.qconshanghai.com/speakers/202253&#34;&gt;Yarn on Docker——容器技术在大数据场景下的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Jul 7,2017 | Shenzhen | ArchSummit（全球架构师峰会）| &lt;a href=&#34;http://sz2017.archsummit.com/presentation/1080&#34;&gt;使用kubernetes的微服务和云原生应用实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Aug 26,2017 | Beijing | 技术·线下沙龙：云原生和微服务 | &lt;a href=&#34;http://www.huodongxing.com/event/8401246554100&#34;&gt;云原生与微服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sept 23,2017 | Beijing | Kubernetes 实战训练 | &lt;a href=&#34;https://www.bagevent.com/event/791762&#34;&gt;Kubernetes 云原生应用设计与实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Oct  15,2017 | Hangzhou | KEUC 2017（Kubernetes中国用户大会）| &lt;a href=&#34;http://keuc.k8smeetup.com/&#34;&gt;k8smeetup最佳社区译者、最佳技术专栏作者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dec 8,2017 | Beijing | ArchSummit（全球架构师峰会）| &lt;a href=&#34;http://bj2017.archsummit.com/presentation/306&#34;&gt;从Kubernetes到Cloud Native——云原生应用之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dec 16,2017 (🎂 My birthday)| Beijing | 下一代微服务： Service Mesh is Coming | &lt;a href=&#34;http://www.itdks.com/eventlist/detail/1690&#34;&gt;IT大咖说 数人云&amp;amp;TalkingData meetup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;contact&#34;&gt;Contact&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Wechat: jimmysong&lt;/li&gt;
&lt;li&gt;Email: jimmysong@jimmysong.io&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/jimmysongio&#34;&gt;Twitter@jimmysongio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://facebook.com/jimmysongio&#34;&gt;Facebook@jimmysongio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.tuchong.com&#34;&gt;图虫(Tuchong Photography)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/cloud-native&#34;&gt;知乎专栏——云原生应用架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;微信公众号——云原生应用架构(CloudNativeGo)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/jimmysong/image/upload/images/cloud-native-wechat-public-account.jpg&#34; alt=&#34;微信公众号-云原生应用架构&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jimmy Song</title>
      <link>https://www.yangcs.net:443/resume/</link>
      <pubDate>Sat, 18 Mar 2017 20:53:54 +0800</pubDate>
      
      <guid>https://www.yangcs.net:443/resume/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://avatars2.githubusercontent.com/u/3328185?v=3&amp;amp;u=84d2689cef6b2f92a651661b8931f7b09b3cf4c0&amp;amp;s=400&#34; alt=&#34;me&#34; /&gt;&lt;/p&gt;

&lt;p&gt;宋净超（Jimmy Song）&lt;/p&gt;

&lt;p&gt;出生：1990年&lt;/p&gt;

&lt;p&gt;现居：北京&lt;/p&gt;

&lt;p&gt;籍贯：山东威海&lt;/p&gt;

&lt;p&gt;学历：大学本科&lt;/p&gt;

&lt;p&gt;毕业：武汉理工大学（211工程）&lt;/p&gt;

&lt;p&gt;专业：软件工程&lt;/p&gt;

&lt;p&gt;微信：jimmysong&lt;/p&gt;

&lt;p&gt;手机：MTg1MTQ0Njg1NjYK（base64）&lt;/p&gt;

&lt;p&gt;Github: &lt;a href=&#34;https://github.com/rootsongjc&#34;&gt;github.com/rootsongjc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Blog：&lt;a href=&#34;https://jimmysong.io&#34;&gt;https://jimmysong.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Twitter: &lt;a href=&#34;https://twitter.com/jimmysongio&#34;&gt;jimmysongio&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;求职目标&#34;&gt;求职目标&lt;/h2&gt;

&lt;p&gt;PaaS平台、Kubernetes、DevOps、微服务架构、Cloud Native&lt;/p&gt;

&lt;h2 id=&#34;个人技能&#34;&gt;个人技能&lt;/h2&gt;

&lt;h3 id=&#34;专业技能&#34;&gt;专业技能&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;211高校毕业，软件专业基础扎实，爱折腾，大学起开始使用Linux系统学习和办公&lt;/li&gt;
&lt;li&gt;从事过大数据平台的构建、熟悉Hadoop生态圈，对Cloudra Hadoop十分熟悉&lt;/li&gt;
&lt;li&gt;熟悉Java、Python、Shell、Go（当前）&lt;/li&gt;
&lt;li&gt;主导过Hadoop集群的安全性设置、大数据集群的迁移和容器化改造&lt;/li&gt;
&lt;li&gt;GitHub铁粉、开源项目簇拥、开源图书写作、英文图书翻译出版&lt;/li&gt;
&lt;li&gt;从0到1推动了TalkingData容器技术落地、包括技术选型、研发、社区参与、布道与落地&lt;/li&gt;
&lt;li&gt;熟悉kubernetes社区和云原生计算基金会（CNCF），并在社区内拥有良好的口碑、kubernetes最佳专栏作者（KEUC2017）&lt;/li&gt;
&lt;li&gt;参与了北京互联网企业基础架构从业人员联合的DCI（Deep Communication Institute）社区的创建并担任轮值主席&lt;/li&gt;
&lt;li&gt;个人博客&lt;a href=&#34;https://jimmysong.io&#34;&gt;https://jimmysong.io&lt;/a&gt;月活跃用户达几万名，并构建了kubernetes与云原生应用微信群，当前人数接近800人且异常活跃，并参与了k8smeetup、kubernetes中文社区，创办了&lt;a href=&#34;https://zhuanlan.zhihu.com/cloud-native&#34;&gt;Cloud Native&lt;/a&gt;知乎专栏（当前关注人数达300多人）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;图书&#34;&gt;图书&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;翻译&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/cloud-native-go&#34;&gt;Cloud Native Go 构建基于Go和React的云原生Web应用与微服务&lt;/a&gt;（已上市）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/posts/cloud-native-python/&#34;&gt;Cloud Native Python 使用Python和React构建云原生应用&lt;/a&gt;（明年上半年上市）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Gitbooks&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook/&#34;&gt;kubernetes-handbook&lt;/a&gt; - kubernetes中文指南/实践手册（第一本开源的kubernetes中文手册）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/hugo-handbook&#34;&gt;hugo-handbook&lt;/a&gt; - Building static website with Hugo&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;github&#34;&gt;GitHub&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/awesome-cloud-native&#34;&gt;awesome-cloud-native&lt;/a&gt; - Awesome cloud native architectures&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/cheatsheets&#34;&gt;cheatsheets&lt;/a&gt; - A modest collection of cheatsheets I’ve written.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/cloudinary-go&#34;&gt;cloudinary-go&lt;/a&gt; - A Go client library and CLI tool to upload static assets to Cloudinary service.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34;&gt;magpie&lt;/a&gt; - Deploying and managing a Hadoop Yarn cluster with Docker Swarm.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/spark-on-k8s&#34;&gt;Spark on kubernetes&lt;/a&gt; - Running spark on kubernetes with native kubernetes scheduler&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;社会活动&#34;&gt;社会活动&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Jun 19,2016 | Beijing | Ghostcloud四城联动大型巡讲活动 | &lt;a href=&#34;https://www.bagevent.com/event/97318&#34;&gt;让Docker听到中国的声音&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Aug 15,2016 | Shanghai | MSA-summit（全球微服务架构技术大会） | &lt;a href=&#34;http://msa-summit.com/&#34;&gt;基于Docker的大数据集群虚拟化实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Oct 13,2016 | Hangzhou | The Computing Conference（云栖大会）| &lt;a href=&#34;https://yunqi.aliyun.com/2016/hangzhou/schedule?spm=5176.8098788.535884.3.7cdb1f673uSp7Q&#34;&gt;大规模容器集群的管理与调度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Oct 20,2016 | Shanghai | Qcon | &lt;a href=&#34;http://2016.qconshanghai.com/speakers/202253&#34;&gt;Yarn on Docker——容器技术在大数据场景下的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2017&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Jul 7,2017 | Shenzhen | ArchSummit（全球架构师峰会）| &lt;a href=&#34;http://sz2017.archsummit.com/presentation/1080&#34;&gt;使用kubernetes的微服务和云原生应用实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Aug 26,2017 | Beijing | 技术·线下沙龙：云原生和微服务 | &lt;a href=&#34;http://www.huodongxing.com/event/8401246554100&#34;&gt;云原生与微服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sept 23,2017 | Beijing | Kubernetes 实战训练 | &lt;a href=&#34;https://www.bagevent.com/event/791762&#34;&gt;Kubernetes 云原生应用设计与实战&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Oct 15,2017 | Hangzhou | KEUC 2017（Kubernetes中国用户大会）| &lt;a href=&#34;http://keuc.k8smeetup.com/&#34;&gt;k8smeetup最佳社区译者、最佳技术专栏作者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dec 8,2017 | Beijing | ArchSummit（全球架构师峰会）| &lt;a href=&#34;http://bj2017.archsummit.com/presentation/306&#34;&gt;从Kubernetes到Cloud Native——云原生应用之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dec 16,2017 | Beijing | 下一代微服务： Service Mesh is Coming | &lt;a href=&#34;http://www.itdks.com/eventlist/detail/1690&#34;&gt;IT大咖说 数人云&amp;amp;TalkingData meetup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;工作经历&#34;&gt;工作经历&lt;/h2&gt;

&lt;h3 id=&#34;talkingdata&#34;&gt;TalkingData&lt;/h3&gt;

&lt;p&gt;&lt;u&gt;大数据及云计算工程师、Cloud Native布道师、KOL&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;2015.07至今&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;负责TalkingData大数据平台数十PB数据的大数据平台的搭建、优化与管理。&lt;/li&gt;
&lt;li&gt;主导完成了TakingData大数据集群Docker虚拟化项目&lt;a href=&#34;https://jimmysong.io/posts/yarn-on-docker/&#34;&gt;yarn on docker&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Cloud Native概念宣导、推广、落地与联合外部企业布道&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;科大讯飞-sz-002230&#34;&gt;科大讯飞（sz.002230）&lt;/h3&gt;

&lt;p&gt;&lt;u&gt;软件开发工程师&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;2013.07-2015.07&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;个性化数据同步系统开发。&lt;/li&gt;
&lt;li&gt;讯飞大数据管理平台&lt;a href=&#34;http://www.infoq.com/cn/articles/build-big-data-open-platform&#34;&gt;maple&lt;/a&gt;开发。&lt;/li&gt;
&lt;li&gt;讯飞语音云Hadoop集群建设&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;项目经验&#34;&gt;项目经验&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;2017.01至今：基于Kubernetes的PaaS平台建设&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：以一己之力从0到1构建基于Kubernetes的PaaS平台。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;完全基于开源的kubernetes&lt;/li&gt;
&lt;li&gt;整个过程可见&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook&#34;&gt;https://jimmysong.io/kubernetes-handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2016.08至2016.12：微服务和Paas平台建设&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：以一己之力从0到1构建了基于Docker的微服务平台。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker版本选型：docker1.11&lt;/li&gt;
&lt;li&gt;Docker网络选型：&lt;a href=&#34;https://github.com/rootsongjc/docker-ipam-plugin&#34;&gt;Shrike&lt;/a&gt;自研网络插件。&lt;/li&gt;
&lt;li&gt;Docker镜像制作：制定镜像制作流程，优化镜像制作过程，探究镜像使用技巧。&lt;/li&gt;
&lt;li&gt;私有仓库搭建：harbor。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2016.01至2016.07：Hadoop计算资源虚拟化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：为了实现Hadoop的计算资源隔离与弹性调度，使用Docker虚拟化技术。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker集群管理工具：&lt;a href=&#34;https://github.com/rootsongjc/magpie&#34;&gt;Magpie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/posts/yarn-on-docker/&#34;&gt;Yarn on docker——大数据集群的计算资源虚拟化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2015.08至2015.12：Hadoop管理与优化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：负责TalkingData几个Hadoop管理、迁移、升级与优化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hadoop集群监控管理平台开发：使用技术&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;Play Framework&lt;/code&gt;、&lt;code&gt;High-chart&lt;/code&gt;、&lt;code&gt;JavaScript&lt;/code&gt;、&lt;code&gt;Bootstrap&lt;/code&gt;、&lt;code&gt;Cassandra&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Hadoop集群的迁移与升级：升级到版本CDH5.5.2，使用Cloudera Manager管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2015.01至2015.07：Hadoop集群升级&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：升级公司原来的Hadoop集群到CDH5并增加安全性配置。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CDH5新特性调研&lt;/li&gt;
&lt;li&gt;Hadoop新集群搭建&lt;/li&gt;
&lt;li&gt;Hadoop安全性配置&lt;/li&gt;
&lt;li&gt;Hadoop集群参数优化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2014.08至2014.12：大数据运维管理平台开发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：BDWS（BigData WorkStation）之Hadoop运维管理平台开发。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用python基于Django框架和puppet工具完成Hadoop集群的自动部署，监控和运维。&lt;/li&gt;
&lt;li&gt;负责Django后台的python代码和shell自动执行脚本、puppet module的编写，puppet和puppet dashboard环境搭建，实现通过Web页面管理主机同时为主机创建Hadoop角色并自动分发配置文件。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2014.03至2014.07：个性化数据同步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：同步北京、合肥、广州三地的用户的个性化数据。 数据源客户端个性化数据，目的地mysql、hbase。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;负责开发公司个性化数据同步组件&lt;code&gt;RMQRepeater&lt;/code&gt;的研发。&lt;/li&gt;
&lt;li&gt;消息中间件调研与选型：研究过Kafka、Zookeeper，最终使用淘宝的开源的&lt;code&gt;RocketMQ&lt;/code&gt;实现。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2013.07至2014.02：Hadoop集群监控告警&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目描述：北京、广州、合肥三地数据分析Hadoop集群的机器和服务监控与告警。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;建立和完善公司大数据集群的监控与告警系统：使用Ganglia、Nagios开源软件，监控集群规模约300台。&lt;/li&gt;
&lt;li&gt;短信告警：使用Shell与 Python监控Hadoop节点状态完成短信告警服务。&lt;/li&gt;
&lt;li&gt;监控个人用户空间占用与主机磁盘使用率：每日定时运行Java程序将Hadoop集群每个节点的磁盘空间利用率和HDFS个人用户目录的空间占用统计值保存在数据库中再使用Django呈现在Web页面中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;兴趣爱好&#34;&gt;兴趣爱好&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;专业摄影师（工会首席摄影师）、视频剪辑、影像后期、街拍与人像摄影，&lt;a href=&#34;https://jimmysongio.tuchong.com/&#34;&gt;请访问我的图虫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;逛GitHub、参与开源社区、折腾新东西&lt;/li&gt;
&lt;li&gt;后摇、电影、旅游&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Linux 下 gns3 网络模拟器配置</title>
      <link>https://www.yangcs.net:443/posts/linux-gns3-start/</link>
      <pubDate>Mon, 23 Jan 2017 11:42:11 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/linux-gns3-start/</guid>
      <description>&lt;p&gt;
&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=0 height=0 src=&#34;//music.163.com/outchain/player?type=2&amp;id=32507038&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-gns3-简介-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;GNS3 简介&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#34;&gt;
&lt;code&gt;GNS3&lt;/code&gt; 是一款具有图形化界面可以运行在多平台（包括 Windows, Linux, and MacOS 等）的网络虚拟软件。Cisco 网络设备管理员或是想要通过 &lt;code&gt;CCNA&lt;/code&gt;,&lt;code&gt;CCNP&lt;/code&gt;,&lt;code&gt;CCIE&lt;/code&gt; 等 Cisco 认证考试的相关人士可以通过它来完成相关的实验模拟操作。同时它也可以用于虚拟体验 Cisco 网际操作系统 IOS 或者是检验将要在真实的路由器上部署实施的相关配置。
&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/gns3.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Windows&lt;/code&gt; 平台下的安装配置非常简单，下载一体化的安装包安装就可以了。但是考虑系统的资源和兼容性，&lt;code&gt;linux&lt;/code&gt; 平台是最好的选择，以下的安装配置基于 &lt;code&gt;Archlinux&lt;/code&gt; 的 64 位系统和&lt;code&gt;GNS1.5.2&lt;/code&gt;版本。&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-gns3-安装-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;GNS3 安装&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;安装python3&#34;&gt;安装Python3&lt;/h3&gt;

&lt;p&gt;新版本的 &lt;code&gt;GNS3&lt;/code&gt; 使用的是 &lt;code&gt;python3&lt;/code&gt;（最好是 &lt;code&gt;python3.3&lt;/code&gt; 以上版本）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pacman -S python
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-sip-包&#34;&gt;安装 sip 包&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sip&lt;/code&gt; 包是 &lt;code&gt;python&lt;/code&gt; 用于调用的扩展库，详情参考：
&lt;a href=&#34;http://www.riverbankcomputing.com/software/sip/intro&#34;&gt;http://www.riverbankcomputing.com/software/sip/intro&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果SIP没有安装或GNS3无法正确调用，它在启动的时候会提示找不到 SIP 或是调用 SIP 失败。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pacman -S sip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-pyqt4-包&#34;&gt;安装 pyqt4 包&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pacman -S python-pyqt4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-pip-支持包&#34;&gt;安装 &lt;code&gt;pip&lt;/code&gt; 支持包&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;pip&lt;/code&gt; 是 &lt;code&gt;python&lt;/code&gt; 下安装扩展包的工具，&lt;code&gt;GNS3&lt;/code&gt; 需要调用很多的 &lt;code&gt;python&lt;/code&gt; 扩展组件，可以通过以下指令安装。&lt;code&gt;pip&lt;/code&gt; 要和 &lt;code&gt;python&lt;/code&gt; 的版本对应。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pacman -S python-pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-gns3&#34;&gt;安装 &lt;code&gt;GNS3&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;可以通过 &lt;code&gt;yaourt&lt;/code&gt; 安装，也可以通过 &lt;code&gt;pip&lt;/code&gt; 指令方式安装，以下内容以 &lt;code&gt;yaourt&lt;/code&gt; 方式安装。&lt;/p&gt;

&lt;p&gt;注意：&lt;code&gt;gns3-server&lt;/code&gt; 与 &lt;code&gt;gns3-gui&lt;/code&gt; 的默认配置文件在 home 目录下，比如我的配置文件在 &lt;code&gt;/home/yang/.config/GNS3/&lt;/code&gt; 目录下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S gns3-server
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;编写 gns3-server 服务脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/lib/systemd/system/gns3-server.service
[Unit]
Description=GNS3 server
Wants=network-online.target
After=network.target network-online.target

[Service]
Type=forking
User=yang
Group=users
ExecStart=/usr/sbin/gns3server --config /home/yang/.config/GNS3/gns3_server.conf --local --log /home/yang/.config/GNS3/gns3.log \
 --pid /home/yang/.config/GNS3/gns3.pid --daemon
Restart=on-abort
PIDFile=/home/yang/.config/GNS3/gns3.pid

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S gns3-gui
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;报错：AttributeError: module &amp;lsquo;aiohttp.web&amp;rsquo; has no attribute &amp;lsquo;RequestHandler&amp;rsquo;&lt;/p&gt;

&lt;p&gt;解决方案：强制安装指定版本的 &lt;code&gt;pyton&lt;/code&gt; 模块 &lt;code&gt;aiohttp&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install aiohttp==1.1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装-dynamips&#34;&gt;安装 &lt;code&gt;dynamips&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Dynamips&lt;/code&gt; 的原始名称为 &lt;code&gt;Cisco 7200 Simulator&lt;/code&gt;，源于 &lt;code&gt;Christophe Fillot&lt;/code&gt; 在2005年8月开始的一个项目，其目的是在传统的 PC 机上模拟（emulate）Cisco 的 7200 路由器。发展到现在，该模拟器已经能够支持 Cisco 的 3600 系列（包括3620，3640，3660），3700 系列（包括3725，3745）和 2600 系列（包括2610到2650XM，2691）路由器平台。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S dynamips
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;启动gns3&#34;&gt;启动GNS3&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;修改gns3-server的配置文件，将 &lt;code&gt;host&lt;/code&gt; 的值改为 &lt;code&gt;127.0.0.1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /home/yang/.config/GNS3/gns3_server.conf
[Server]
host = 127.0.0.1
port = 3080
--snip--
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;启动gns3-server服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start gns3-server
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果所有的组件都已正常安装，接下来在图形界面下的终端输入 &lt;code&gt;gns3&lt;/code&gt; 就可以启动应用了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E5%B7%A5%E4%BD%9C%E5%8C%BA%201_432.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-gns3-配置-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;GNS3 配置&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;gns3-基本配置&#34;&gt;GNS3 基本配置&lt;/h3&gt;

&lt;p&gt;点击“&lt;code&gt;edit&lt;/code&gt;”-“&lt;code&gt;preferences&lt;/code&gt;”找到“&lt;code&gt;general&lt;/code&gt;”检查相关设置是否正确，可以根据实际系统的配置和自己的喜好设置，例如“&lt;code&gt;console application&lt;/code&gt;”中我把 &lt;code&gt;telnet&lt;/code&gt; 的指令设成 &lt;code&gt;Gnome terminal&lt;/code&gt;,设置好后如图所示。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/gns3-console%E8%AE%BE%E7%BD%AE.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;点击“&lt;code&gt;edit&lt;/code&gt;”-“&lt;code&gt;preferences&lt;/code&gt;”找到“&lt;code&gt;server&lt;/code&gt;”主要用于设置系统和 &lt;code&gt;console&lt;/code&gt; 绑定的端口。通过设定相应的端口，远程用户可以 &lt;code&gt;telnet&lt;/code&gt; 主机的指定端口进行配置。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/gns3-server.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;配置ios路由&#34;&gt;配置IOS路由&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;gns3&lt;/code&gt; 通过图形界面调用 &lt;code&gt;dynamips&lt;/code&gt; 来实现对 &lt;code&gt;cisco&lt;/code&gt; 路由器的模拟操作，它可以模拟的设备可以参考 &lt;code&gt;dynamips&lt;/code&gt; 的指令说明。&lt;/p&gt;

&lt;p&gt;cisco 路由器的映像可以通过各种不同的方式获取，网上有很多这样的下载地址。这里给出一个 ios 镜像比较全的地址：&lt;a href=&#34;http://www.networkvn.net/2014/06/cisco-ios-image-for-gns3.html&#34;&gt;http://www.networkvn.net/2014/06/cisco-ios-image-for-gns3.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是我看到过最全的ios 站点，俄国人FTP站点收集的：&lt;a href=&#34;http://sobek.su/Cisco/&#34;&gt;http://sobek.su/Cisco/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;经常用到的镜像可以从我的 dropbox 里下载：&lt;a href=&#34;https://www.dropbox.com/sh/0g6wjuq0kw4x9by/AAAAegYzrhB4uayzm9d0F2oba?dl=0&#34;&gt;ios&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击“&lt;code&gt;edit&lt;/code&gt;”-“&lt;code&gt;preferences&lt;/code&gt;”找到“&lt;code&gt;dynamips&lt;/code&gt;”检查相关设置是否正确，然后选取“&lt;code&gt;IOS routers&lt;/code&gt;”找到已解压好的IOS映像，设置好后如图所示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Preferences_435.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这里需要指定3个地方： 【镜像文件】、【平台】、【型号】，然后 Apply。&lt;/p&gt;

&lt;p&gt;很多人对于型号可能有疑问？ 3620, 3640 有什么差异呢？  不同之处在于支持多少板卡。3620（2个插槽），3640（4个插槽），3660（6个插槽）。&lt;/p&gt;

&lt;p&gt;注意，记得点击&amp;rdquo;保存&amp;rdquo;，然后回到刚才的界面，我们可以看到，Router &lt;code&gt;c3640&lt;/code&gt; 可选了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;添加模块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们知道cisco路由器采用模块化的结构，路由器上面有额外的插槽，这些插槽可以安装各种模块，以提供更多的端口或其他东西，悲催的事儿就是当你需要添加更多的模块时，你必须为每个模块支付相应的费用，也就是按模块收费。
&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/wKioL1QFRSDytnjOAAHgwQqfNBg933.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;我们可以拖拽左侧相应的设备（路由器或交换机）至工作区，然后对其 &lt;code&gt;右键&lt;/code&gt; - &lt;code&gt;配置&lt;/code&gt;， 在 &lt;code&gt;solt&lt;/code&gt; 中选择合适的模块。
&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Unsaved%20project-%20-%20GNS3_447.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;可以按照实验需求自行添加所需模块，T 结尾的为 &lt;code&gt;Serial 接口&lt;/code&gt;，E 为 &lt;code&gt;Ethernet 接口&lt;/code&gt;，FE 为 &lt;code&gt;fast-Ethernet 接口&lt;/code&gt;。
那么各个模块都是什么含义呢？&lt;/p&gt;

&lt;p&gt;&lt;code&gt;光口&lt;/code&gt;：SX(传输距离550m)、LX（10km）、ZX(70km)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;电口&lt;/code&gt;：TX&lt;/p&gt;

&lt;p&gt;&lt;code&gt;网络模块&lt;/code&gt;： NM(network module)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;常用模块&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NM-1FE-TX &amp;mdash;-&amp;gt; 快速以太网&lt;/li&gt;
&lt;li&gt;NM-16ESW &amp;mdash;-&amp;gt; 16口以太网交换机模块&lt;/li&gt;
&lt;li&gt;NM-4T &amp;mdash;-&amp;gt; 2M线端口，同轴电缆&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br \&gt;
需要注意的是 &lt;code&gt;Idle-PC&lt;/code&gt; 值的选取，只有配置了合适的 &lt;code&gt;idle-pc&lt;/code&gt; 值，&lt;code&gt;dynamips&lt;/code&gt; 的运行才正常（CPU的值在 &lt;code&gt;20%&lt;/code&gt; 以内），如果 CPU 占用过高可以重新获取 &lt;code&gt;idle-pc&lt;/code&gt; 值。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Unsaved%20project-%20-%20GNS3_436.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Unsaved%20project-%20-%20GNS3_437.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/top.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;回到 &lt;code&gt;gns3&lt;/code&gt; 界面选择刚配置好的路由器（例如 &lt;code&gt;C3640&lt;/code&gt;）拖至中间空白区域，然后选中它右击“&lt;code&gt;start&lt;/code&gt;”启动，启动后可以选择“&lt;code&gt;console&lt;/code&gt;”进入配置模式。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Unsaved%20project-%20-%20GNS3_440.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;配置vpcs&#34;&gt;配置vpcs&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;vpcs&lt;/code&gt; 主要用来模拟 &lt;code&gt;PC&lt;/code&gt; 的网络操作，它的功能最简单，只有基本的网络指令，没有 &lt;code&gt;qemu&lt;/code&gt; 下的 &lt;code&gt;tinycore&lt;/code&gt; 的功能多。但是 &lt;code&gt;vpcs&lt;/code&gt; 占用的资源更少，启动速度更快。需要注意的是 &lt;code&gt;vpcs&lt;/code&gt; 没法单独启动，一定要将网线连接后才可以进入 &lt;code&gt;console&lt;/code&gt; 界面。&lt;a href=&#34;http://sourceforge.net/projects/vpcs/&#34;&gt;http://sourceforge.net/projects/vpcs/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装也很简单，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S vpcs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后，在gns3的设置界面选取 &lt;code&gt;VPCS&lt;/code&gt; 的选项，找到已经编译好的 &lt;code&gt;vpcs&lt;/code&gt; 执行文件，如下图所示。
&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Unsaved%20project%20-%20GNS3_441.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;注意：启动 &lt;code&gt;vpcs&lt;/code&gt; 之前，必须要把 &lt;code&gt;VPCS&lt;/code&gt; 和其他设备用网线连接起来，不然会报错 Server error from &lt;a href=&#34;http://127.0.0.1:3080:&#34;&gt;http://127.0.0.1:3080:&lt;/a&gt; PC1: This VPCS instance must be connected in order to start&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Unsaved%20project-%20-%20GNS3_446.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vpcs&lt;/code&gt; 必须连接路由的 &lt;code&gt;Fast-Ethernet&lt;/code&gt; 接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;docker-支持&#34;&gt;Docker 支持&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;GNS3 1.5&lt;/code&gt; 中增加了对 &lt;code&gt;Docker&lt;/code&gt; 的支持。它的目标不是模拟生产中容器的部署，而是为了替代笨重的 &lt;code&gt;qemu&lt;/code&gt; 和 &lt;code&gt;vpcs&lt;/code&gt; 用来模拟 pc。
&lt;br \&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在使用 Docker 之前，需要先安装ubridge&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ yaourt -S ubridge
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;添加一个 Docker 模板&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;点击 &lt;code&gt;Preferences&lt;/code&gt; - &lt;code&gt;Docker containers&lt;/code&gt; - &lt;code&gt;New&lt;/code&gt;，新建一个Docker 容器模板。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/79452a76c6a569b251929440a96b3c31.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;br \&gt;&lt;/p&gt;

&lt;p&gt;选择一个镜像。你可以选择 &amp;ldquo;&lt;code&gt;Existing image&lt;/code&gt;&amp;ldquo;，用的是本机已经存在的镜像，也可以选择 &amp;ldquo;&lt;code&gt;New image&lt;/code&gt;&amp;ldquo;，它会自动去官方仓库拉取你需要的镜像。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/d895f4c984286d4169008eb95af66617.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;br \&gt;&lt;/p&gt;

&lt;p&gt;选择一个启动命令，通常我们只想要一个 &lt;code&gt;shell&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/655343e3e4d84b1d54764c4bec8ca397.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;br \&gt;&lt;/p&gt;

&lt;p&gt;设置环境变量。容器启动后你会在容器里看到你设置的这些环境变量。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/711e7a83854868f97f4987fac0e0fea8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;br \&gt;&lt;/p&gt;

&lt;p&gt;设置好了之后，你可以将容器模板拖到中间区域，如果这个镜像在本地不存在，就会自动从官方仓库拉取这个镜像。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Unsaved%20project-%20-%20GNS3_448.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;br \&gt;&lt;/p&gt;

&lt;p&gt;现在你可以启动这个容器并打开 &lt;code&gt;console&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/alpine-1_449.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是：一般情况下，容器会启动一个后台守护进程并开放一些端口，但在 GNS3 中并不是这样，因为我们需要到容器中去手动设置 ip。&lt;/p&gt;

&lt;h3 id=&#34;网络抓包配置&#34;&gt;网络抓包配置&lt;/h3&gt;

&lt;p&gt;抓包主要作用是查找、定位网络通讯中存在的问题，一般情况下可以是额头 &lt;code&gt;tcpdump&lt;/code&gt; 或是 &lt;code&gt;wireshark&lt;/code&gt;。&lt;code&gt;tcpdump&lt;/code&gt; 主要的操作方式通过命令行，&lt;code&gt;wireshark&lt;/code&gt; 提供图形界面，操作及查看方式更加直观，这里以 &lt;code&gt;wireshark&lt;/code&gt; 为例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S wireshark-gtk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后，&lt;code&gt;GNS3&lt;/code&gt; 的配置如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Preferences_450.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在需要抓包的设备上右键选择“&lt;code&gt;Capture&lt;/code&gt;”进行抓包操作，如果设备有多块网卡会提示选择那块。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zabbix Api 简介和使用</title>
      <link>https://www.yangcs.net:443/posts/zabbix-api-introduce-and-use/</link>
      <pubDate>Thu, 05 Jan 2017 10:19:18 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/zabbix-api-introduce-and-use/</guid>
      <description>&lt;p&gt;
&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=0 height=0 src=&#34;//music.163.com/outchain/player?type=2&amp;id=22712173&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-api简介-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;API简介&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;Zabbix API&lt;/code&gt; 开始扮演着越来越重要的角色，尤其是在集成第三方软件和自动化日常任务时。很难想象管理数千台服务器而没有自动化是多么的困难。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Zabbix API&lt;/code&gt; 为批量操作、第三方软件集成以及其他作用提供可编程接口。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Zabbix API&lt;/code&gt; 是在1.8版本中开始引进并且已经被广泛应用。所有的Zabbix移动客户端都是基于API，甚至原生的WEB前端部分也是建立在它之上。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Zabbix API&lt;/code&gt; 中间件使得架构更加模块化也避免直接对数据库进行操作。它允许你通过 &lt;code&gt;JSON RPC&lt;/code&gt; 协议来创建、更新和获取Zabbix对象并且做任何你喜欢的操作【当然前提是你拥有认证账户】。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Zabbix API&lt;/code&gt; 提供两项主要功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程管理 &lt;code&gt;Zabbix&lt;/code&gt; 配置&lt;/li&gt;
&lt;li&gt;远程检索配置和历史数据&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;API 采用JSON-RPC实现。这意味着调用任何函数，都需要发送POST请求，输入输出数据都是以JSON格式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-zabbix-api的使用流程-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;Zabbix API的使用流程&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;使用-api-的基本步骤&#34;&gt;使用 &lt;code&gt;API&lt;/code&gt; 的基本步骤&lt;/h3&gt;

&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#34;&gt;
1. 准备JSON对象，它描述了你想要做什么（创建主机，获取图像，更新监控项等）。&lt;br /&gt;
2. 采用POST方法向 &lt;code&gt;http://example.com/zabbix/api_jsonrpc.php&lt;/code&gt; 发送此JSON对象，提供用户名和密码，&lt;code&gt;HTTP Header Content-Type&lt;/code&gt; 必须为【application/jsonrequest，application/json-rpc，application/json】其中之一。
&lt;code&gt;http://example.com/zabbix/&lt;/code&gt; 是Zabbix前端地址。&lt;code&gt;api_jsonrpc.php&lt;/code&gt; 是调用API的PHP脚本。可在安装可视化前端的目录下找到。&lt;br /&gt;
3. 获取 SESSIONID。&lt;br /&gt;
4. 通过 SESSIONID 建立后续的连接。&lt;br /&gt;
5. 提交 POST 数据，格式为 JSON，其中放对应的方法，获取需要的数据。
&lt;/p&gt;

&lt;h3 id=&#34;使用-curl-模拟-api-的使用&#34;&gt;使用 &lt;code&gt;curl&lt;/code&gt; 模拟 API 的使用&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;获取 &lt;code&gt;SESSIONID&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s -X POST -H &#39;Content-Type:application/json&#39; -d &#39;
&amp;gt; {
&amp;gt;    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
&amp;gt;    &amp;quot;method&amp;quot;: &amp;quot;host.get&amp;quot;,
&amp;gt;    &amp;quot;params&amp;quot;: {
&amp;gt;       &amp;quot;user&amp;quot;: &amp;quot;Admin&amp;quot;,
&amp;gt;       &amp;quot;password&amp;quot;: &amp;quot;zabbix&amp;quot;
&amp;gt;    },
&amp;gt;    &amp;quot;id&amp;quot;: 1
&amp;gt;    }&#39; http://172.16.241.130/zabbix/api_jsonrpc.php | python -m json.tool
{
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;result&amp;quot;: &amp;quot;581cc92624202bddaeff3a90cca181dc&amp;quot;,
    &amp;quot;id&amp;quot;: 1
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用获取的 &lt;code&gt;SESSIONID&lt;/code&gt; 去调用 API 的 &lt;code&gt;host.get&lt;/code&gt; 方法请求 hostid&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -s -X POST -H &#39;Content-Type:application/json&#39; -d &#39;
&amp;gt; {
&amp;gt;    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
&amp;gt;    &amp;quot;method&amp;quot;: &amp;quot;host.get&amp;quot;,
&amp;gt;    &amp;quot;params&amp;quot;: {
&amp;gt;       &amp;quot;output&amp;quot;: [&amp;quot;hostid&amp;quot;]
&amp;gt;    },
&amp;gt;    &amp;quot;auth&amp;quot;: &amp;quot;581cc92624202bddaeff3a90cca181dc&amp;quot;,
&amp;gt;    &amp;quot;id&amp;quot;: 1
&amp;gt;    }&#39; http://172.16.241.130/zabbix/api_jsonrpc.php | python -m json.tool
{
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;result&amp;quot;: [
        {
            &amp;quot;hostid&amp;quot;: &amp;quot;10084&amp;quot;
        }
    ],
    &amp;quot;id&amp;quot;: 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数解释：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;&lt;/code&gt;-这是标准的 JSON RPC 参数以标示协议版本。所有的请求都会保持不变。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;method&amp;quot;: &amp;quot;method.name&amp;quot;&lt;/code&gt;-这个参数定义了真实执行的操作。例如：host.create、item.update 等等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;params&amp;quot;&lt;/code&gt;-这里通过传递JSON对象来作为特定方法的参数。如果你希望创建监控项，&lt;code&gt;&amp;quot;name&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;key_&amp;quot;&lt;/code&gt; 参数是需要的，每个方法需要的参数在 Zabbix API 文档中都有描述。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;id&amp;quot;: 1&lt;/code&gt;-这个字段用于绑定 JSON 请求和响应。响应会跟请求有相同的 &amp;ldquo;id&amp;rdquo;。在一次性发送多个请求时很有用，这些也不需要唯一或者连续。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;auth&amp;quot;: &amp;quot;581cc92624202bddaeff3a90cca181dc&amp;quot;&lt;/code&gt;-这是一个认证令牌【authentication token】用以鉴别用户、访问API。这也是使用API进行相关操作的前提-获取认证ID。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-python-模拟-api-的使用&#34;&gt;使用 &lt;code&gt;python&lt;/code&gt; 模拟 API 的使用&lt;/h3&gt;

&lt;p&gt;这里我们使用python 3。&lt;/p&gt;

&lt;h4 id=&#34;安装必要模块&#34;&gt;安装必要模块&lt;/h4&gt;

&lt;p&gt;要使用 zabbix 的 API 接口，需要用 pip 安装 &lt;code&gt;zabbix-api&lt;/code&gt; 模块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install zabbix-api
$ pip list
iniparse (0.3.1)
ordereddict (1.2)
pip (8.1.0)
pycurl (7.19.0)
pygpgme (0.1)
setuptools (19.6.2)
urlgrabber (3.9.1)
yum-metadata-parser (1.1.2)
zabbix-api (0.4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;查询某主机获取hostid&#34;&gt;查询某主机获取hostid&lt;/h4&gt;

&lt;p&gt;写一个 &lt;code&gt;python&lt;/code&gt; 脚本，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ vim get_hostid.py
#!/usr/bin/env python
# encoding: utf-8

from zabbix_api import ZabbixAPI
server = &amp;quot;http://172.16.241.130/zabbix&amp;quot;
username = &amp;quot;Admin&amp;quot;
password = &amp;quot;zabbix&amp;quot;
zapi = ZabbixAPI(server=server, path=&amp;quot;&amp;quot;, log_level=0)
zapi.login(username, password)

## 通过计算机名查找hostid
hostinfo=zapi.host.get({&amp;quot;output&amp;quot;:&amp;quot;extend&amp;quot;,&amp;quot;filter&amp;quot;:{&amp;quot;host&amp;quot;:&amp;quot;Zabbix server&amp;quot;}})
hostid_01=hostinfo[0][&#39;hostid&#39;]
print(hostid_01)

## 通过主机可见名查找hostid
hostinfo=zapi.host.get({&amp;quot;output&amp;quot;:&amp;quot;extend&amp;quot;,&amp;quot;filter&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;Zabbix server&amp;quot;}})
hostid_02=hostinfo[0][&#39;hostid&#39;]
print(hostid_02)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行脚本，得到结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python get_hostid.py
&#39;10084&#39;
&#39;10084&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;获取目标主机对应的监控项和监控项具体名称&#34;&gt;获取目标主机对应的监控项和监控项具体名称&lt;/h4&gt;

&lt;p&gt;写一个 &lt;code&gt;python&lt;/code&gt; 脚本，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ vim get_items.py
#!/usr/bin/env python
# encoding: utf-8

from zabbix_api import ZabbixAPI
import pprint
server = &amp;quot;http://172.16.241.130/zabbix&amp;quot;
username = &amp;quot;Admin&amp;quot;
password = &amp;quot;zabbix&amp;quot;
zapi = ZabbixAPI(server=server, path=&amp;quot;&amp;quot;, log_level=0)
zapi.login(username, password)

result = zapi.item.get({&amp;quot;output&amp;quot;: [&amp;quot;itemids&amp;quot;, &amp;quot;key_&amp;quot;], &amp;quot;host&amp;quot;: &amp;quot;Zabbix server&amp;quot;})
pprint.pprint(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行脚本，得到结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python get_items.py
[{&#39;itemid&#39;: &#39;23327&#39;, &#39;key_&#39;: &#39;agent.hostname&#39;},
 {&#39;itemid&#39;: &#39;23287&#39;, &#39;key_&#39;: &#39;agent.ping&#39;},
 {&#39;itemid&#39;: &#39;23288&#39;, &#39;key_&#39;: &#39;agent.version&#39;},
 {&#39;itemid&#39;: &#39;23289&#39;, &#39;key_&#39;: &#39;kernel.maxfiles&#39;},
 {&#39;itemid&#39;: &#39;23290&#39;, &#39;key_&#39;: &#39;kernel.maxproc&#39;},
 {&#39;itemid&#39;: &#39;23683&#39;, &#39;key_&#39;: &#39;mysql.ping&#39;},
 {&#39;itemid&#39;: &#39;23684&#39;, &#39;key_&#39;: &#39;mysql.status[Bytes_received]&#39;},
 {&#39;itemid&#39;: &#39;23685&#39;, &#39;key_&#39;: &#39;mysql.status[Bytes_sent]&#39;},
--snip--
 {&#39;itemid&#39;: &#39;23635&#39;, &#39;key_&#39;: &#39;zabbix[vmware,buffer,pfree]&#39;},
 {&#39;itemid&#39;: &#39;23274&#39;, &#39;key_&#39;: &#39;zabbix[wcache,history,pfree]&#39;},
 {&#39;itemid&#39;: &#39;23275&#39;, &#39;key_&#39;: &#39;zabbix[wcache,index,pfree]&#39;},
 {&#39;itemid&#39;: &#39;23276&#39;, &#39;key_&#39;: &#39;zabbix[wcache,trend,pfree]&#39;},
 {&#39;itemid&#39;: &#39;23277&#39;, &#39;key_&#39;: &#39;zabbix[wcache,values]&#39;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;获取对应监控项的历史数据&#34;&gt;获取对应监控项的历史数据&lt;/h4&gt;

&lt;p&gt;写一个 &lt;code&gt;python&lt;/code&gt; 脚本，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ vim get_items.py
#!/usr/bin/env python
# encoding: utf-8

from zabbix_api import ZabbixAPI
import pprint
server = &amp;quot;http://172.16.241.130/zabbix&amp;quot;
username = &amp;quot;Admin&amp;quot;
password = &amp;quot;zabbix&amp;quot;
zapi = ZabbixAPI(server=server, path=&amp;quot;&amp;quot;, log_level=0)
zapi.login(username, password)

result = zapi.history.get({&amp;quot;output&amp;quot;: &amp;quot;extend&amp;quot;, &amp;quot;history&amp;quot;: 0, &amp;quot;itemids&amp;quot;: &amp;quot;23296&amp;quot;, &amp;quot;sortfield&amp;quot;: &amp;quot;clock&amp;quot;, &amp;quot;sortorder&amp;quot;: &amp;quot;DESC&amp;quot;, &amp;quot;limit&amp;quot;: 10})
pprint.pprint(result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行脚本，得到结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python get_items.py
[{&#39;clock&#39;: &#39;1483637416&#39;,
  &#39;itemid&#39;: &#39;23296&#39;,
  &#39;ns&#39;: &#39;833400783&#39;,
  &#39;value&#39;: &#39;0.0100&#39;},
 {&#39;clock&#39;: &#39;1483637356&#39;,
  &#39;itemid&#39;: &#39;23296&#39;,
  &#39;ns&#39;: &#39;102860881&#39;,
  &#39;value&#39;: &#39;0.0300&#39;},
 {&#39;clock&#39;: &#39;1483637296&#39;,
  &#39;itemid&#39;: &#39;23296&#39;,
  &#39;ns&#39;: &#39;609325047&#39;,
  &#39;value&#39;: &#39;0.0800&#39;},
 {&#39;clock&#39;: &#39;1483637236&#39;,
  &#39;itemid&#39;: &#39;23296&#39;,
  &#39;ns&#39;: &#39;31887252&#39;,
  &#39;value&#39;: &#39;0.1300&#39;},
--snip--
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;获取对应监控项一段时间内的历史数据并格式化输出&#34;&gt;获取对应监控项一段时间内的历史数据并格式化输出&lt;/h4&gt;

&lt;p&gt;写一个 &lt;code&gt;python&lt;/code&gt; 脚本，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ vim history_data.py
#!/usr/bin/env python
# encoding: utf-8

&amp;quot;&amp;quot;&amp;quot;
Retrieves history data for a given numeric (either int or float) item_id
&amp;quot;&amp;quot;&amp;quot;

from zabbix_api import ZabbixAPI
import pprint
from datetime import datetime
import time
server = &amp;quot;http://172.16.241.130/zabbix&amp;quot;
username = &amp;quot;Admin&amp;quot;
password = &amp;quot;zabbix&amp;quot;
zapi = ZabbixAPI(server=server)
zapi.login(username, password)
item_id = &amp;quot;23296&amp;quot;

# Create a time range
time_till = time.mktime(datetime.now().timetuple())
time_from = time_till - 60 * 60 * 24 * 10  # 10 days

# Query item&#39;s history (integer) data
history = zapi.history.get({&amp;quot;itemids&amp;quot;: item_id, &amp;quot;time_from&amp;quot;: time_from, &amp;quot;time_till&amp;quot;: time_till, &amp;quot;output&amp;quot;: &amp;quot;extend&amp;quot;, &amp;quot;limit&amp;quot;: &amp;quot;10&amp;quot;})

# If nothing was found, try getting it from history (float) data
if not len(history):
    history = zapi.history.get({&amp;quot;itemids&amp;quot;: item_id, &amp;quot;time_from&amp;quot;: time_from, &amp;quot;time_till&amp;quot;: time_till, &amp;quot;output&amp;quot;: &amp;quot;extend&amp;quot;, &amp;quot;limit&amp;quot;: &amp;quot;10&amp;quot;, &amp;quot;history&amp;quot;: 0})

for point in history:
        print(&amp;quot;{0}: {1}&amp;quot;.format(datetime.fromtimestamp(int(point[&#39;clock&#39;]))
                                .strftime(&amp;quot;%x %X&amp;quot;), point[&#39;value&#39;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行脚本，得到结果为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ python history_data.py
12/29/16 09:40:16: 0.4900
12/29/16 09:41:16: 0.1800
12/29/16 09:42:16: 0.1600
12/29/16 09:43:16: 0.2000
12/29/16 09:44:16: 0.0700
12/29/16 09:45:16: 0.1000
12/29/16 09:46:16: 0.2100
12/29/16 09:47:16: 0.0700
12/29/16 09:48:16: 0.5100
12/29/16 09:49:16: 0.2200
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Python3 系列之文件读写</title>
      <link>https://www.yangcs.net:443/posts/python3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</link>
      <pubDate>Tue, 03 Jan 2017 08:51:06 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/python3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</guid>
      <description>&lt;p&gt;
&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=0 height=0 src=&#34;http://other.web.rh01.sycdn.kuwo.cn/resource/n2/2/46/1567406567.mp3&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-文件与文件路径-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;文件与文件路径&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;用到的模块：&lt;code&gt;os&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-1-当前工作目录&#34;&gt;1.1 当前工作目录&lt;/h3&gt;

&lt;p&gt;在交互模式下输入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import os
&amp;gt;&amp;gt;&amp;gt; os.getcwd()
&#39;/tmp&#39;
&amp;gt;&amp;gt;&amp;gt; os.chdir(&#39;/home/yang/test&#39;)
&amp;gt;&amp;gt;&amp;gt; os.getcwd()
&#39;/home/yang/test&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要更改的当前目录不存在，&lt;code&gt;Pyhton&lt;/code&gt;就会显示一个错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; os.chdir(&#39;/user/bin&#39;)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
FileNotFoundError: [Errno 2] No such file or directory: &#39;/user/bin&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-创建新文件夹&#34;&gt;1.2 创建新文件夹&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; os.makedirs(&#39;/tmp/test&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它会递归地创建文件夹，也就是说，&lt;code&gt;os.makedirs()&lt;/code&gt; 将创建所有必要的中间文件夹。&lt;/p&gt;

&lt;h3 id=&#34;1-3-处理绝对路径和相对路径&#34;&gt;1.3 处理绝对路径和相对路径&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.path.abspath(path)&lt;/code&gt;：返回参数的&lt;code&gt;绝对路径&lt;/code&gt;的字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; os.path.abspath(&#39;.&#39;)
&#39;/tmp&#39;
&amp;gt;&amp;gt;&amp;gt; os.path.abspath(&#39;./test&#39;)
&#39;/tmp/test&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.path.isabs(path)&lt;/code&gt;：如果参数是一个绝对路径，就返回True，如果参数是一个相对路径，就返回False&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; os.path.isabs(&#39;.&#39;)
False
&amp;gt;&amp;gt;&amp;gt; os.path.isabs(os.path.abspath(&#39;.&#39;))
True
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.path.relpath(path, start)&lt;/code&gt;：返回从 start 路径到 path 的相对路径的字符串。如果没有提供 start，就使用当前工作目录作为开始路径。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; os.path.relpath(&#39;/home/yang&#39;, &#39;/tmp&#39;)
&#39;../home/yang&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.path.dirname(path)&lt;/code&gt;：返回一个字符串，它包含&lt;code&gt;path&lt;/code&gt;参数中最后一个斜杠&lt;span id=&#34;inline-blue&#34;&gt;之前&lt;/span&gt;的所有内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.basename(path)&lt;/code&gt;：返回一个字符串，它包含&lt;code&gt;path&lt;/code&gt;参数中最后一个斜杠&lt;span id=&#34;inline-blue&#34;&gt;之后&lt;/span&gt;的所有内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; path = &#39;/usr/bin/vlc&#39;
&amp;gt;&amp;gt;&amp;gt; os.path.basename(path)
&#39;vlc&#39;
&amp;gt;&amp;gt;&amp;gt; os.path.dirname(path)
&#39;/usr/bin&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.path.split()&lt;/code&gt;：获取一个路径的&lt;span id=&#34;inline-blue&#34;&gt;目录名称和基本名称&lt;/span&gt;这两个字符串的元组。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; path = &#39;/usr/bin/vlc&#39;
&amp;gt;&amp;gt;&amp;gt; os.path.split(path)
(&#39;/usr/bin&#39;, &#39;vlc&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.path.split()&lt;/code&gt;不会接受一个文件路径并返回每个文件夹的字符串的列表。如果需要这样，请使用&lt;code&gt;split()&lt;/code&gt;字符串方法。&lt;code&gt;os.path.sep&lt;/code&gt;设置为正确的文件夹分割斜杠。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; path.split(os.path.sep)
[&#39;&#39;, &#39;usr&#39;, &#39;bin&#39;, &#39;vlc&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-4-查看文件大小和文件夹内容&#34;&gt;1.4 查看文件大小和文件夹内容&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;os.path.getsize(path)：返回path参数中文件的字节数。&lt;/li&gt;
&lt;li&gt;os.listdir(path)：返回文件名字符串的列表，包含path参数中的每个文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; os.path.getsize(&#39;/usr/bin/vlc&#39;)
14712
&amp;gt;&amp;gt;&amp;gt; os.listdir(&#39;/etc&#39;)
[&#39;ld.so.conf.d&#39;, &#39;skel&#39;, &#39;profile.d&#39;, &#39;fstab&#39;, &#39;shells&#39;, &#39;rpc&#39;, &#39;nscd.conf&#39;, &#39;gai.conf&#39;, &#39;locale.gen&#39;, &#39;ssl&#39;, &#39;dbus-1&#39;, &#39;ethertypes&#39;, &#39;iptables&#39;, 
--snip--
&#39;logrotate.conf&#39;, &#39;man_db.conf&#39;, &#39;pacman.conf&#39;, &#39;wgetrc&#39;, &#39;cpufreq-bench.conf&#39;, &#39;papersize&#39;, &#39;nanorc&#39;, &#39;ld.so.cache&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想知道这个目录下所有文件的总字节数，就可以同时使用 os.path.getsize() 和 os.listdir()。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; totalSize = 0
&amp;gt;&amp;gt;&amp;gt; for filename in os.listdir(&#39;/etc&#39;):
        totalSize = totalSize + os.path.getsize(os.path.join(&#39;/etc&#39;, filename))
&amp;gt;&amp;gt;&amp;gt; print(totalSize)
846656
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-5-检查路径有效性&#34;&gt;1.5 检查路径有效性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.path.exists(path)&lt;/code&gt;：如果path参数所指的文件或文件夹存在，将返回True，否则返回False。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.isfile(path)&lt;/code&gt;：如果path参数存在，并且是一个文件，将返回True，否则返回False。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.path.isdir(path)&lt;/code&gt;：如果path参数存在，并且是一个文件夹，将返回True，否则返回False。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; os.path.exists(&#39;/tmp&#39;)
True
&amp;gt;&amp;gt;&amp;gt; os.path.exists(&#39;/user/bin&#39;)
False
&amp;gt;&amp;gt;&amp;gt; os.path.isdir(&#39;/tmp&#39;)
True
&amp;gt;&amp;gt;&amp;gt; os.path.isfile(&#39;/tmp&#39;)
False
&amp;gt;&amp;gt;&amp;gt; os.path.isdir(&#39;/usr/bin/vlc&#39;)
False
&amp;gt;&amp;gt;&amp;gt; os.path.isfile(&#39;/usr/bin/vlc&#39;)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-文件读写过程-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;文件读写过程&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在 Python 中，读写文件有3个步骤：&lt;/p&gt;

&lt;p&gt;1、调用 &lt;code&gt;open()&lt;/code&gt; 函数，返回一个 File 对象。&lt;br /&gt;
2、调用 File 对象的 &lt;code&gt;read()&lt;/code&gt; 或 &lt;code&gt;write()&lt;/code&gt; 方法。&lt;br /&gt;
3、调用 File 对象的 &lt;code&gt;close()&lt;/code&gt; 方法，关闭该文件。&lt;/p&gt;

&lt;h3 id=&#34;2-1-创建文件&#34;&gt;2.1 创建文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f = open(&#39;test.txt&#39;,&#39;w&#39;)
&amp;gt;&amp;gt;&amp;gt; f.write(&#39;Hello world!&#39;)
# 因为此时写入的数据还在内存中，并没有被写入磁盘，所以要关闭之后才能读取到数据
&amp;gt;&amp;gt;&amp;gt; f.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想不关闭就能读取到数据，可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f.flush()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-读取文件&#34;&gt;2.2 读取文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 默认以“r”模式打开文本（只读）
&amp;gt;&amp;gt;&amp;gt; f = open(&#39;test.txt&#39;)
# 读取文本中所有内容
&amp;gt;&amp;gt;&amp;gt; f.read()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果这时再用f.readline()读取文本，将会得到空字符串，因为它是以迭代器的方式打开这个文本，所以此时它的内存指针已经指向了文本的最后一行&lt;/p&gt;

&lt;p&gt;如果还想可以继续读，可以把它的内存指针指向第一行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 查看内存指针的位置
&amp;gt;&amp;gt;&amp;gt; f.tell()
# 将内存指针指向第一行
&amp;gt;&amp;gt;&amp;gt; f.seek(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-遍历文件内容&#34;&gt;2.3 遍历文件内容&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; a = open(&#39;user_info.txt&#39;)
&amp;gt;&amp;gt;&amp;gt; for line in a.readlines():
    # 加上逗号可以避免打印换行符
        print(line),
&amp;gt;&amp;gt;&amp;gt; a.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=#8A2BE2&gt;readlines&lt;/font&gt;将文本中的所有内容都读取到了内存中，对于大文本来说会很耗内存。
为了解决这个问题，我们可以使用&lt;font color=#8A2BE2&gt;xreadlines。&lt;/font&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-4-追加&#34;&gt;2.4 追加&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; F = open(&#39;test.txt&#39;,&#39;a&#39;)
&amp;gt;&amp;gt;&amp;gt; F.write(&amp;quot;append to the end&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; f.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-用-pprint-pformat-函数保存变量&#34;&gt;2.5 用 &lt;code&gt;pprint.pformat()&lt;/code&gt; 函数保存变量&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;pprint.pformat()&lt;/code&gt; 函数将返回同样的文本字符串，但不是打印它。这个字符串不仅是易于阅读的格式，同时也是语法上正确的 Pthon 代码。&lt;code&gt;pprint.pformat()&lt;/code&gt; 函数将提供一个字符串，你可以将它写入.py文件，该文件将成为你字节的&lt;span id=&#34;inline-blue&#34;&gt;模块&lt;/span&gt;，如果你需要使用存储在其中的变量，就可以导入它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import pprint
&amp;gt;&amp;gt;&amp;gt; cats = [{&#39;name&#39;: &#39;Zophie&#39;, &#39;desc&#39;: &#39;chubby&#39;}, {&#39;name&#39;: &#39;Pooka&#39;, &#39;desc&#39;: &#39;fluffy&#39;}]
&amp;gt;&amp;gt;&amp;gt; pprint.pformat(cats)
&amp;quot;[{&#39;desc&#39;: &#39;chubby&#39;, &#39;name&#39;: &#39;Zophie&#39;}, {&#39;desc&#39;: &#39;fluffy&#39;, &#39;name&#39;: &#39;Pooka&#39;}]&amp;quot;
&amp;gt;&amp;gt;&amp;gt; file = open(&#39;myCats.py&#39;, &#39;w&#39;)
&amp;gt;&amp;gt;&amp;gt; file.write(&#39;cats = &#39; + pprint.pformat(cats) + &#39;\n&#39;)
83
&amp;gt;&amp;gt;&amp;gt; file.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;import 语句导入的模块本身就是 Python 脚本。如果来自 &lt;code&gt;pprint.pformat()&lt;/code&gt; 的字符串保存为一个.py文件，该文件就是一个可以导入的模块，像其他模块一样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import myCats
&amp;gt;&amp;gt;&amp;gt; myCats.cats
[{&#39;desc&#39;: &#39;chubby&#39;, &#39;name&#39;: &#39;Zophie&#39;}, {&#39;desc&#39;: &#39;fluffy&#39;, &#39;name&#39;: &#39;Pooka&#39;}]
&amp;gt;&amp;gt;&amp;gt; myCats.cats[0]
{&#39;desc&#39;: &#39;chubby&#39;, &#39;name&#39;: &#39;Zophie&#39;}
&amp;gt;&amp;gt;&amp;gt; myCats.cats[0][&#39;name&#39;]
&#39;Zophie&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用-shelf-模块保存变量&#34;&gt;用 &lt;code&gt;shelf&lt;/code&gt; 模块保存变量&lt;/h3&gt;

&lt;p&gt;shelve类似于一个 &lt;code&gt;key-value&lt;/code&gt; 数据库，可以很方便的用来保存Python的内存对象，其内部使用 &lt;code&gt;pickle&lt;/code&gt; 来序列化数据，简单来说，使用者可以将一个列表、字典、或者用户自定义的类实例保存到 &lt;code&gt;shelve&lt;/code&gt; 中，下次需要用的时候直接取出来，就是一个 Python 内存对象，不需要像传统数据库一样，先取出数据，然后用这些数据重新构造一遍所需要的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import shelve
&amp;gt;&amp;gt;&amp;gt; shelfFile = shelve.open(&#39;mydata&#39;)
&amp;gt;&amp;gt;&amp;gt; cats = [&#39;Zophie&#39;, &#39;Pooka&#39;, &#39;Simon&#39;]
&amp;gt;&amp;gt;&amp;gt; shelfFile[&#39;cats&#39;] = cats
&amp;gt;&amp;gt;&amp;gt; shelfFile.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shelf值不必使用读模式或写模式打开，因为它们在打开后，既能读又能写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; shelfFile = shelve.open(&#39;mydata&#39;)
&amp;gt;&amp;gt;&amp;gt; type(shelfFile)
&amp;lt;class &#39;shelve.DbfilenameShelf&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; shelfFile[&#39;cats&#39;]
[&#39;Zophie&#39;, &#39;Pooka&#39;, &#39;Simon&#39;]
&amp;gt;&amp;gt;&amp;gt; shelfFile.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像字典一样，&lt;code&gt;shelf&lt;/code&gt; 值有 &lt;code&gt;keys()&lt;/code&gt; 和 &lt;code&gt;values()&lt;/code&gt; 方法，返回 shelf 中键和值的类似列表的值。因为这些方法返回类似列表的值，而不是真正的列表，所以应该将它们传递给 &lt;code&gt;list()&lt;/code&gt; 函数，取得列表的形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; shelfFile = shelve.open(&#39;mydata&#39;)
&amp;gt;&amp;gt;&amp;gt; list(shelfFile.keys())
[&#39;cats&#39;]
&amp;gt;&amp;gt;&amp;gt; list(shelfFile.values())
[[&#39;Zophie&#39;, &#39;Pooka&#39;, &#39;Simon&#39;]]
&amp;gt;&amp;gt;&amp;gt; shelfFile.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p id=&#34;div-border-left-red&#34;&gt;创建文件时，如果你需要在文本编辑器中读取它们，纯文本就非常有用。但是，如果想要保存 `Python` 程序中的数据，那就使用 `shelve` 模块&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-3-项目-多重剪切板-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;3. &lt;strong&gt;项目：多重剪切板&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;该程序被命名为 &lt;code&gt;mcb.py&lt;/code&gt;，该程序将利用一个关键字保存每段剪切板文本。例如，当运行&lt;code&gt;python mcb.py spam&lt;/code&gt;，这段文本稍后将重新加载到剪切板中。如果用户忘了有哪些关键字，他们可以运行 &lt;code&gt;python mcb.py list&lt;/code&gt;，将所有关键字的列表复制到剪切板中。&lt;/p&gt;

&lt;p&gt;下面是程序要做的事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;针对要检查的关键字，提供命令行参数。&lt;/li&gt;
&lt;li&gt;如果参数是 &lt;code&gt;save&lt;/code&gt;，那么将剪切板的内容保存到关键字。&lt;/li&gt;
&lt;li&gt;如果参数是 &lt;code&gt;list&lt;/code&gt;，就将所有的&lt;span id=&#34;inline-purple&#34;&gt;关键字&lt;/span&gt;拷贝到剪切板。&lt;/li&gt;
&lt;li&gt;否则，就将关键词对应的文本拷贝到剪切板。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这意味着代码要做下列事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从 &lt;code&gt;sys.argv&lt;/code&gt; 读取命令行参数。&lt;/li&gt;
&lt;li&gt;读写剪切板。&lt;/li&gt;
&lt;li&gt;保存并加载 &lt;code&gt;shelve&lt;/code&gt; 文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要安装的软件（以Archlinux为例）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S python-pyperclip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下软件只需选择其中一种安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S xsel
$ pacman -S xclip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-1-注释和-shelve-设置&#34;&gt;3.1 注释和 &lt;code&gt;shelve&lt;/code&gt; 设置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;   #! python3
   # mcb.pyw - Save and loads pieces of text to the clipboard.
   # Usage: py mcb.pyw save &amp;lt;keyword&amp;gt; - Save clipboard to keyword.
   #        py mcb.pyw &amp;lt;keyword&amp;gt; - Load keyword to clipboard.
   #        py mcb.pyw list - Loads all keywords to clipboard.
(1)import shelve, pyperclip, sys

(2)mcbShelf = shelve.open(&#39;mcb&#39;)

   # TODO: Save clipboard content.

   # TODO: Save clipboard content

   mcbShelf.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(1)&lt;/span&gt; 拷贝和粘贴需要 &lt;code&gt;pyperclip&lt;/code&gt; 模块，读取命令行参数需要 &lt;code&gt;sys&lt;/code&gt; 模块。&lt;code&gt;shelve&lt;/code&gt; 模块也需要准备好，当用户希望保存一段剪切板文本时，你需要将它保存到一个 &lt;code&gt;shelf&lt;/code&gt; 文件中。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(2)&lt;/span&gt; 当用户希望将文本拷贝回剪切板时，你需要打开 shelf 文件，将它重新加载到程序中。这个 shelf 文件命名时带有前缀 &lt;code&gt;mcb&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;3-2-用一个关键字保存剪切板内容&#34;&gt;3.2 用一个关键字保存剪切板内容&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;   #! python3
   # mcb.pyw - Save and loads pieces of text to the clipboard.
   --snip--
   
   # Save clipboard content.
(1)if len(sys.argv) == 3 and sys.argv[1].lower() == &#39;save&#39;:
(2)    mcbShelf[sys.argv[2]] = pyperclip.paste()
   elif len(sys.argv) == 2:
(3)# TODO: List keywords and load content

   mcbShelf.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(1)&lt;/span&gt; 如果第一个命令行参数是字符串 &lt;code&gt;save&lt;/code&gt;，&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(2)&lt;/span&gt; 那么第二个命令行参数就是保存剪切板内容的当前关键字。关键字将用作 &lt;code&gt;mcbShelf&lt;/code&gt;中的键，值就是剪切板上的文本。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(3)&lt;/span&gt; 如果只有一个命令行参数，就假定它要么是 &lt;code&gt;list&lt;/code&gt;，要么是需要加载到剪切板上的关键字。&lt;/p&gt;

&lt;h3 id=&#34;3-3-列出关键字和加载关键字的内容&#34;&gt;3.3 列出关键字和加载关键字的内容&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;   #! python3
   # mcb.pyw - Save and loads pieces of text to the clipboard.
   --snip--
   
   # Save clipboard content.
   if len(sys.argv) == 3 and sys.argv[1].lower() == &#39;save&#39;:
       mcbShelf[sys.argv[2]] = pyperclip.paste()
   elif len(sys.argv) == 2:
   # List keywords and load content
(1)if sys.argv[1].lower() == &#39;list&#39;:
(2)     pyperclip.copy(str(list(mcbShelf.keys())))
   elif sys.argv[1] in mcbShelf:
(3)     pyperclip.copy(mcbShelf[sys.argv[1]])

   mcbShelf.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(1)&lt;/span&gt; 如果只有一个命令行参数，首先检查它是不是 &lt;code&gt;list&lt;/code&gt;。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(2)&lt;/span&gt; 如果是，表示 &lt;code&gt;shelf&lt;/code&gt; 键的列表的字符串将被拷贝到剪切板。用户可以将这个列表拷贝到一个打开的文本编辑器，进行查看。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;display:inline; padding:.2em .6em .3em; font-size:80%; font-weight:bold; line-height:1; color:#fff; text-align:center; white-space:nowrap; vertical-align:baseline; border-radius:0; background-color: #2780e3;&#34;&gt;(3)&lt;/span&gt; 否则，你可以假定该命令行参数是一个关键字。如果这个关键字是 &lt;code&gt;shelf&lt;/code&gt; 中的一个键，就可以将对应的值加载到剪切板。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Iptables基础原理之tcp/ip协议</title>
      <link>https://www.yangcs.net:443/posts/iptables%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E4%B9%8Btcp-ip%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 26 Dec 2016 09:17:42 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/iptables%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E4%B9%8Btcp-ip%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;p&gt;
&lt;iframe width=&#34;0&#34; height=&#34;0&#34; frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; src=&#34;http://yangchuansheng-netease.daoapp.io/player?type=2&amp;amp;id=405597568&amp;amp;auto=1&amp;amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-ip-首部-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;IP 首部&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/ipv4header.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IP Version&lt;/code&gt;：协议版本号，这里指ipv4&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Header Length&lt;/code&gt;：IP 首部长度
首部长度共设置了4 bit，4 bit的取值范围0-15，由于每一个字段的长度是32位，也就是4个字节，所以首部最长为15 * 4 = 60个字节。
而常见的ip首部长度为20字节，所以在首部长度中更多的是5，4*5=20。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Type Of Service&lt;/code&gt;（TOS）：服务类型。
包括 3 bits 的优先权子字段（现在已被忽略），4 bits 的 TOS 子字段和 1 bit 未用但必须设置为0。
4 bits 的 TOS 分别代表：最小时延、最大吞吐量、最高可靠性和和最小费用。
4 bits 中只能有 1 bit 设置为 1。如果所有 4 bits 均为 0，就意味着是一般服务。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;图1列出了对不同应用建议的&lt;code&gt;TOS&lt;/code&gt;值。最后一列给出的是十六进制值，因为这就是后面将要看到的&lt;code&gt;tcpdump&lt;/code&gt;命令输出。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5%E6%8E%A8%E8%8D%90%E5%80%BCjpg&#34; alt=&#34;服务类型字段推荐值&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;font size=2&gt;图1 服务类型字段推荐值&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Total Length&lt;/code&gt;：整个IP数据报的长度，以字节为单位。
&lt;code&gt;Total Length&lt;/code&gt; - &lt;code&gt;Header Length&lt;/code&gt; = data 长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Identification&lt;/code&gt;（&lt;code&gt;Fragment ID&lt;/code&gt;）：标识字段（段ID）。
当一个IP报文在网上传输的时候，如果两个物理设备所支持的报文大小不相同，那么必须要对报文进行分片。当所有的分片都到达目标主机后，必须要将这些分片合并为一个IP报文，否则没有意义。段ID可以告诉我们哪些分片属于同一个IP报文。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DF&lt;/code&gt;：Don&amp;rsquo;t Fragment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MF&lt;/code&gt;：More Fragment&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fragment Offset&lt;/code&gt;：段偏移。
表示分段的数据报在整个数据流中的位置，即相当于分片数据报的顺序号。
发送主机对第一个数据报的段偏移量置为0，而后续的分片数据报的段偏移量则以网络的&lt;code&gt;MTU&lt;/code&gt;大小赋值。
段偏移量对于接收方进行数据重组的时候，这是一个关键的字段。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Time To Live&lt;/code&gt;（&lt;code&gt;TTL&lt;/code&gt;）：设置了数据报可以经过的最多&lt;code&gt;路由器&lt;/code&gt;数。它指定了数据报的生存时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Protocol&lt;/code&gt;：协议。指定&lt;code&gt;data&lt;/code&gt;中包含的协议，如TCP、UDP、ICMP。根据它可以识别是哪个协议向&lt;code&gt;IP&lt;/code&gt;发送数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Header Checksum&lt;/code&gt;：校验和。
报文首部在发送过程中可能会发生差错，所以需要通过校验和来进行验证，一旦验证出现错误，便进行重传。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt;：可变长度的可选数据。很少使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-2-tcp-首部-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;2. &lt;strong&gt;TCP 首部&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;要想真正承载应用协议从一个主机到另一个主机，那我们就应该知道两台主机上的哪些&lt;code&gt;进程&lt;/code&gt;之间在进行通信。所以众多的上层应用协议都是基于&lt;code&gt;tcp&lt;/code&gt;或者&lt;code&gt;udp&lt;/code&gt;来完成数据报文的再次封装以标记通信的两个进程。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tcp&lt;/code&gt;和&lt;code&gt;udp&lt;/code&gt;都是通过端口号来进行标识，每打开一个端口，就称为打开一个&lt;code&gt;套接字文件&lt;/code&gt;。
端口号的取值范围一般是 0-65535。在linux主机中，0-1023端口范围只有管理员才有权使用。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/TCP-header.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;font size=2&gt;图2 TCP 首部&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Sequence Number&lt;/code&gt;：序列号。
发送方告诉接收方我所发送的这个报文的编号，它表示在这个报文段中的第一个数据字节。
第一次的编号可能是随机，以后每次+1。
序列号是 32 bits 的无符号数，到达$2^{32}-1$后又从0开始。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Acknowledgement Number&lt;/code&gt;：确认号。
把对方的序列号+1，并会送给对方，告诉它我收到了。
只有&lt;code&gt;ACK&lt;/code&gt;标志为1时确认号才有效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Reserved&lt;/code&gt;：保留字段。不常用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;URG&lt;/code&gt;：紧急指针（Urgent Pointer）有效。
URG = 1，表示紧急指针有效
URG = 0，表示紧急指针无效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PSH&lt;/code&gt;：推送。一旦发生了推送，就意味着这个报文一定不能在缓存中停留，应该立即递给内核，所以这是一个需要内核优先处理的报文。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RST&lt;/code&gt;：重置。当连接发生抖动、发生故障的时候，有可能需要进行重置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYN&lt;/code&gt;：同步请求。我们建立联系的第一个请求报文必须要发送&lt;code&gt;SYN&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIN&lt;/code&gt;：断开连接请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Window Size&lt;/code&gt;：滑动窗口大小。
一次发送一个报文速度很慢，为了提高速度，可以一次发送多个报文，滑动窗口大小决定了一次可以发送多少个报文。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TCP Checksum&lt;/code&gt;：校验和。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Urgent Pointer&lt;/code&gt;：紧急指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-3-建立连接-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;3. &lt;strong&gt;建立连接&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;两台主机，谁也没有跟其他主机通信的时候，大家默认都是&lt;code&gt;closed&lt;/code&gt;，要让一方能够接收其他主机的请求，它要从&lt;code&gt;closed&lt;/code&gt;转为&lt;code&gt;listen&lt;/code&gt;状态。&lt;/p&gt;

&lt;p&gt;1、客户端通过向服务器端发送一个&lt;code&gt;SYN&lt;/code&gt;来建立一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数A。&lt;/p&gt;

&lt;p&gt;2、服务器端应当为一个合法的&lt;code&gt;SYN&lt;/code&gt;回送一个&lt;code&gt;SYN/ACK&lt;/code&gt;。&lt;code&gt;ACK&lt;/code&gt;的确认码应为A+1，&lt;code&gt;SYN/ACK&lt;/code&gt;包本身又有一个随机序号B。&lt;/p&gt;

&lt;p&gt;3、最后，客户端再发送一个&lt;code&gt;ACK&lt;/code&gt;。当服务端受到这个&lt;code&gt;ACK&lt;/code&gt;的时候，就完成了三路握手，并进入了连接建立状态。此时包序号被设定为收到的确认号A+1，而响应则为B+1。&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-4-断开连接-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;4. &lt;strong&gt;断开连接&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;那如何断开连接呢？简单的过程如下：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/tcp%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【注意】中断连接端可以是Client端，也可以是Server端。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设&lt;code&gt;Client&lt;/code&gt;端发起中断连接请求，也就是发送&lt;code&gt;FIN&lt;/code&gt;报文。&lt;code&gt;Server&lt;/code&gt;端接到&lt;code&gt;FIN&lt;/code&gt;报文后，意思是说&amp;rdquo;&lt;font color=red&gt;我Client端没有数据要发给你了&lt;/font&gt;&amp;ldquo;，但是如果你还有数据没有发送完成，则不必急着关闭&lt;code&gt;Socket&lt;/code&gt;，可以继续发送数据。所以你先发送&lt;code&gt;ACK&lt;/code&gt;，&amp;rdquo;&lt;font color=red&gt;告诉&lt;code&gt;Client&lt;/code&gt;端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&lt;/font&gt;&amp;ldquo;。这个时候&lt;code&gt;Client&lt;/code&gt;端就进入&lt;code&gt;FIN_WAIT&lt;/code&gt;状态，继续等待&lt;code&gt;Server&lt;/code&gt;端的&lt;code&gt;FIN&lt;/code&gt;报文。当&lt;code&gt;Server&lt;/code&gt;端确定数据已发送完成，则向&lt;code&gt;Client&lt;/code&gt;端发送&lt;code&gt;FIN&lt;/code&gt;报文，&amp;rdquo;&lt;font color=red&gt;告诉&lt;code&gt;Client&lt;/code&gt;端，好了，我这边数据发完了，准备好关闭连接了&lt;/font&gt;&amp;ldquo;。&lt;code&gt;Client&lt;/code&gt;端收到&lt;code&gt;FIN&lt;/code&gt;报文后，“&lt;font color=red&gt;就知道可以关闭连接了，但是他还是不相信网络，怕&lt;code&gt;Server&lt;/code&gt;端不知道要关闭，所以发送&lt;code&gt;ACK&lt;/code&gt;后进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，如果&lt;code&gt;Server&lt;/code&gt;端没有收到&lt;code&gt;ACK&lt;/code&gt;则可以重传&lt;/font&gt;”。&lt;code&gt;Server&lt;/code&gt;端收到&lt;code&gt;ACK&lt;/code&gt;后，&amp;rdquo;&lt;font color=red&gt;就知道可以断开连接了&lt;/font&gt;&amp;ldquo;。&lt;code&gt;Client&lt;/code&gt;端等待了2 &lt;code&gt;MSL&lt;/code&gt; 后依然没有收到回复，则证明&lt;code&gt;Server&lt;/code&gt;端已正常关闭，那好，我&lt;code&gt;Client&lt;/code&gt;端也可以关闭连接了。Ok，&lt;code&gt;TCP&lt;/code&gt;连接就这样关闭了！&lt;/p&gt;

&lt;p&gt;整个过程&lt;code&gt;Client&lt;/code&gt;端所经历的状态如下：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/0_1312719804oSkK.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;Server&lt;/code&gt;端所经历的过程如下：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/0_1312719833030b.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; 在&lt;code&gt;TIME_WAIT&lt;/code&gt;状态中，如果&lt;code&gt;TCP client&lt;/code&gt;端最后一次发送的ACK丢失了，它将重新发送。&lt;code&gt;TIME_WAIT&lt;/code&gt;状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【问题1】&lt;/strong&gt;为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&amp;rdquo;你发的FIN报文我收到了&amp;rdquo;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【问题2】&lt;/strong&gt;为什么&lt;code&gt;TIME_WAIT&lt;/code&gt;状态需要经过2&lt;code&gt;MSL&lt;/code&gt;(最大报文段生存时间)才能返回到CLOSE状态？
答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以&lt;code&gt;TIME_WAIT&lt;/code&gt;状态就是用来重发可能丢失的ACK报文。&lt;/p&gt;

&lt;p&gt;整个TCP状态机过程如下：
&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(1) 突然有一台主机想成为服务器，被动打开，转化为&lt;code&gt;listen&lt;/code&gt;状态，等待客户端发起请求&lt;br /&gt;
(2) 客户端发起&lt;code&gt;SYN&lt;/code&gt;请求&lt;br /&gt;
(3) 服务端收到&lt;code&gt;SYN&lt;/code&gt;&lt;br /&gt;
(4) 客户端与服务端转化为&lt;code&gt;connection established&lt;/code&gt;&lt;br /&gt;
(5) 双方可以发送数据了&lt;br /&gt;
(6) 客户端发送分手请求，自己转化为&lt;code&gt;FIN WAIT 1&lt;/code&gt;状态，等待对方告诉我&lt;font color=red&gt;可以分手了&lt;/font&gt;&lt;br /&gt;
(7) 服务端收到&lt;code&gt;SYN&lt;/code&gt;，然后发送给对方&lt;code&gt;ACK&lt;/code&gt;进行确认，&lt;font color=red&gt;分手就分手&lt;/font&gt;&lt;br /&gt;
(8) 当服务端响应客户端后，服务端状态变为&lt;code&gt;CLOSE WAIT&lt;/code&gt;&lt;br /&gt;
(9) 客户端一旦收到了&lt;code&gt;ACK&lt;/code&gt;，就要等待对方的&lt;code&gt;FIN&lt;/code&gt;（整个过程叫&lt;code&gt;FIN WAIT 2&lt;/code&gt;）&lt;br /&gt;
(10) 客户端收到对方的&lt;code&gt;FIN&lt;/code&gt;后，给对方以&lt;code&gt;ACK&lt;/code&gt;，等待一段时间（大约2MSL）后，然后转化为&lt;code&gt;CLOSED&lt;/code&gt;状态&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>向量的叉乘与行列式</title>
      <link>https://www.yangcs.net:443/posts/%E5%90%91%E9%87%8F%E7%9A%84%E5%8F%89%E4%B9%98%E4%B8%8E%E8%A1%8C%E5%88%97%E5%BC%8F/</link>
      <pubDate>Sat, 03 Dec 2016 23:59:48 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/%E5%90%91%E9%87%8F%E7%9A%84%E5%8F%89%E4%B9%98%E4%B8%8E%E8%A1%8C%E5%88%97%E5%BC%8F/</guid>
      <description>&lt;p&gt;
&lt;strong&gt;为了循序渐进，先从二维开始讲起，然后过渡到三维&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-二维空间-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;二维空间&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;我们从一个五边形的面积开始说起&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E6%AD%A3%E4%BA%94%E8%BE%B9%E5%BD%A2.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;比如我们要求这个正五边形的面积，该怎样用向量求呢？&lt;/p&gt;

&lt;p&gt;先简化这个问题，不用考虑五边形，只需考虑三角形。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E4%BA%94%E8%BE%B9%E5%BD%A22.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;现在，我们把正五边形分割成三个三角形，再把三角形的面积加起来，就得到了五边形的面积。&lt;/p&gt;

&lt;p&gt;那么问题来了：&lt;strong&gt;怎样求三角形的面积？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E4%B8%89%E8%A7%92%E5%BD%A2.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;设三角形的面积为S，那么&lt;/p&gt;

&lt;p&gt;$$
S = \frac{1}{2}\left|\vec{A}\right|\left|\vec{MN}\right| = \frac{1}{2}\left|\vec{A}\right|\left|\vec{B}\right|\sin(\theta) \tag{1}
$$&lt;/p&gt;

&lt;p&gt;$\sin(\theta)$该如何求呢？&lt;/p&gt;

&lt;p&gt;如果你学过向量的点积，应该知道$\vec{a}\cdot\vec{b}=\left|\vec{a}\right|\left|\vec{b}\right|\cos(\theta)$.
所以为了求$\sin(\theta)$，我们可以先求出$\cos(\theta)$&lt;/p&gt;

&lt;p&gt;$$
\cos(\theta)=\frac{\vec{a}\cdot\vec{b}}{\left|\vec{a}\right|\left|\vec{b}\right|} \tag{2}
$$&lt;/p&gt;

&lt;p&gt;再利用公式&lt;/p&gt;

&lt;p&gt;$$
\cos^2(\theta)+\sin^2(\theta)=1 \tag{3}
$$&lt;/p&gt;

&lt;p&gt;便可以求出$\sin(\theta)$的值。&lt;/p&gt;

&lt;p&gt;&lt;br \&gt;
&lt;strong&gt;通过以上步骤，可以看出这样做很麻烦，有没有更简单的办法呢？当然有&lt;/strong&gt;
&lt;br \&gt;
求$\sin(\theta)$太麻烦了，但是求$\cos(\theta)$却很简单，为了避免求$\sin(\theta)$，我们能否找到一个角，使这个角的余弦等于$\sin(\theta)$ ?&lt;/p&gt;

&lt;p&gt;作向量$\vec{A}$、$\vec{B}$，夹角记为$\theta$，将向量$\vec{A}$逆时针旋转$90^\circ$得到$\vec{A^\prime}$，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E9%80%89%E5%8C%BA_347.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;通过上图给的条件，我们已知：&lt;/p&gt;

&lt;p&gt;$$
\begin{cases}
\beta=\frac{\pi}{2}-\theta \\&lt;br /&gt;
\cos(\beta)=\sin(\theta)
\end{cases}
$$&lt;/p&gt;

&lt;p&gt;这意味着$\vec{A}$的模长乘以$\vec{B}$的模长，再乘以$\sin(\theta)$，等于$\vec{A^\prime}$的模长乘以$\vec{B}$的模长，再乘以$\cos(\beta)$，得到：&lt;/p&gt;

&lt;p&gt;\begin{aligned}
&amp;amp; \left|\vec{A}\right|\left|\vec{B}\right|\sin(\theta) \\&lt;br /&gt;
= &amp;amp; \left|\vec{A^\prime}\right|\left|\vec{B}\right|\cos(\beta) \\&lt;br /&gt;
= &amp;amp; \vec{A^\prime}\cdot\vec{B}
\end{aligned}&lt;/p&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;p&gt;$$
\left|\vec{A}\right|\left|\vec{B}\right|\sin(\theta)=\vec{A^\prime}\cdot\vec{B} \tag{4}
$$&lt;/p&gt;

&lt;p&gt;这个方法看起来不错，不过还有一点是不知道的，就是怎么求$\vec{A^\prime}$呢?&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E9%80%89%E5%8C%BA_348.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;假设$\vec{A}$的坐标为$\left\langle a_1,a_2 \right\rangle$，由我画的图可知，逆时针旋转$90^\circ$后，得到：$A^\prime=\left\langle -a_2,a_1 \right\rangle$ 。&lt;/p&gt;

&lt;p&gt;同时再假设$\vec{B}$的坐标为$\left\langle b_1,b_2 \right\rangle$，现在将$\vec{A}$和$\vec{B}$的坐标分别带入(4)式，得到：&lt;/p&gt;

&lt;p&gt;\begin{aligned}
&amp;amp; \vec{A^\prime}\cdot\vec{B} \\&lt;br /&gt;
= &amp;amp; \left\langle -a_2,a_1 \right\rangle \cdot \left\langle b_1,b_2 \right\rangle \\&lt;br /&gt;
= &amp;amp; a_1b_2-a_2b_1
\end{aligned}&lt;/p&gt;

&lt;p&gt;如果你学过行列式，应该知道&lt;/p&gt;

&lt;p&gt;\begin{aligned}
&amp;amp; a_1b_2-a_2b_1 \\&lt;br /&gt;
= &amp;amp; \begin{vmatrix} a_1 &amp;amp; a_2 \\ b_1 &amp;amp; b_2 \end{vmatrix} \\&lt;br /&gt;
= &amp;amp; det(\vec{A},\vec{B})
\end{aligned}&lt;/p&gt;

&lt;p&gt;由此可知，三角形的面积&lt;/p&gt;

&lt;p&gt;$$
S=\frac{1}{2}det(\vec{A},\vec{B}) \tag{5}
$$&lt;/p&gt;

&lt;p&gt;现在可以得出结论：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;向量$\vec{A}$与向量$\vec{B}$的行列式表示一个以$\vec{A}$和$\vec{B}$为边构成的平行四边形的面积&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还可以表述得更严格一点，因为面积没有负数，而行列式的值有正有负，符号取决于两个向量之间的夹角，所以我们可以这样描述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;向量$\vec{A}$与向量$\vec{B}$的行列式的绝对值表示一个以$\vec{A}$和$\vec{B}$为边构成的平行四边形的面积&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;p-markdown-1-style-display-block-padding-10px-margin-10px-0-border-1px-solid-ccc-border-left-width-5px-border-radius-3px-border-left-color-df3e3e-1-三维空间-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#34;&gt;1. &lt;strong&gt;三维空间&lt;/strong&gt;&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;在空间中，从简单的开始，我们可以做两件事情：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;求平行六面体的体积&lt;/li&gt;
&lt;li&gt;求平行六面体的表面积&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;咱们先来求平行六面体的体积。&lt;/p&gt;

&lt;h3 id=&#34;平行六面体的体积&#34;&gt;平行六面体的体积&lt;/h3&gt;

&lt;p&gt;求体积之前，需要了解几个定义&lt;/p&gt;

&lt;h4 id=&#34;空间中的行列式&#34;&gt;空间中的行列式&lt;/h4&gt;

&lt;p&gt;空间中也有行列式的概念，假设有三个向量$\vec{A}$、$\vec{B}$和$\vec{C}$，定义：&lt;/p&gt;

&lt;p&gt;\begin{aligned}
det(\vec{A},\vec{B},\vec{C}) &amp;amp; = \begin{vmatrix} a_1 &amp;amp; a_2 &amp;amp; a_3 \\ b_1 &amp;amp; b_2 &amp;amp; b_3 \\ c_1 &amp;amp; c_2 &amp;amp; c_3 \end{vmatrix} \\&lt;br /&gt;
&amp;amp; = a_1\begin{vmatrix} b_2 &amp;amp; b_3 \\ c_2 &amp;amp; c_3 \end{vmatrix} - a_2\begin{vmatrix} b_1 &amp;amp; b_3 \\ c_1 &amp;amp; c_3 \end{vmatrix} + a_3\begin{vmatrix} b_1 &amp;amp; b_2 \\ c_1 &amp;amp; c_2 \end{vmatrix}
\end{aligned}&lt;/p&gt;

&lt;p&gt;如果你学过行列式的知识，上面的计算过程应该很容易理解，我就不作过多解释了。&lt;/p&gt;

&lt;h4 id=&#34;叉乘&#34;&gt;叉乘&lt;/h4&gt;

&lt;p&gt;叉乘适用于两个在空间内的向量（这里我指的是三维空间），定义：&lt;/p&gt;

&lt;p&gt;\begin{aligned}
\vec{A}\times\vec{B}=\begin{vmatrix} \hat{i} &amp;amp; \hat{j} &amp;amp; \hat{k} \\ a_1 &amp;amp; a_2 &amp;amp; a_3 \\ b_1 &amp;amp; b_2 &amp;amp; b_3 \end{vmatrix}
\end{aligned}&lt;/p&gt;

&lt;p&gt;其中，$\hat{i}$,$\hat{j}$,$\hat{k}$分别为三维空间中的三个坐标轴上的单位向量。&lt;/p&gt;

&lt;p&gt;我们把$\vec{A}\times\vec{B}$称为向量$\vec{A}$与$\vec{B}$的&lt;font size=4&gt;$\color{blue}{叉乘！}$&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;如果你仔细观察，你会发现，这个行列式的第二行和第三行分别是向量$\vec{A}$和$\vec{B}$的坐标，但是第一行却是三个单位向量，这意味着后面两行的元素都是数值，而第一行的元素都是向量。这意味着什么？这不是常理上的行列式，如果你尝试在计算器中这样计算，它会显示这是错误的，向量不该出现在这里。
&lt;br \&gt;
那么，为什么要这么做呢？&lt;/p&gt;

&lt;p&gt;如果使用上面提到的空间中的行列式的定义，可以得到：&lt;/p&gt;

&lt;p&gt;$$
\begin{vmatrix} \hat{i} &amp;amp; \hat{j} &amp;amp; \hat{k} \\ a_1 &amp;amp; a_2 &amp;amp; a_3 \\ b_1 &amp;amp; b_2 &amp;amp; b_3 \end{vmatrix}=\begin{vmatrix} a_2 &amp;amp; a_3 \\ b_2 &amp;amp; b_3 \end{vmatrix}\hat{i}-\begin{vmatrix} a_1 &amp;amp; a_3 \\ b_1 &amp;amp; b_3 \end{vmatrix}\hat{j}+\begin{vmatrix} a_1 &amp;amp; a_2 \\ b_1 &amp;amp; b_2 \end{vmatrix}\hat{k} \tag{6}
$$&lt;/p&gt;

&lt;p&gt;你发现了什么？没错，我们得到的结果不是一个数，而是一个&lt;font size=4&gt;$\color{blue}{向量}$&lt;/font&gt;，这就是向量叉乘的定义。
&lt;br \&gt;
那么问题在于，这样定义有什么好处呢？这种怪异计算的几何意义在哪里？为什么我们要费心去这样做？&lt;/p&gt;

&lt;p&gt;下面我们对上面的式子进行转化，看看会出现什么神奇的结果。&lt;/p&gt;

&lt;p&gt;将式(6)进一步化简，得到：&lt;/p&gt;

&lt;p&gt;\begin{aligned}
\vec{A}\times\vec{B}=(a_2b_3-a_3b_2)\hat{i}-(a_1b_3-a_3b_1)\hat{j}+(a_1b_2-a_2b_1)\hat{k}
\end{aligned}&lt;/p&gt;

&lt;p&gt;看起来没什么特别的，试着求一下$\vec{A}\times\vec{B}$的模，为了方便计算，我们求$\vec{A}\times\vec{B}$的模的平方&lt;/p&gt;

&lt;p&gt;\begin{aligned}
\left| \vec{A}\times\vec{B} \right|^2 &amp;amp; = (a_2b_3-a_3b_2)^2+(a_1b_3-a_3b_1)^2+(a_1b_2-a_2b_1)^2 \\&lt;br /&gt;
&amp;amp; = (a_1^2b_2^2+a_1^2b_3^2)+(a_2^2b_1^2+a_2^2b_3^2)+(a_3^2b_1^2+a_3^2b_2^2) \\&lt;br /&gt;
&amp;amp; - 2(a_1a_2b_1b_2+a_1a_3b_1b_3+a_2a_3b_2b_3) \\&lt;br /&gt;
&amp;amp; = (\underbrace{a_1^2b_2^2+a_1^2b_3^2}+a_1^2b_1^2)+(\underbrace{a_2^2b_1^2+a_2^2b_3^2}+a_2^2b_2^2)+(\underbrace{a_3^2b_1^2+a_3^2b_2^2}+a_3^2b_3^2)-(a_1^2b_1^2+a_2^2b_2^2+a_3^2b_3^2) \\&lt;br /&gt;
&amp;amp; - 2(a_1a_2b_1b_2+a_1a_3b_1b_3+a_2a_3b_2b_3) \\&lt;br /&gt;
&amp;amp; = {(\underbrace{a_1^2b_1^2+a_1^2b_2^2+a_1^2b_3^2)+(a_2^2b_1^2+a_2^2b_2^2+a_2^2b_3^2)+(a_3^2b_1^2+a_3^2b_2^2+a_3^2b_3^2)}} \\&lt;br /&gt;
&amp;amp; - {\underbrace{(a_1^2b_1^2+a_2^2b_2^2+a_3^2b_3^2)+2(a_1a_2b_1b_2+a_1a_3b_1b_3+a_2a_3b_2b_3)}} \\&lt;br /&gt;
&amp;amp; = (a_1^2+a_2^2+a_3^2)(b_1^2+b_2^2+b_3^2)-(a_1b_1+a_2b_2+a_3b_3)^2 \\&lt;br /&gt;
&amp;amp; = \left|\vec{A}\right|^2\cdot\left|\vec{B}\right|^2-\left|\vec{A}\cdot\vec{B}\right|^2 \\&lt;br /&gt;
&amp;amp; = \left|\vec{A}\right|^2\cdot\left|\vec{B}\right|^2\cdot1-\left|\vec{A}\right|^2\cdot\left|\vec{B}\right|^2\cdot\frac{\left|\vec{A}\cdot\vec{B}\right|^2}{\left|\vec{A}\right|^2\cdot\left|\vec{B}\right|^2} \\&lt;br /&gt;
&amp;amp; = \left|\vec{A}\right|^2\cdot\left|\vec{B}\right|^2(1-\frac{\left|\vec{A}\cdot\vec{B}\right|^2}{\left|\vec{A}\right|^2\cdot\left|\vec{B}\right|^2}) \\&lt;br /&gt;
&amp;amp; = \left|\vec{A}\right|^2\cdot\left|\vec{B}\right|^2(1-cos^2\left\langle\vec{A},\vec{B}\right\rangle) \\&lt;br /&gt;
&amp;amp; = (\left|\vec{A}\right|\cdot\left|\vec{B}\right|\cdot\sin\left\langle\vec{A},\vec{B}\right\rangle)
\end{aligned}&lt;/p&gt;

&lt;p&gt;发现了什么？&lt;strong&gt;原来$\vec{A}\times\vec{B}$的模长等于一个以$\vec{A}$和$\vec{B}$为边构成的平行四边形的面积&lt;/strong&gt;。
&lt;br \&gt;
接下来的问题是：既然$\vec{A}\times\vec{B}$的结果是一个向量，那么这个向量的方向是什么呢？&lt;/p&gt;

&lt;p&gt;答案是：它的方向垂直于向量$\vec{A}$与$\vec{B}$构成的平面，并且遵循右手定则。&lt;/p&gt;

&lt;p&gt;如果你不知道右手定则，我可以解释一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;首先，你的右手平行于向量$\vec{A}$的方向，然后，你的手指向向量$\vec{B}$的方向弯曲，这时，你的大拇指竖直的方向就是$\vec{A}\times\vec{B}$的方向。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们来证明一下为什么$\vec{A}\times\vec{B}$的方向垂直于向量$\vec{A}$与$\vec{B}$构成的平面。
为了简化，令&lt;/p&gt;

&lt;p&gt;$$
\begin{cases}
m_1=a_2b_3-a_3b_2 \\&lt;br /&gt;
m_2=a_1b_3-a_3b_1 \\&lt;br /&gt;
m_3=a_1b_2-a_2b_1
\end{cases}
$$
于是可以得到
$$
\vec{A}\times\vec{B}=m_1\hat{i}-m_2\hat{j}+m_3\hat{k} \tag{7}
$$
基本思路是这样：&lt;strong&gt;我们从$\vec{A}$与$\vec{B}$构成的平面中找两个方向不在同一条直线上的向量，如果$\vec{A}\times\vec{B}$与这两个向量均垂直,那么它就垂直于$\vec{A}$与$\vec{B}$构成的平面&lt;/strong&gt;
&lt;br \&gt;
为了方便计算，我们这样定义三个互相垂直的单位向量：其中，向量$\hat{i}$与$\hat{j}$在$\vec{A}$与$\vec{B}$构成的平面上，而向量$\hat{k}$垂直于这个平面。&lt;/p&gt;

&lt;p&gt;现在问题简单了，只要我们能证明$\hat{i}\times\hat{j}$的方向平行于$\hat{k}$，就说明$\vec{A}\times\vec{B}$的方向垂直于向量$\vec{A}$与$\vec{B}$构成的平面。&lt;/p&gt;

&lt;p&gt;设$\hat{i}=\left\langle1,0,0\right\rangle$,$\hat{j}=\left\langle0,1,0\right\rangle$,$\hat{k}=\left\langle0,0,1\right\rangle$，那么&lt;/p&gt;

&lt;p&gt;\begin{aligned}
\hat{i}\times\hat{j} &amp;amp; = \begin{vmatrix} \hat{i} &amp;amp; \hat{j} &amp;amp; \hat{k} \\ 1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 \end{vmatrix} \\&lt;br /&gt;
&amp;amp; = \begin{vmatrix} 0 &amp;amp; 0 \\ 1 &amp;amp; 0 \end{vmatrix}\hat{i}-\begin{vmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 0 \end{vmatrix}\hat{j}+\begin{vmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{vmatrix}\hat{k} \\&lt;br /&gt;
&amp;amp; = \hat{k}
\end{aligned}&lt;/p&gt;

&lt;p&gt;太神奇了，$\hat{i}\times\hat{j}$竟然等于$\hat{k}$，所以当然也平行于$\hat{k}$，所以$\vec{A}\times\vec{B}$的方向垂直于向量$\vec{A}$与$\vec{B}$构成的平面，并且遵循右手定则。
&lt;br \&gt;
于是可以得到如下的结论：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$\left|\vec{A}\times\vec{B}\right|$等于一个以$\vec{A}$和$\vec{B}$为边构成的平行四边形的面积&lt;/li&gt;
&lt;li&gt;$\vec{A}\times\vec{B}$的方向垂直于向量$\vec{A}$与$\vec{B}$构成的平面，并且遵循右手定则
&lt;br \&gt;
下面我们回到最初提出的问题：&lt;strong&gt;求平行六面体的体积&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/%E9%80%89%E5%8C%BA_351.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
如上图所示，我们要求由三个向量$\vec{A}$,$\vec{B}$与$\vec{C}$构成的平行六面体的体积。&lt;/p&gt;

&lt;p&gt;设体积为V，向量$\vec{A}$与$\vec{B}$构成的平行四边形的面积为S，高为h，那么：&lt;/p&gt;

&lt;p&gt;$$
V=S \cdot h \tag{8}
$$&lt;/p&gt;

&lt;p&gt;通过上面的分析，可以得知$S=\left|\vec{A}\times\vec{B}\right|$，那么高度h该怎么求呢？
假设高度h的方向为$\vec{H}$，那么h等于向量$\vec{C}$在向量$\vec{H}$上的投影，所以&lt;/p&gt;

&lt;p&gt;\begin{aligned}
h &amp;amp; = \left|\vec{C}\cdot\right|\cos\left\langle\vec{C},\vec{H}\right\rangle \\&lt;br /&gt;
&amp;amp; = \left|\vec{C}\right|\cdot\frac{\vec{C}\cdot\vec{H}}{\left|\vec{C}\right|\left|\vec{H}\right|} \\&lt;br /&gt;
&amp;amp; = \vec{C}\cdot\frac{\vec{H}}{\left|\vec{H}\right|} \\&lt;br /&gt;
&amp;amp; = \vec{C}\cdot\vec{h}, &amp;amp; \text{设$\vec{h}$为向量$\vec{H}$方向上的单位向量}
\end{aligned}&lt;/p&gt;

&lt;p&gt;带入(8)式，得：&lt;/p&gt;

&lt;p&gt;\begin{aligned}
V &amp;amp; = \left|\vec{A}\times\vec{B}\right|\cdot(\vec{C}\cdot\vec{h}) \\&lt;br /&gt;
&amp;amp; = \left|\vec{A}\times\vec{B}\right|\cdot(\vec{C}\cdot\frac{\vec{A}\times\vec{B}}{\left|\vec{A}\times\vec{B}\right|}) \\&lt;br /&gt;
&amp;amp; = \vec{C}\cdot(\vec{A}\times\vec{B}) \\&lt;br /&gt;
&amp;amp; = \left\langle c_1,c_2,c_3 \right\rangle\cdot{(a_2b_3-a_3b_2)\hat{i}-(a_1b_3-a_3b_1)\hat{j}+(a_1b_2-a_2b_1)\hat{k}} \\&lt;br /&gt;
&amp;amp; = c_1\begin{vmatrix} a_2 &amp;amp; a_3 \\ b_2 &amp;amp; b_3 \end{vmatrix}\hat{i}-c_2\begin{vmatrix} a_1 &amp;amp; a_3 \\ b_1 &amp;amp; b_3 \end{vmatrix}\hat{j}+c_3\begin{vmatrix} a_1 &amp;amp; a_2 \\ b_1 &amp;amp; b_2 \end{vmatrix}\hat{k} \\&lt;br /&gt;
&amp;amp; = det(\vec{A},\vec{B},\vec{C})
\end{aligned}&lt;/p&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;p&gt;$$
V=det(\vec{A},\vec{B},\vec{C})=\vec{C}\cdot(\vec{A}\times\vec{B}) \tag{9}
$$&lt;/p&gt;

&lt;p&gt;$\vec{C}\cdot(\vec{A}\times\vec{B})$称为向量的&lt;font size=4&gt;$\color{blue}{混合积}$&lt;/font&gt;。
&lt;br \&gt;
现在可以得出结论：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;向量$\vec{A}$、$\vec{B}$与$\vec{C}$的行列式等于由向量$\vec{A}$、$\vec{B}$与$\vec{C}$构成的平行六面体的体积&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br \&gt;
体积的部分暂时就讲到这里，接下来的一篇将会介绍平行六面体的面积。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>子空间投影</title>
      <link>https://www.yangcs.net:443/posts/%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/</link>
      <pubDate>Sat, 04 Jun 2016 17:18:59 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/%E5%AD%90%E7%A9%BA%E9%97%B4%E6%8A%95%E5%BD%B1/</guid>
      <description>&lt;p&gt;&amp;emsp;&amp;emsp;&lt;font size=4&gt;&lt;strong&gt;为了弄明白子空间投影是怎么一回事，我们遵循从低维到高维的规律，先从二维开始讲起。&lt;/strong&gt;&lt;/font&gt;

&lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=0 height=0 src=&#34;http://music.163.com/outchain/player?type=2&amp;id=2119491&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-二维空间&#34;&gt;1. 二维空间&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;如下图所示（我随手画的，不要介意），设向量p是向量b在向量a上面的投影，向量e垂直于向量p及a。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/1.png&#34; alt=&#34;img&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;于是我们可以得到这样的一个等式：&lt;/p&gt;

&lt;p&gt;$$a^Te = 0$$&lt;/p&gt;

&lt;p&gt;即&lt;/p&gt;

&lt;p&gt;$$a^T(b-xa) = 0\tag{1}$$&lt;/p&gt;

&lt;p&gt;解得：&lt;/p&gt;

&lt;p&gt;$$x = \frac{a^Tb}{a^Ta}$$&lt;/p&gt;

&lt;p&gt;于是向量p可表示为：&lt;/p&gt;

&lt;p&gt;$$p = xa = a\frac{a^Tb}{a^Ta}\tag{2}$$&lt;/p&gt;

&lt;p&gt;现在我们设&lt;/p&gt;

&lt;p&gt;$$p = Pb\tag{3}$$&lt;/p&gt;

&lt;p&gt;我们把这个矩阵P称为$\color{red}{投影矩阵}$。&lt;/p&gt;

&lt;p&gt;比较式(2)和式(3)，立即可以知道：&lt;/p&gt;

&lt;p&gt;$$\color{red}{P = \frac{a \cdot a^T}{a^T \cdot a}}\tag{4}$$&lt;/p&gt;

&lt;h2 id=&#34;2-三维空间&#34;&gt;2. 三维空间&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;为了让你们能够有一个直观的认识，我仍然用我高超的画艺画了一幅美图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/3.png&#34; alt=&#34;img&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;假设图中的那个平面由向量$a_1$和$a_2$构成，令&lt;/p&gt;

&lt;p&gt;$$A = \begin{bmatrix} a_1 &amp;amp; a_2 \end{bmatrix}$$&lt;/p&gt;

&lt;p&gt;由于向量p在平面上，所以p可以表示为：&lt;/p&gt;

&lt;p&gt;$$p = \hat{x_1}a_1 + \hat{x_2}a_2\tag{5}$$&lt;/p&gt;

&lt;p&gt;即&lt;/p&gt;

&lt;p&gt;$$p = A\hat{x}\tag{6}$$&lt;/p&gt;

&lt;p&gt;与二维空间类似，设向量p是向量b在平面上的投影，向量e垂直于那个平面，当然也垂直于向量p，同样也垂直于向量$a_1$和$a_2$,于是可以得到方程组：&lt;/p&gt;

&lt;p&gt;$$
\begin{cases}
a_1^T(b - A\hat{x}) = 0 \\&lt;br /&gt;
a_2^T(b - A\hat{x}) = 0 \\&lt;br /&gt;
\end{cases}\tag{7}
$$&lt;/p&gt;

&lt;p&gt;即&lt;/p&gt;

&lt;p&gt;$$\begin{bmatrix} a_1^T \\a_2^T \end{bmatrix}(b - A\hat{x}) = \begin{bmatrix} 0 \\0 \end{bmatrix}$$&lt;/p&gt;

&lt;p&gt;进一步化简得到：&lt;/p&gt;

&lt;p&gt;$$A^T(b - A\hat{x}) = 0\tag{8}$$&lt;/p&gt;

&lt;p&gt;解得：&lt;/p&gt;

&lt;p&gt;$$\hat{x} = (A^TA)^{-1}(A^Tb)\tag{9}$$&lt;/p&gt;

&lt;p&gt;将(9)代入(6)得：&lt;/p&gt;

&lt;p&gt;$$p = A\hat{x} = A(A^TA)^{-1}A^Tb\tag{10}$$&lt;/p&gt;

&lt;p&gt;与二维空间类似，我们设&lt;/p&gt;

&lt;p&gt;$$p = Pb\tag{11}$$&lt;/p&gt;

&lt;p&gt;比较式(10)和式(11)，立即可以得到：&lt;/p&gt;

&lt;p&gt;$$\color{red}{P = A(A^TA)^{-1}A^T}\tag{12}$$&lt;/p&gt;

&lt;p&gt;&lt;font size=4&gt;$\color{blue}{这就是投影矩阵的表达式！}$&lt;/font&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>十分钟告诉你什么是最小二乘法</title>
      <link>https://www.yangcs.net:443/posts/%E5%8D%81%E5%88%86%E9%92%9F%E5%91%8A%E8%AF%89%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/</link>
      <pubDate>Sat, 04 Jun 2016 13:28:25 +0000</pubDate>
      
      <guid>https://www.yangcs.net:443/posts/%E5%8D%81%E5%88%86%E9%92%9F%E5%91%8A%E8%AF%89%E4%BD%A0%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;曾经看过国内各种关于讲解最小二乘法的教科书，但都是一大堆枯燥的推导公式，看起来很高深的样子，其实根本不知道它在说些什么！传授知识本来就应该告诉你这个东西到底是什么，它到底是干嘛的，就应该把复杂的问题简单化，可国内大多数教科书都是反其道而行，全是看起来很牛逼的样子，学生看了却什么也不懂。今天我就用最通俗易懂的方式，从线性代数和线性空间的角度告诉你什么是最小二乘法。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;最小二乘法是一种最优化技术，它的做法是找到一组估计值，使得估计值与实际值的平方和的值最小，通过使误差的平方和最小，我们可以得到一下线性方程组，对这个线性方程组进行求解就可以得到拟合曲线。我们可以通过一个例子来进行讲解。&lt;/p&gt;

&lt;p&gt;假设有一组数据点$t_1$，$t_2$和$t_3$，它们的坐标分别是(1，1)，(2，2)，(3，2)，而我想找到最优的那条线，假设这条直线为：&lt;/p&gt;

&lt;p&gt;$$y = C + Dt\tag{1}$$&lt;/p&gt;

&lt;p&gt;它不会通过所有的点，因为不存在这样的直线，所以我要选一条最优的使总误差最小的直线。我们需要知道总误差怎么度量，因为它决定了哪条线胜出，我们必须先定出误差是什么，才能通过最小化这个量而找到C和D。在此我就不作图了，因为图像很简单，你们可以自己想象一下，或者自己拿笔画画。
将这三个点带入方程，得到：
$$\begin{cases}
C + D = 1 \\&lt;br /&gt;
C + 2D =2 \\&lt;br /&gt;
C + 3D =2
\end{cases}\tag{2}$$&lt;/p&gt;

&lt;p&gt;通过计算我们知道，它们联立是无解的，但可以有最优解。
这个方程组可写成矩阵的形式
$$AX = B\tag{3}$$&lt;/p&gt;

&lt;p&gt;其中，$A = \begin{bmatrix} 1 &amp;amp; 1 \\1 &amp;amp; 2 \\1 &amp;amp; 3 \end{bmatrix}$，$X = \begin{bmatrix} C &amp;amp; D \end{bmatrix}$，$B = \begin{bmatrix} 1 \\2 \\3 \end{bmatrix}$。&lt;/p&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;A的列向量线性无关，所以它们构成了列空间的一组基，但列空间不包括向量B，所以方程无解。那么最优解是什么呢？
我们将AX与B之间的差值相加，得到：&lt;/p&gt;

&lt;p&gt;$$AX - B = E\tag{4}$$&lt;/p&gt;

&lt;p&gt;其中，$E = \begin{bmatrix} e_1 \\e_2 \\e_3 \end{bmatrix}$，$e_1 = C + D - 1$，$e_2 = C + 2D - 2$，$e_3 = C + 3D - 2$，E称为误差向量。&lt;/p&gt;

&lt;p&gt;我们要求的是$\left|AX - B\right|^2$ = $\left|E\right|^2$的最小值。&lt;/p&gt;

&lt;p&gt;$$\left|E\right|^2 = \left|e_1\right|^2 + \left|e_2\right|^2 + \left|e_3\right|^2\tag{5}$$
&amp;emsp;&amp;emsp;分别过点$t_1$,$t_2$和$t_3$作与x轴垂直的直线，与直线y=C+Dt的交点分别为$s_1$,$s_2$,$s_3$。于是
$$\begin{cases}
\left|e_1\right| = \left|t_1-s_1\right| \\&lt;br /&gt;
\left|e_2\right| = \left|t_2-s_2\right| \\&lt;br /&gt;
\left|e_3\right| = \left|t_3-s_3\right|
\end{cases}\tag{6}$$&lt;/p&gt;

&lt;p&gt;假设$s_1$,$s_2$,$s_3$的纵坐标分别为$p_1$,$p_2$,$p_3$，令$p = \begin{bmatrix}p_1 \\p_2\\p_3\end{bmatrix}$。&lt;/p&gt;

&lt;p&gt;我们知道方程组$AX = B$是无解的，但方程组$AX = p$有解，我们来求解方程组$AX = p$。为了提醒自己这里表示的是最优的估计，而不是完美的结果，我们在X上面加个小帽子，使方程组变为&lt;/p&gt;

&lt;p&gt;$$A\hat{X} = p\tag{7}$$&lt;/p&gt;

&lt;p&gt;其中p是B在p向量这个方向上的投影，设投影矩阵为P，则&lt;/p&gt;

&lt;p&gt;$$p = PB\tag{8}$$&lt;/p&gt;

&lt;p&gt;如果不懂什么是投影矩阵，可以参考我的另一篇文章&lt;a href=&#34;http://www.yangcs.net/posts/be9ff8b7/&#34;&gt;子空间投影&lt;/a&gt;，在此不作赘述。
通过投影矩阵的知识我们知道投影矩阵P的表达式为&lt;/p&gt;

&lt;p&gt;$$P = A(A^TA)^{-1}A^T\tag{9}$$&lt;/p&gt;

&lt;p&gt;代入(8)，得：&lt;/p&gt;

&lt;p&gt;$$p = A(A^TA)^{-1}A^TB\tag{10}$$&lt;/p&gt;

&lt;p&gt;将(10)代入(7)，得：&lt;/p&gt;

&lt;p&gt;$$A\hat{X} = A(A^TA)^{-1}A^TB$$&lt;/p&gt;

&lt;p&gt;最后得到方程组为：&lt;/p&gt;

&lt;p&gt;$$A^TAX = A^TB\tag{11}$$&lt;/p&gt;

&lt;p&gt;解得&lt;/p&gt;

&lt;p&gt;$$\hat{X} = \begin{bmatrix} \frac{2}{3} \\ \frac{1}{2} \end{bmatrix}$$&lt;/p&gt;

&lt;p&gt;这就是最优解，所以最优的那条直线为：&lt;/p&gt;

&lt;p&gt;$$y = \frac{2}{3} + \frac{1}{2}t\tag{12}$$&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
