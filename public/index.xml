<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ryan Yang</title>
    <link>https://www.yangcs.net/</link>
    <description>Recent content on Ryan Yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 23 Jan 2018 08:26:58 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux全局智能分流方案</title>
      <link>https://www.yangcs.net/posts/linux-circumvent/</link>
      <pubDate>Tue, 23 Jan 2018 08:26:58 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/linux-circumvent/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本来我是决定不再写这样的文章了的。但是呢，最近连续配置了两次 &lt;code&gt;ArchLinux&lt;/code&gt;，在配置这种东西的时候连续撞到了同样的坑，加上这段时间经常有人问我关于 &lt;code&gt;Linux&lt;/code&gt; 下的 &lt;code&gt;shadowsocks&lt;/code&gt; 的问题，所以我想了想还是写一篇记录一下吧，也免得自己以后再忘记了。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这里有两种方案，都可以实现全局智能分流。第一种方案的思路是使用 &lt;code&gt;ipset&lt;/code&gt; 载入 &lt;code&gt;chnroute&lt;/code&gt; 的 &lt;code&gt;IP&lt;/code&gt; 列表并使用 &lt;code&gt;iptables&lt;/code&gt; 实现带自动分流国内外流量的全局代理。为什么不用 &lt;code&gt;PAC&lt;/code&gt; 呢？因为 &lt;code&gt;PAC&lt;/code&gt; 这种东西只对浏览器有用。难道你在浏览器之外就不需要科学上网了吗？反正我是不信的……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=Blue&gt;本教程所用系统为 &lt;code&gt;Archlinux&lt;/code&gt;，其他发型版类似，请自行参考相关资料。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-margin-bottom-2em-margin-right-5px-padding-8px-15px-letter-spacing-2px-background-image-linear-gradient-to-right-bottom-rgb-0-188-212-rgb-63-81-181-background-color-rgb-63-81-181-color-rgb-255-255-255-border-left-10px-solid-rgb-51-51-51-border-radius-5px-text-shadow-rgb-102-102-102-1px-1px-1px-box-shadow-rgb-102-102-102-1px-1px-2px-1-通过-iptables-实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;margin-bottom:2em; margin-right: 5px; padding: 8px 15px; letter-spacing: 2px; background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181)); background-color: rgb(63, 81, 181); color: rgb(255, 255, 255); border-left: 10px solid rgb(51, 51, 51); border-radius:5px; text-shadow: rgb(102, 102, 102) 1px 1px 1px; box-shadow: rgb(102, 102, 102) 1px 1px 2px;&#34;&gt;1. 通过 iptables 实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-1-安装相关软件&#34;&gt;1.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;shadowsocks-libev&lt;/li&gt;
&lt;li&gt;ipset&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S shadowsocks-libev ipset
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-配置shadowsocks-libev-略过&#34;&gt;1.2 配置shadowsocks-libev（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;1-3-获取中国ip段&#34;&gt;1.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-4-创建启动和关闭脚本&#34;&gt;1.4 创建启动和关闭脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /home/yang/bin/shadowsocks/ss-up.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

SOCKS_SERVER=$SERVER_IP # SOCKS 服务器的 IP 地址
# Setup the ipset
ipset -N chnroute hash:net maxelem 65536

for ip in $(cat &#39;/home/yang/bin/路由表/cn_rules.conf&#39;); do
  ipset add chnroute $ip
done

# 在nat表中新增一个链，名叫：SHADOWSOCKS
iptables -t nat -N SHADOWSOCKS

# Allow connection to the server
iptables -t nat -A SHADOWSOCKS -d $SOCKS_SERVER -j RETURN

# Allow connection to reserved networks
iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN

# Allow connection to chinese IPs
iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A SHADOWSOCKS -p icmp -m set --match-set chnroute dst -j RETURN

# Redirect to Shadowsocks
# 把1081改成你的shadowsocks本地端口
iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-port 1081
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A SHADOWSOCKS -p icmp -j REDIRECT --to-port 1081

# 将SHADOWSOCKS链中所有的规则追加到OUTPUT链中
iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A OUTPUT -p icmp -j SHADOWSOCKS

# 内网流量流经 shadowsocks 规则链
iptables -t nat -A PREROUTING -s 192.168/16 -j SHADOWSOCKS
# 内网流量源NAT
iptables -t nat -A POSTROUTING -s 192.168/16 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这是在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前执行的脚本，用来设置 &lt;code&gt;iptables&lt;/code&gt; 规则，对全局应用代理并将 &lt;code&gt;chnroute&lt;/code&gt; 导入 &lt;code&gt;ipset&lt;/code&gt; 来实现自动分流。注意要把服务器 &lt;code&gt;IP&lt;/code&gt; 和本地端口相关的代码全部替换成你自己的。
&amp;emsp;&amp;emsp;这里就有一个坑了，就是在把 &lt;code&gt;chnroute.txt&lt;/code&gt; 加入 &lt;code&gt;ipset&lt;/code&gt; 的时候。因为 &lt;code&gt;chnroute.txt&lt;/code&gt; 是一个 &lt;code&gt;IP&lt;/code&gt; 段列表，而中国持有的 &lt;code&gt;IP&lt;/code&gt; 数量上还是比较大的，所以如果使用 &lt;code&gt;hash:ip&lt;/code&gt; 来导入的话会使内存溢出。我在第二次重新配置的时候就撞进了这个大坑……
&amp;emsp;&amp;emsp;但是你也不能尝试把整个列表导入 &lt;code&gt;iptables&lt;/code&gt;。虽然导入 &lt;code&gt;iptables&lt;/code&gt; 不会导致内存溢出，但是 &lt;code&gt;iptables&lt;/code&gt; 是线性查表，即使你全部导入进去，也会因为低下的性能而抓狂。
&lt;br \&gt;
然后再创建 &lt;code&gt;/home/yang/bin/shadowsocks/ss-down.sh&lt;/code&gt;, 这是用来清除上述规则的脚本，比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# iptables -t nat -D OUTPUT -p icmp -j SHADOWSOCKS
iptables -t nat -D OUTPUT -p tcp -j SHADOWSOCKS
iptables -t nat -F SHADOWSOCKS
iptables -t nat -X SHADOWSOCKS
ipset destroy chnroute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x ss-up.sh
$ chmod +x ss-down.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-5-配置ss-redir服务&#34;&gt;1.5 配置ss-redir服务&lt;/h3&gt;

&lt;p&gt;首先，默认的 &lt;code&gt;ss-local&lt;/code&gt; 并不能用来作为 &lt;code&gt;iptables&lt;/code&gt; 流量转发的目标，因为它是 &lt;code&gt;socks5&lt;/code&gt; 代理而非透明代理。我们至少要把 &lt;code&gt;systemd&lt;/code&gt; 执行的程序改成 &lt;code&gt;ss-redir&lt;/code&gt;。其次，上述两个脚本还不能自动执行，必须让 &lt;code&gt;systemd&lt;/code&gt; 分别在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前和关闭之后将脚本执行，这样才能自动配置好 &lt;code&gt;iptables&lt;/code&gt; 规则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/lib/systemd/system/shadowsocks-libev@.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]
Description=Shadowsocks-Libev Client Service
After=network.target

[Service]
User=root
CapabilityBoundingSet=~CAP_SYS_ADMIN
ExecStart=
ExecStartPre=/home/yang/bin/shadowsocks/ss-up.sh
ExecStart=/usr/bin/ss-redir -u -c /etc/%i.json
ExecStopPost=/home/yang/bin/shadowsocks/ss-down.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-6-配置智能-dns-服务&#34;&gt;1.6 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;完成了以上工作之后是不是就可以实现全局科学上网了呢？答案是否定的，我们还有最后一项工作需要完成，那就是解决 &lt;code&gt;DNS&lt;/code&gt; 污染问题。如果你不知道什么是 &lt;code&gt;DNS&lt;/code&gt; 污染，我可以简单地给你普及一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 污染是一种让一般用户由于得到虚假目标主机 &lt;code&gt;IP&lt;/code&gt; 而不能与其通信的方法，是一种 &lt;code&gt;DNS&lt;/code&gt; 缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的 &lt;code&gt;DNS&lt;/code&gt; 查询没有任何认证机制，而且 &lt;code&gt;DNS&lt;/code&gt; 查询通常基于的 &lt;code&gt;UDP&lt;/code&gt; 是无连接不可靠的协议，因此 &lt;code&gt;DNS&lt;/code&gt; 的查询非常容易被篡改，通过对 &lt;code&gt;UDP&lt;/code&gt; 端口 53 上的 &lt;code&gt;DNS&lt;/code&gt; 查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 污染症状：目前一些被禁止访问的网站很多就是通过 &lt;code&gt;DNS&lt;/code&gt; 污染来实现的，例如 &lt;code&gt;YouTube&lt;/code&gt;、&lt;code&gt;Facebook&lt;/code&gt; 等网站。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应对dns污染的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;DNS&lt;/code&gt; 污染，可以说，个人用户很难单单靠设置解决，通常可以使用 &lt;code&gt;VPN&lt;/code&gt; 或者域名远程解析的方法解决，但这大多需要购买付费的 &lt;code&gt;VPN&lt;/code&gt; 或 &lt;code&gt;SSH&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;Hosts&lt;/code&gt; 的方法，手动设置域名正确的 &lt;code&gt;IP&lt;/code&gt; 地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dns&lt;/code&gt; 加密解析：&lt;a href=&#34;https://dnscrypt.org/&#34; target=&#34;_blank&#34;&gt;DNSCrypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;忽略 &lt;code&gt;DNS&lt;/code&gt; 投毒污染小工具：&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy&#34; target=&#34;_blank&#34;&gt;Pcap_DNSProxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们选择用 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 来解决这个问题，以前用的是 &lt;code&gt;Pdnsd + Dnsmasq&lt;/code&gt; 组合， 后来发现 &lt;code&gt;TCP&lt;/code&gt; 请求效率太低加上家里网络与那些国外的 &lt;code&gt;DNS&lt;/code&gt; 丢包实在是严重， 所以打算用 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 代替 &lt;code&gt;Pdnsd&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 的详细介绍，可以参考:
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy&#34; target=&#34;_blank&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy&lt;/a&gt;
安装过程可以参考：
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe_Linux.zh-Hans.txt&#34; target=&#34;_blank&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe_Linux.zh-Hans.txt&lt;/a&gt;
更详细的使用说明可以参考：
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe.zh-Hans.txt&#34; target=&#34;_blank&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe.zh-Hans.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要重点强调一些需要注意的配置项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DNS&lt;/code&gt; - 境外域名解析参数区域（这是最关键的一项配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[DNS]
# 这里一定要填 IPv4 + TCP！！！表示只使用 TCP 协议向境外远程 DNS 服务器发出请求
Outgoing Protocol = IPv4 + TCP
# 建议当系统使用全局代理功能时启用，程序将除境内服务器外的所有请求直接交给系统而不作任何过滤等处理，系统会将请求自动发往远程服务器进行解析
Direct Request = IPv4
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Local DNS&lt;/code&gt; - 境内域名解析参数区域&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Local DNS]
# 发送请求到境内 DNS 服务器时所使用的协议
Local Protocol = IPv4 + UDP
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Addresses&lt;/code&gt; - 普通模式地址区域&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Addresses]
...
...
# IPv4 主要境外 DNS 服务器地址
IPv4 Main DNS Address = 8.8.4.4:53
# IPv4 备用境外 DNS 服务器地址
IPv4 Alternate DNS Address = 8.8.8.8:53|208.67.220.220:443|208.67.222.222:5353
# IPv4 主要境内 DNS 服务器地址，用于境内域名解析，推荐使用 onedns
IPv4 Local Main DNS Address = 112.124.47.27:53
# IPv4 备用境内 DNS 服务器地址，用于境内域名解析
IPv4 Local Alternate DNS Address = 114.215.126.16:53
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-7-配置系统-dns-服务器设置&#34;&gt;1.7 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可参见 &lt;a href=&#34;https://developers.google.com/speed/public-dns/docs/using&#34; target=&#34;_blank&#34;&gt;https://developers.google.com/speed/public-dns/docs/using&lt;/a&gt; 中 &lt;code&gt;Changing your DNS servers settings&lt;/code&gt; 中 &lt;code&gt;Linux&lt;/code&gt; 一节&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;图形界面以 &lt;code&gt;GNOME 3&lt;/code&gt; 为例：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开所有程序列表，并 -&amp;gt; 设置 – 硬件分类 – 网络&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果要对当前的网络配置进行编辑 -&amp;gt; 单击齿轮按钮&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选中 &lt;code&gt;IPv4&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 栏目中，将自动拨向关闭&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在服务器中填入 &lt;code&gt;127.0.0.1&lt;/code&gt; （或103.214.195.99:7300）并应用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选中 &lt;code&gt;IPv6&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 栏目中，将自动拨向关闭&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在服务器中填入 ::1 并应用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请务必确保只填入这两个地址，填入其它地址可能会导致系统选择其它 DNS 服务器绕过程序的代理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启网络连接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改系统文件修改 DNS 服务器设置：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自动获取地址(DHCP)时：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以 &lt;code&gt;root&lt;/code&gt; 权限进入 &lt;code&gt;/etc/dhcp&lt;/code&gt; 或 &lt;code&gt;/etc/dhcp3&lt;/code&gt; 目录（视乎 dhclient.conf 文件位置）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改 &lt;code&gt;dhclient.conf&lt;/code&gt; 文件，修改或添加 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 一项即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 一项被 # 注释则需要把注释去掉以使配置生效，不需要添加新的条目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;dhclient.conf&lt;/code&gt; 文件可能存在多个 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 项，是各个网络接口的配置项目，直接修改总的配置项目即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;service network(/networking) restart&lt;/code&gt; 或 &lt;code&gt;ifdown/ifup&lt;/code&gt; 或 &lt;code&gt;ifconfig stop/start&lt;/code&gt; 重启网络服务/网络端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非自动获取地址(DHCP)时：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以 &lt;code&gt;root&lt;/code&gt; 权限进入 &lt;code&gt;/etc&lt;/code&gt; 目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改 &lt;code&gt;resolv.conf&lt;/code&gt; 文件里的 &lt;code&gt;nameserver&lt;/code&gt; 即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果重启后配置被覆盖，则需要修改或新建 &lt;code&gt;/etc/resolvconf/resolv.conf.d&lt;/code&gt; 文件，内容和 &lt;code&gt;resolv.conf&lt;/code&gt; 一样&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;service network(/networking) restart&lt;/code&gt; 或 &lt;code&gt;ifdown/ifup&lt;/code&gt; 或 &lt;code&gt;ifconfig stop/start&lt;/code&gt; 重启网络服务/网络端口&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-8-打开流量转发&#34;&gt;1.8 打开流量转发&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /etc/sysctl.d/30-ipforward.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;net.ipv4.ip_forward=1

net.ipv6.conf.all.forwarding = 1

net.ipv4.tcp_congestion_control=westwood

net.ipv4.tcp_syn_retries = 5

net.ipv4.tcp_synack_retries = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑完成后，执行以下命令使变动立即生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -p
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;p-markdown-1-style-margin-bottom-2em-margin-right-5px-padding-8px-15px-letter-spacing-2px-background-image-linear-gradient-to-right-bottom-rgb-0-188-212-rgb-63-81-181-background-color-rgb-63-81-181-color-rgb-255-255-255-border-left-10px-solid-rgb-51-51-51-border-radius-5px-text-shadow-rgb-102-102-102-1px-1px-1px-box-shadow-rgb-102-102-102-1px-1px-2px-2-通过-nftables-实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;margin-bottom:2em; margin-right: 5px; padding: 8px 15px; letter-spacing: 2px; background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181)); background-color: rgb(63, 81, 181); color: rgb(255, 255, 255); border-left: 10px solid rgb(51, 51, 51); border-radius:5px; text-shadow: rgb(102, 102, 102) 1px 1px 1px; box-shadow: rgb(102, 102, 102) 1px 1px 2px;&#34;&gt;2. 通过 nftables 实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-1-安装相关软件&#34;&gt;2.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;shadowsocks-libev&lt;/li&gt;
&lt;li&gt;nftables&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S shadowsocks-libev nftables
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-配置shadowsocks-libev-略过&#34;&gt;2.2 配置shadowsocks-libev（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;2-3-获取中国ip段&#34;&gt;2.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
cat cn_rules.conf|sed &#39;:label;N;s/\n/, /;b label&#39;|sed &#39;s/$/&amp;amp; }/g&#39;|sed &#39;s/^/{ &amp;amp;/g&#39; &amp;gt; /home/yang/bin/路由表/cn_rules1.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-创建启动和关闭脚本&#34;&gt;2.4 创建启动和关闭脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /home/yang/bin/shadowsocks/nftables-up.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#! /bin/bash

nft_pre=&amp;quot;/usr/sbin/nft add rule nat prerouting&amp;quot;
nft_out=&amp;quot;/usr/sbin/nft add rule nat output&amp;quot;
chnroute=$(cat &#39;/home/yang/bin/路由表/cn_rules1.conf&#39;)

/usr/bin/nft -f /etc/nftables.conf

${nft_pre} tcp dport 8385 return
${nft_pre} ip daddr 139.162.87.98 return
${nft_pre} ip daddr { 0.0.0.0/8, 10.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, 224.0.0.0/4, 240.0.0.0/4, 172.16.39.0/24} return
${nft_pre} ip daddr $chnroute return
${nft_pre} tcp sport { 32768-61000} redirect to 1081
#${nft_pre} ip protocol icmp redirect to 1081
# 内网流量源NAT
nft add rule nat postrouting ip saddr 192.168.0.0/12 masquerade

${nft_out} tcp dport 8385 return
${nft_out} ip daddr 139.162.87.98 return
${nft_out} ip daddr { 0.0.0.0/8, 10.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, 224.0.0.0/4, 240.0.0.0/4, 172.16.39.0/24} return
${nft_out} ip daddr $chnroute return
# /proc/sys/net/ipv4/ip_local_port_range，本地发起的连接的端口范围
${nft_out} tcp sport { 32768-61000} redirect to 1081
${nft_out} ip protocol icmp redirect to 1081
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这是在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前执行的脚本，用来设置 &lt;code&gt;nftables&lt;/code&gt; 规则。
然后再创建 &lt;code&gt;/home/yang/bin/shadowsocks/nftables-down.sh&lt;/code&gt;, 这是用来清除上述规则的脚本，比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

sudo nft flush table nat
#sudo nft flush table filter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x nftables-up.sh
$ chmod +x nftables-down.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-配置ss-redir服务&#34;&gt;2.5 配置ss-redir服务&lt;/h3&gt;

&lt;p&gt;首先，默认的 &lt;code&gt;ss-local&lt;/code&gt; 并不能用来作为 &lt;code&gt;nftables&lt;/code&gt; 流量转发的目标，因为它是 &lt;code&gt;socks5&lt;/code&gt; 代理而非透明代理。我们至少要把 &lt;code&gt;systemd&lt;/code&gt; 执行的程序改成 &lt;code&gt;ss-redir&lt;/code&gt;。其次，上述两个脚本还不能自动执行，必须让 &lt;code&gt;systemd&lt;/code&gt; 分别在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前和关闭之后将脚本执行，这样才能自动配置好 &lt;code&gt;nftables&lt;/code&gt; 规则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/lib/systemd/system/shadowsocks-libev@.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]
Description=Shadowsocks-Libev Client Service
After=network.target

[Service]
User=root
CapabilityBoundingSet=~CAP_SYS_ADMIN
ExecStart=
ExecStartPre=/home/yang/bin/shadowsocks/nftables-up.sh
ExecStart=/usr/bin/ss-redir -u -c /etc/%i.json
ExecStopPost=/home/yang/bin/shadowsocks/nftables-down.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start nftables
$ systemctl start shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable nftables
$ systemctl enable shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-6-配置智能-dns-服务&#34;&gt;2.6 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;2-7-配置系统-dns-服务器设置&#34;&gt;2.7 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;2-8-打开流量转发&#34;&gt;2.8 打开流量转发&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-margin-bottom-2em-margin-right-5px-padding-8px-15px-letter-spacing-2px-background-image-linear-gradient-to-right-bottom-rgb-0-188-212-rgb-63-81-181-background-color-rgb-63-81-181-color-rgb-255-255-255-border-left-10px-solid-rgb-51-51-51-border-radius-5px-text-shadow-rgb-102-102-102-1px-1px-1px-box-shadow-rgb-102-102-102-1px-1px-2px-3-通过策略路由实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;margin-bottom:2em; margin-right: 5px; padding: 8px 15px; letter-spacing: 2px; background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181)); background-color: rgb(63, 81, 181); color: rgb(255, 255, 255); border-left: 10px solid rgb(51, 51, 51); border-radius:5px; text-shadow: rgb(102, 102, 102) 1px 1px 1px; box-shadow: rgb(102, 102, 102) 1px 1px 2px;&#34;&gt;3. 通过策略路由实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;3-1-安装相关软件&#34;&gt;3.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;badvpn&lt;/li&gt;
&lt;li&gt;shadowsocks&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S badvpn shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-配置shadowsocks-略过&#34;&gt;3.2 配置shadowsocks（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;3-3-获取中国ip段&#34;&gt;3.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-4-配置智能-dns-服务&#34;&gt;3.4 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;3-5-配置系统-dns-服务器设置&#34;&gt;3.5 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;3-6-写路由表启动和终止脚本&#34;&gt;3.6 写路由表启动和终止脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/local/bin/socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
SOCKS_SERVER=$SERVER_IP # SOCKS 服务器的 IP 地址
SOCKS_PORT=1081 # 本地SOCKS 服务器的端口
GATEWAY_IP=$(ip route|grep &amp;quot;default&amp;quot;|awk &#39;{print $3}&#39;) # 家用网关（路由器）的 IP 地址，你也可以手动指定
TUN_NETWORK_DEV=tun0 # 选一个不冲突的 tun 设备号
TUN_NETWORK_PREFIX=10.0.0 # 选一个不冲突的内网 IP 段的前缀


start_fwd() {
ip tuntap del dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
# 添加虚拟网卡
ip tuntap add dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
# 给虚拟网卡绑定IP地址
ip addr add &amp;quot;$TUN_NETWORK_PREFIX.1/24&amp;quot; dev &amp;quot;$TUN_NETWORK_DEV&amp;quot;
# 启动虚拟网卡
ip link set &amp;quot;$TUN_NETWORK_DEV&amp;quot; up
ip route del default via &amp;quot;$GATEWAY_IP&amp;quot;
ip route add &amp;quot;$SOCKS_SERVER&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
# 特殊ip段走家用网关（路由器）的 IP 地址（如局域网联机）
# ip route add &amp;quot;172.16.39.0/24&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
# 国内网段走家用网关（路由器）的 IP 地址
for i in $(cat /home/yang/bin/路由表/cn_rules.conf)
do
ip route add &amp;quot;$i&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
done
# 将默认网关设为虚拟网卡的IP地址
ip route add 0.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
ip route add 128.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
# 将socks5转为vpn
badvpn-tun2socks --tundev &amp;quot;$TUN_NETWORK_DEV&amp;quot; --netif-ipaddr &amp;quot;$TUN_NETWORK_PREFIX.2&amp;quot; --netif-netmask 255.255.255.0 --socks-server-addr &amp;quot;127.0.0.1:$SOCKS_PORT&amp;quot;
TUN2SOCKS_PID=&amp;quot;$!&amp;quot;
}


stop_fwd() {
ip route del 128.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
ip route del 0.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
for i in $(cat /home/yang/bin/路由表/cn_rules.conf)
do
ip route del &amp;quot;$i&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
done
ip route del &amp;quot;172.16.39.0/24&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
ip route del &amp;quot;$SOCKS_SERVER&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
ip route add default via &amp;quot;$GATEWAY_IP&amp;quot;
ip link set &amp;quot;$TUN_NETWORK_DEV&amp;quot; down
ip addr del &amp;quot;$TUN_NETWORK_PREFIX.1/24&amp;quot; dev &amp;quot;$TUN_NETWORK_DEV&amp;quot;
ip tuntap del dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
}



start_fwd
trap stop_fwd INT TERM
wait &amp;quot;$TUN2SOCKS_PID&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /etc/systemd/system/socksfwd.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]

Description=Transparent SOCKS5 forwarding

After=network-online.target

[Service]

Type=simple

ExecStart=/usr/local/bin/socksfwd

LimitNOFILE=1048576


[Install]

WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-7-打开流量转发&#34;&gt;3.7 打开流量转发&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /etc/sysctl.d/30-ipforward.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;net.ipv4.ip_forward=1

net.ipv6.conf.all.forwarding = 1

net.ipv4.tcp_congestion_control=westwood

net.ipv4.tcp_syn_retries = 5

net.ipv4.tcp_synack_retries = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑完成后，执行以下命令使变动立即生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -p
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>控制 Egress 流量</title>
      <link>https://www.yangcs.net/posts/control-egress-traffic/</link>
      <pubDate>Thu, 16 Aug 2018 13:40:27 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/control-egress-traffic/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p id=&#34;div-border-left-red&#34;&gt;本文主要内容来自 &lt;a href=&#34;https://istio.io/zh/docs/tasks/traffic-management/egress/&#34; target=&#34;_blank&#34;&gt;Istio 官方文档&lt;/a&gt;，并对其进行了大量扩展和补充。&lt;/p&gt;

&lt;p&gt;缺省情况下，Istio 服务网格内的 Pod，由于其 iptables 将所有外发流量都透明的转发给了 &lt;code&gt;Sidecar&lt;/code&gt;，所以这些集群内的服务无法访问集群之外的 URL，而只能处理集群内部的目标。&lt;/p&gt;

&lt;p&gt;本文的任务描述了如何将外部服务暴露给 Istio 集群中的客户端。你将会学到如何通过定义 &lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#ServiceEntry&#34; target=&#34;_blank&#34;&gt;ServiceEntry&lt;/a&gt; 来调用外部服务；或者简单的对 Istio 进行配置，要求其直接放行对特定 IP 范围的访问。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-开始之前-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 开始之前&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;根据&lt;a href=&#34;https://www.yangcs.net/posts/istio-1.0-deploy/&#34; target=&#34;_blank&#34;&gt;安装指南&lt;/a&gt;的内容，部署 Istio。&lt;/li&gt;
&lt;li&gt;启动 &lt;a href=&#34;https://github.com/istio/istio/tree/release-1.0/samples/sleep&#34; target=&#34;_blank&#34;&gt;sleep&lt;/a&gt; 示例应用，我们将会使用这一应用来完成对外部服务的调用过程。 如果启用了 &lt;a href=&#34;https://istio.io/zh/docs/setup/kubernetes/sidecar-injection/#sidecar-%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5&#34; target=&#34;_blank&#34;&gt;Sidecar 的自动注入功能&lt;/a&gt;，运行：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl apply -f samples/sleep/sleep.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否则在部署 &lt;code&gt;sleep&lt;/code&gt; 应用之前，就需要手工注入 Sidecar：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/sleep/sleep.yaml)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上任何可以 &lt;code&gt;exec&lt;/code&gt; 和 &lt;code&gt;curl&lt;/code&gt; 的 Pod 都可以用来完成这一任务。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-istio-中配置外部服务-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. Istio 中配置外部服务&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;通过配置 Istio &lt;code&gt;ServiceEntry&lt;/code&gt;，可以从 Istio 集群中访问外部任意的可用服务。这里我们会使用 &lt;a href=&#34;http://httpbin.org/&#34; target=&#34;_blank&#34;&gt;httpbin.org&lt;/a&gt; 以及 &lt;a href=&#34;https://www.baidu.com/&#34; target=&#34;_blank&#34;&gt;www.baidu.com&lt;/a&gt; 进行试验。&lt;/p&gt;

&lt;h4 id=&#34;配置外部服务&#34;&gt;配置外部服务&lt;/h4&gt;

&lt;p id=&#34;blue&#34;&gt;1. 创建一个 &lt;code&gt;ServiceEntry&lt;/code&gt; 对象，放行对一个外部 HTTP 服务的访问：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: httpbin-ext
spec:
  hosts:
  - httpbin.org
  ports:
  - number: 80
    name: http
    protocol: HTTP
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p id=&#34;blue&#34;&gt;2. 另外创建一个 &lt;code&gt;ServiceEntry&lt;/code&gt; 对象和一个 &lt;code&gt;VirtualService&lt;/code&gt;，放行对一个外部 HTTPS 服务的访问：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: baidu
spec:
  hosts:
  - www.baidu.com
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  resolution: DNS
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: baidu
spec:
  hosts:
  - www.baidu.com
  tls:
  - match:
    - port: 443
      sniHosts:
      - www.baidu.com
    route:
    - destination:
        host: www.baidu.com
        port:
          number: 443
      weight: 100
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;发起对外部服务的访问&#34;&gt;发起对外部服务的访问&lt;/h4&gt;

&lt;p&gt;使用 &lt;code&gt;kubectl exec&lt;/code&gt; 命令进入测试 Pod。假设使用的是 sleep 服务，运行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o go-template=&#39;{{range .items}}{{.metadata.name}}{{end}}&#39;)
$ kubectl exec -it $SOURCE_POD -c sleep bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发起一个对外部 HTTP 服务的请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://httpbin.org/headers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发起一个对外部 HTTPS 服务的请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl https://www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;http-serviceentry-配置深度解析&#34;&gt;HTTP ServiceEntry 配置深度解析&lt;/h4&gt;

&lt;p&gt;按照之前的惯例，还是先来解读一下 HTTP 协议的 &lt;code&gt;ServiceEntry&lt;/code&gt; 映射到 Envoy 配置层面具体是哪些内容，这样才能对 ServiceEntry 有更加深刻的认识。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;创建一个 &lt;code&gt;HTTP&lt;/code&gt; 协议的 ServiceEntry（不指定 &lt;code&gt;GateWay&lt;/code&gt;） 本质上是在服务网格内的&lt;strong&gt;所有应用的所有 Pod&lt;/strong&gt;上创建相应的路由规则和与之对应的 Cluster。指定 GateWay 的 ServiceEntry 遵循的是另一套法则，后面我们再说。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;可以通过 istioctl 来验证一下（以 &lt;code&gt;httpbin-ext&lt;/code&gt; 为例）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看 sleep 的 Pod Name：
$ kubectl get pod -l app=sleep

NAME                     READY     STATUS    RESTARTS   AGE
sleep-5bc866558c-89shb   2/2       Running   0          49m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看路由&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl pc routes sleep-5bc866558c-89shb --name 80 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;80&amp;quot;,
        &amp;quot;virtualHosts&amp;quot;: [
            {
                &amp;quot;name&amp;quot;: &amp;quot;httpbin.org:80&amp;quot;,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;httpbin.org&amp;quot;,
                    &amp;quot;httpbin.org:80&amp;quot;
                ],
                &amp;quot;routes&amp;quot;: [
                    {
                        &amp;quot;match&amp;quot;: {
                            &amp;quot;prefix&amp;quot;: &amp;quot;/&amp;quot;
                        },
                        &amp;quot;route&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|80||httpbin.org&amp;quot;,
                            &amp;quot;timeout&amp;quot;: &amp;quot;0.000s&amp;quot;,
                            &amp;quot;maxGrpcTimeout&amp;quot;: &amp;quot;0.000s&amp;quot;
                        },
                        &amp;quot;decorator&amp;quot;: {
                            &amp;quot;operation&amp;quot;: &amp;quot;httpbin.org:80/*&amp;quot;
                        },
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到从 Pod sleep-5bc866558c-89shb 内部对域名 &lt;code&gt;httpbin.org&lt;/code&gt; 发起的请求通过 HTTP 路由被定向到集群 &lt;code&gt;outbound|80||httpbin.org&lt;/code&gt;。&lt;code&gt;outbound&lt;/code&gt; 表示这是出站流量&lt;/p&gt;

&lt;p&gt;查看 &lt;code&gt;Cluster&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl pc clusters sleep-5bc866558c-89shb --fqdn httpbin.org -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;outbound|80||httpbin.org&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;ORIGINAL_DST&amp;quot;,
        &amp;quot;connectTimeout&amp;quot;: &amp;quot;1.000s&amp;quot;,
        &amp;quot;lbPolicy&amp;quot;: &amp;quot;ORIGINAL_DST_LB&amp;quot;,
        &amp;quot;circuitBreakers&amp;quot;: {
            &amp;quot;thresholds&amp;quot;: [
                {}
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span id=&#34;inline-blue&#34;&gt;type&lt;/span&gt; : 服务发现类型。&lt;code&gt;ORIGINAL_DST&lt;/code&gt; 表示原始目的地类型，大概意思就是：连接进入之前已经被解析为一个特定的目标 IP 地址。这种连接通常是由代理使用 IP table REDIRECT 或者 eBPF 之类的机制转发而来的。完成路由相关的转换之后，代理服务器会将连接转发到该 IP 地址。&lt;code&gt;httpbin.org&lt;/code&gt; 是外网域名，当然可以解析，所以连接进入之前可以被解析为一个特定的目标 IP 地址。Envoy 服务发现类型的详细解析可以参考：&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/service_discovery#arch-overview-service-discovery-types-original-destination&#34; target=&#34;_blank&#34;&gt;Service discovery&lt;/a&gt;。&lt;code&gt;ServiceEntry.Resolution&lt;/code&gt; 字段的解析可以参考：&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#ServiceEntry-Resolution&#34; target=&#34;_blank&#34;&gt;ServiceEntry.Resolution&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里我简要说明一下，ServiceEntry 的 &lt;code&gt;resolution&lt;/code&gt; 字段可以取三个不同的值，分别对应 Envoy 中的三种服务发现策略：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NONE&lt;/code&gt; : 对应于 Envoy 中的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/service_discovery#original-destination&#34; target=&#34;_blank&#34;&gt;ORIGINAL_DST&lt;/a&gt;。如果不指定 resolution 字段，默认使用这个策略。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STATIC&lt;/code&gt; : 对应于 Envoy 中的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/service_discovery#static&#34; target=&#34;_blank&#34;&gt;STATIC&lt;/a&gt;。表示使用 &lt;code&gt;endpoints&lt;/code&gt; 中指定的静态 IP 地址作为服务后端。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; : 对应于 Envoy 中的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/service_discovery#strict-dns&#34; target=&#34;_blank&#34;&gt;STRICT_DNS&lt;/a&gt;。表示处理请求时尝试向 DNS 查询 IP 地址。如果没有指定 &lt;code&gt;endpoints&lt;/code&gt;，并且没有使用通配符，代理服务器会使用 DNS 解析 &lt;code&gt;hosts&lt;/code&gt; 字段中的地址。如果指定了 &lt;code&gt;endpoints&lt;/code&gt;，那么指定的地址就会作为目标 IP 地址。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;lbPolicy&lt;/span&gt; : 负载均衡策略。&lt;code&gt;ORIGINAL_DST_LB&lt;/code&gt; 表示使用原始目的地的负载均衡策略。具体参考: &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/load_balancing&#34; target=&#34;_blank&#34;&gt;Load balancing&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你还部署了 &lt;code&gt;bookinfo&lt;/code&gt; 示例应用，可以通过执行 &lt;code&gt;istioctl pc routes &amp;lt;productpage_pod_name&amp;gt; --name 80 -o json&lt;/code&gt; 和 &lt;code&gt;istioctl pc clusters &amp;lt;productpage_pod_name&amp;gt; --fqdn httpbin.org -o json&lt;/code&gt; 来验证一下，你会发现输出的结果和上面一模一样。如果还不放心，可以查看 bookinfo 应用内的所有 Pod，你会得到相同的答案。至此你应该可以理解&lt;strong&gt;在服务网格内的所有应用的所有 Pod上创建相应的路由规则和与之对应的 Cluster&lt;/strong&gt;这句话的含义了。&lt;/p&gt;

&lt;h4 id=&#34;https-serviceentry-配置深度解析&#34;&gt;HTTPS ServiceEntry 配置深度解析&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;HTTPS&lt;/code&gt; 协议的 ServiceEntry 与 Envoy 配置文件的映射关系与 HTTP 协议有所不同。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;创建一个 &lt;code&gt;HTTPS&lt;/code&gt; 协议的 ServiceEntry（不指定 &lt;code&gt;GateWay&lt;/code&gt;） 本质上是在服务网格内的&lt;strong&gt;所有应用的所有 Pod&lt;/strong&gt;上创建相应的&lt;strong&gt;监听器&lt;/strong&gt;和与之对应的 Cluster。指定 GateWay 的 ServiceEntry 我会另行发文详说。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;可以通过 istioctl 来验证（以 &lt;code&gt;baidu&lt;/code&gt; 为例）。为了更精确地分析该 ServiceEntry，可以先把 &lt;code&gt;VirtualService&lt;/code&gt; 删除：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl delete virtualservice baidu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看监听器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl pc listeners sleep-5bc866558c-89shb --address 0.0.0.0 --port 443 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;0.0.0.0_443&amp;quot;,
        &amp;quot;address&amp;quot;: {
            &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
                &amp;quot;portValue&amp;quot;: 443
            }
        },
        &amp;quot;filterChains&amp;quot;: [
            {
                &amp;quot;filters&amp;quot;: [
                    ...
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;envoy.tcp_proxy&amp;quot;,
                        &amp;quot;config&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|443||www.baidu.com&amp;quot;,
                            &amp;quot;stat_prefix&amp;quot;: &amp;quot;outbound|443||www.baidu.com&amp;quot;
                        }
                    }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span id=&#34;inline-blue&#34;&gt;name&lt;/span&gt; : 监听器过滤器的名称。该字段的值必须与 Envoy 所支持的过滤器匹配，不可随意填写，具体参考：&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener/listener.proto#listener-filter&#34; target=&#34;_blank&#34;&gt;listener.Filter&lt;/a&gt;。此处 &lt;code&gt;envoy.tcp_proxy&lt;/code&gt; 表示使用 TCP 代理，而 TCP 代理是无法基于路由过滤的，所以这里不会创建路由规则，而是直接将请求转到 &lt;code&gt;Cluster&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看 Cluster：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl pc clusters sleep-5bc866558c-89shb --fqdn www.baidu.com -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;outbound|443||www.baidu.com&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;STRICT_DNS&amp;quot;,
        &amp;quot;connectTimeout&amp;quot;: &amp;quot;1.000s&amp;quot;,
        &amp;quot;hosts&amp;quot;: [
            {
                &amp;quot;socketAddress&amp;quot;: {
                    &amp;quot;address&amp;quot;: &amp;quot;www.baidu.com&amp;quot;,
                    &amp;quot;portValue&amp;quot;: 443
                }
            }
        ],
        &amp;quot;circuitBreakers&amp;quot;: {
            &amp;quot;thresholds&amp;quot;: [
                {}
            ]
        },
        &amp;quot;dnsLookupFamily&amp;quot;: &amp;quot;V4_ONLY&amp;quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从监听器的配置来看，由于绑定的是 &lt;code&gt;0.0.0.0&lt;/code&gt;，而且也没有指定域名，看起来应该可以访问集群外任何 443 端口的服务。实际上这是行不通的，因为当请求通过监听器转到 Cluster 之后，由于 Cluster 采用的是严格的 DNS 服务发现策略，只要域名不是 &lt;code&gt;www.baidu.com&lt;/code&gt;，都不会解析。你可以使用 kubectl exec 命令进入 sleep Pod 来测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl exec -it $SOURCE_POD -c sleep bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发起对外部 HTTPS 服务的请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl https://www.163.com
curl: (51) SSL: no alternative certificate subject name matches target host name &#39;www.163.com&#39;

$ curl https://www.taobao.com
curl: (51) SSL: no alternative certificate subject name matches target host name &#39;www.taobao.com&#39;

$ curl https://192.192.192.192
curl: (51) SSL: certificate subject name &#39;baidu.com&#39; does not match target host name &#39;192.192.192.192&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果你将服务发现策略改为 &lt;code&gt;NONE&lt;/code&gt;，就会发现除了可以访问 &lt;code&gt;www.baidu.com&lt;/code&gt;，还可以访问 &lt;code&gt;www.163.com&lt;/code&gt; 和 &lt;code&gt;www.taobao.com&lt;/code&gt; 等其他 https 协议的网站，至于为什么会这样，前面介绍服务发现策略的时候我已经详细解释过了。&lt;/p&gt;

&lt;h4 id=&#34;tls-virtualservice-配置深度解析&#34;&gt;TLS VirtualService 配置深度解析&lt;/h4&gt;

&lt;p&gt;关于 VirtualService 的解析之前的文章已有相关说明，不过这里的 VirtualService 与之前遇到的不同，涉及到了 &lt;code&gt;TLSRoute&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;tls&lt;/span&gt; : 透传 TLS 和 HTTPS 流量。TLS 路由通常应用在 &lt;code&gt;https-&lt;/code&gt;、&lt;code&gt;tls-&lt;/code&gt; 前缀的平台服务端口，或者经 &lt;code&gt;Gateway&lt;/code&gt; 透传的 HTTPS、TLS 协议 端口，以及使用 HTTPS 或者 TLS 协议的 &lt;code&gt;ServiceEntry&lt;/code&gt; 端口上。具体参考：&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#TLSRoute&#34; target=&#34;_blank&#34;&gt;TLSRoute&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span id=&#34;inline-blue&#34;&gt;sniHosts&lt;/span&gt; : 必要字段。要匹配的 SNI（服务器名称指示）。可以在 SNI 匹配值中使用通配符。比如 &lt;code&gt;*.com&lt;/code&gt; 可以同时匹配 &lt;code&gt;foo.example.com&lt;/code&gt; 和 &lt;code&gt;example.com&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;route&lt;/span&gt; : 流量的转发目标。目前 TLS 服务只允许一个转发目标(所以权重必须设置为 100)。当 Envoy 支持 TCP 权重路由之后，这里就可以使用多个目标了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看映射到 Envoy 中的配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl pc listeners sleep-5bc866558c-89shb --address 0.0.0.0 --port 443 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;0.0.0.0_443&amp;quot;,
        &amp;quot;address&amp;quot;: {
            &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
                &amp;quot;portValue&amp;quot;: 443
            }
        },
        &amp;quot;filterChains&amp;quot;: [
            {
                &amp;quot;filterChainMatch&amp;quot;: {
                    &amp;quot;serverNames&amp;quot;: [
                        &amp;quot;www.baidu.com&amp;quot;
                    ]
                },
                &amp;quot;filters&amp;quot;: [
                    ...
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;envoy.tcp_proxy&amp;quot;,
                        &amp;quot;config&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|443||www.baidu.com&amp;quot;,
                            &amp;quot;stat_prefix&amp;quot;: &amp;quot;outbound|443||www.baidu.com&amp;quot;
                        }
                    }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span id=&#34;inline-blue&#34;&gt;filterChainMatch&lt;/span&gt; : 用于为&lt;strong&gt;监听器过滤器链&lt;/strong&gt;指定匹配条件，具体参考：&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/listener/listener.proto#listener-filterchainmatch&#34; target=&#34;_blank&#34;&gt;listener.FilterChainMatch&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;最后我们来思考一下：既然不创建 TLS VirtualService 也可以访问 &lt;code&gt;www.baidu.com&lt;/code&gt;，那么创建 TLS VirtualService 和不创建 TLS VirtualService 有什么区别呢？正确答案是：没有关联 &lt;code&gt;VirtualService&lt;/code&gt; 的 &lt;code&gt;https-&lt;/code&gt; 或者 &lt;code&gt;tls-&lt;/code&gt; 端口流量会被视为透传 &lt;code&gt;TCP&lt;/code&gt; 流量，而不是透传 TLS 和 HTTPS 流量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;为外部服务设置路由规则&#34;&gt;为外部服务设置路由规则&lt;/h4&gt;

&lt;p&gt;通过 &lt;code&gt;ServiceEntry&lt;/code&gt; 访问外部服务的流量，和网格内流量类似，都可以进行 Istio &lt;a href=&#34;https://istio.io/zh/docs/concepts/traffic-management/#%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE&#34; target=&#34;_blank&#34;&gt;路由规则&lt;/a&gt; 的配置。下面我们使用 istioctl 为 httpbin.org 服务设置一个超时规则。&lt;/p&gt;

&lt;p id=&#34;blue&#34;&gt;1. 在测试 Pod 内部，调用 httpbin.org 这一外部服务的 &lt;code&gt;/delay&lt;/code&gt; 端点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl exec -it $SOURCE_POD -c sleep bash
$ time curl -o /dev/null -s -w &amp;quot;%{http_code}\n&amp;quot; http://httpbin.org/delay/5

200

real    0m5.024s
user    0m0.003s
sys     0m0.003s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个请求会在大概五秒钟左右返回一个内容为 &lt;code&gt;200 (OK)&lt;/code&gt; 的响应。&lt;/p&gt;

&lt;p id=&#34;blue&#34;&gt;2. 退出测试 Pod，使用 &lt;code&gt;istioctl&lt;/code&gt; 为 httpbin.org 外部服务的访问设置一个 3 秒钟的超时：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cat &amp;lt;&amp;lt;EOF | istioctl create -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: httpbin-ext
spec:
  hosts:
    - httpbin.org
  http:
  - timeout: 3s
    route:
      - destination:
          host: httpbin.org
        weight: 100
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p id=&#34;blue&#34;&gt;3. 等待几秒钟之后，再次发起 `curl` 请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl exec -it $SOURCE_POD -c sleep bash
$ time curl -o /dev/null -s -w &amp;quot;%{http_code}\n&amp;quot; http://httpbin.org/delay/5

504

real    0m3.149s
user    0m0.004s
sys     0m0.004s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一次会在 3 秒钟之后收到一个内容为 &lt;code&gt;504 (Gateway Timeout)&lt;/code&gt; 的响应。虽然 httpbin.org 还在等待他的 5 秒钟，Istio 却在 3 秒钟的时候切断了请求。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-直接调用外部服务-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 直接调用外部服务&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;如果想要跳过 Istio，直接访问某个 IP 范围内的外部服务，就需要对 Envoy sidecar 进行配置，阻止 Envoy 对外部请求的&lt;a href=&#34;https://istio.io/zh/docs/concepts/traffic-management/#%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF&#34; target=&#34;_blank&#34;&gt;劫持&lt;/a&gt;。可以在 &lt;a href=&#34;https://istio.io/docs/reference/config/installation-options/&#34; target=&#34;_blank&#34;&gt;Helm&lt;/a&gt; 中设置 &lt;code&gt;global.proxy.includeIPRanges&lt;/code&gt; 变量，然后使用 kubectl apply 命令来更新名为 &lt;code&gt;istio-sidecar-injector&lt;/code&gt; 的 &lt;code&gt;Configmap&lt;/code&gt;。在 istio-sidecar-injector 更新之后，global.proxy.includeIPRanges 会在所有未来部署的 Pod 中生效。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;global.proxy.includeIPRanges&lt;/code&gt; 变量的最简单方式就是把内部服务的 IP 地址范围传递给它，这样就在 Sidecar proxy 的重定向列表中排除掉了外部服务的地址了。&lt;/p&gt;

&lt;p&gt;内部服务的 IP 范围取决于集群的部署情况。例如你的集群中这一范围是 &lt;code&gt;10.0.0.1/24&lt;/code&gt;，这个配置中，就应该这样更新 istio-sidecar-injector：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm template install/kubernetes/helm/istio &amp;lt;安装 Istio 时所使用的参数&amp;gt; --set global.proxy.includeIPRanges=&amp;quot;10.0.0.1/24&amp;quot; -x templates/sidecar-injector-configmap.yaml | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这里应该使用和之前部署 Istio 的时候同样的 Helm 命令，尤其是 &amp;ndash;namespace 参数。在安装 Istio 原有命令的基础之上，加入 &lt;code&gt;--set global.proxy.includeIPRanges=&amp;quot;10.0.0.1/24&amp;quot; -x templates/sidecar-injector-configmap.yaml&lt;/code&gt; 即可。&lt;/p&gt;

&lt;p&gt;然后和前面一样，重新部署 sleep 应用。更新了 &lt;code&gt;ConfigMap istio-sidecar-injector&lt;/code&gt; 并且重新部署了 sleep 应用之后，Istio sidecar 就应该只劫持和管理集群内部的请求了。任意的外部请求都会简单的绕过 Sidecar，直接访问目的地址。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export SOURCE_POD=$(kubectl get pod -l app=sleep -o go-template=&#39;{{range .items}}{{.metadata.name}}{{end}}&#39;)
$ kubectl exec -it $SOURCE_POD -c sleep curl http://httpbin.org/headers
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;p-id-h2-4-总结-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 总结&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;这个任务中，我们使用两种方式从 Istio 服务网格内部来完成对外部服务的调用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;ServiceEntry&lt;/code&gt; (推荐方式)&lt;/li&gt;
&lt;li&gt;配置 Istio sidecar，从它的重定向 IP 表中排除外部服务的 IP 范围&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式（&lt;code&gt;ServiceEntry&lt;/code&gt;）中，网格内部的服务不论是访问内部还是外部的服务，都可以使用同样的 Istio 服务网格的特性。我们通过为外部服务访问设置超时规则的例子，来证实了这一优势。&lt;/p&gt;

&lt;p&gt;第二种方式越过了 Istio sidecar proxy，让服务直接访问到对应的外部地址。然而要进行这种配置，需要了解云供应商特定的知识和配置。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-清理-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 清理&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;删除规则：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   $ istioctl delete serviceentry httpbin-ext baidu
   $ istioctl delete virtualservice httpbin-ext baidu
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;停止 sleep 服务：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   $ kubectl delete -f samples/sleep/sleep.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;扫一扫关注微信公众号&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#blue {
color: #2780e3;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>请求都去哪了？（续）</title>
      <link>https://www.yangcs.net/posts/where-is-the-request-2/</link>
      <pubDate>Mon, 13 Aug 2018 16:30:30 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/where-is-the-request-2/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;书接前文，上文我们通过跟踪&lt;strong&gt;集群外通过 ingressgateway 发起的请求&lt;/strong&gt;来探寻流量在 Istio 服务网格之间的流动方向，先部署 bookinfo 示例应用，然后创建一个监听在 &lt;code&gt;ingressgateway&lt;/code&gt; 上的  GateWay 和 VirtualService，通过分析我们追踪到请求最后转交给了 &lt;code&gt;productpage&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在继续追踪请求之前，先对之前的内容做一个补充说明。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-pod-在服务网格之间如何通信-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. Pod 在服务网格之间如何通信？&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;大家都知道，在 Istio 尚未出现之前，Kubernetes 集群内部 Pod 之间是通过 &lt;code&gt;ClusterIP&lt;/code&gt; 来进行通信的，那么通过 Istio 在 Pod 内部插入了 &lt;code&gt;Sidecar&lt;/code&gt; 之后，微服务应用之间是否仍然还是通过 ClusterIP 来通信呢？我们来一探究竟！&lt;/p&gt;

&lt;p&gt;继续拿上文的步骤举例子，来看一下 ingressgateway 和 productpage 之间如何通信，请求通过 ingressgateway 到达了 &lt;code&gt;endpoint&lt;/code&gt; ，那么这个 endpoint 到底是 &lt;code&gt;ClusterIP&lt;/code&gt; + Port 还是 &lt;code&gt;PodIP&lt;/code&gt; + Port 呢？由于 istioctl 没有提供 eds 的查看参数，可以通过 pilot 的 xds debug 接口来查看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 获取 istio-pilot 的 ClusterIP
$ export PILOT_SVC_IP=$(kubectl -n istio-system get svc -l app=istio-pilot -o go-template=&#39;{{range .items}}{{.spec.clusterIP}}{{end}}&#39;)

# 查看 eds
$ curl http://$PILOT_SVC_IP:8080/debug/edsz|grep &amp;quot;outbound|9080||productpage.default.svc.cluster.local&amp;quot; -A 27 -B 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;clusterName&amp;quot;: &amp;quot;outbound|9080||productpage.default.svc.cluster.local&amp;quot;,
  &amp;quot;endpoints&amp;quot;: [
    {
      &amp;quot;lbEndpoints&amp;quot;: [
        {
          &amp;quot;endpoint&amp;quot;: {
            &amp;quot;address&amp;quot;: {
              &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;172.30.135.40&amp;quot;,
                &amp;quot;portValue&amp;quot;: 9080
              }
            }
          },
          &amp;quot;metadata&amp;quot;: {
            &amp;quot;filterMetadata&amp;quot;: {
              &amp;quot;istio&amp;quot;: {
                  &amp;quot;uid&amp;quot;: &amp;quot;kubernetes://productpage-v1-76474f6fb7-pmglr.default&amp;quot;
                }
            }
          }
        }
      ]
    }
  ]
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里可以看出，各个微服务之间是直接通过 &lt;code&gt;PodIP + Port&lt;/code&gt; 来通信的，Service 只是做一个逻辑关联用来定位 Pod，实际通信的时候并没有通过 Service。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-部署-bookinfo-应用的时候发生了什么-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 部署 bookinfo 应用的时候发生了什么？&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;通过 Istio 来部署 bookinfo 示例应用时，Istio 会向应用程序的所有 Pod 中注入 Envoy 容器。但是我们仍然还不清楚注入的 Envoy 容器的配置文件里都有哪些东西，这时候就是 istioctl 命令行工具发挥强大功效的时候了，可以通过 &lt;code&gt;proxy-config&lt;/code&gt; 参数来深度解析 Envoy 的配置文件（上一节我们已经使用过了）。&lt;/p&gt;

&lt;p&gt;我们先把目光锁定在某一个固定的 Pod 上，以 &lt;code&gt;productpage&lt;/code&gt; 为例。先查看 productpage 的 Pod Name：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pod -l app=productpage

NAME                              READY     STATUS    RESTARTS   AGE
productpage-v1-76474f6fb7-pmglr   2/2       Running   0          7h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#2780e3&#34;&gt;1. 查看 productpage 的监听器的基本基本摘要&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr

ADDRESS            PORT      TYPE
172.30.135.40      9080      HTTP    // ③ Receives all inbound traffic on 9080 from listener `0.0.0.0_15001`
10.254.223.255     15011     TCP &amp;lt;---+
10.254.85.22       20001     TCP     |
10.254.149.167     443       TCP     |
10.254.14.157      42422     TCP     |
10.254.238.17      9090      TCP     |  ② Receives outbound non-HTTP traffic for relevant IP:PORT pair from listener `0.0.0.0_15001`
10.254.184.32      5556      TCP     |
10.254.0.1         443       TCP     |
10.254.52.199      8080      TCP     |
10.254.118.224     443       TCP &amp;lt;---+  
0.0.0.0            15031     HTTP &amp;lt;--+
0.0.0.0            15004     HTTP    |
0.0.0.0            9093      HTTP    |
0.0.0.0            15030     HTTP    |
0.0.0.0            8080      HTTP    |  ④ Receives outbound HTTP traffic for relevant port from listener `0.0.0.0_15001`
0.0.0.0            8086      HTTP    |
0.0.0.0            9080      HTTP    |
0.0.0.0            15010     HTTP &amp;lt;--+
0.0.0.0            15001     TCP     // ① Receives all inbound and outbound traffic to the pod from IP tables and hands over to virtual listener
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Istio 会生成以下的监听器：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;① &lt;code&gt;0.0.0.0:15001&lt;/code&gt; 上的监听器接收进出 Pod 的所有流量，然后将请求移交给虚拟监听器。&lt;/li&gt;
&lt;li&gt;② 每个 Service IP 配置一个虚拟监听器，每个出站 TCP/HTTPS 流量一个非 HTTP 监听器。&lt;/li&gt;
&lt;li&gt;③ 每个 Pod 入站流量暴露的端口配置一个虚拟监听器。&lt;/li&gt;
&lt;li&gt;④ 每个出站 HTTP 流量的 HTTP &lt;code&gt;0.0.0.0&lt;/code&gt; 端口配置一个虚拟监听器。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上一节提到服务网格之间的应用是直接通过 PodIP 来进行通信的，但还不知道服务网格内的应用与服务网格外的应用是如何通信的。大家应该可以猜到，这个秘密就隐藏在 Service IP 的虚拟监听器中，以 &lt;code&gt;kube-dns&lt;/code&gt; 为例，查看 productpage 如何与 kube-dns 进行通信：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr --address 10.254.0.2 --port 53 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;10.254.0.2_53&amp;quot;,
        &amp;quot;address&amp;quot;: {
            &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;10.254.0.2&amp;quot;,
                &amp;quot;portValue&amp;quot;: 53
            }
        },
        &amp;quot;filterChains&amp;quot;: [
            {
                &amp;quot;filters&amp;quot;: [
                    ...
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;envoy.tcp_proxy&amp;quot;,
                        &amp;quot;config&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|53||kube-dns.kube-system.svc.cluster.local&amp;quot;,
                            &amp;quot;stat_prefix&amp;quot;: &amp;quot;outbound|53||kube-dns.kube-system.svc.cluster.local&amp;quot;
                        }
                    }
                ]
            }
        ],
        &amp;quot;deprecatedV1&amp;quot;: {
            &amp;quot;bindToPort&amp;quot;: false
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看 eds
$ curl http://$PILOT_SVC_IP:8080/debug/edsz|grep &amp;quot;outbound|53||kube-dns.kube-system.svc.cluster.local&amp;quot; -A 27 -B 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;clusterName&amp;quot;: &amp;quot;outbound|53||kube-dns.kube-system.svc.cluster.local&amp;quot;,
  &amp;quot;endpoints&amp;quot;: [
    {
      &amp;quot;lbEndpoints&amp;quot;: [
        {
          &amp;quot;endpoint&amp;quot;: {
            &amp;quot;address&amp;quot;: {
              &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;172.30.135.21&amp;quot;,
                &amp;quot;portValue&amp;quot;: 53
              }
            }
          },
          &amp;quot;metadata&amp;quot;: {
            &amp;quot;filterMetadata&amp;quot;: {
              &amp;quot;istio&amp;quot;: {
                  &amp;quot;uid&amp;quot;: &amp;quot;kubernetes://coredns-64b597b598-4rstj.kube-system&amp;quot;
                }
            }
          }
        }
      ]
    },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，服务网格内的应用仍然通过 ClusterIP 与网格外的应用通信，但有一点需要注意：&lt;strong&gt;这里并没有 &lt;code&gt;kube-proxy&lt;/code&gt; 的参与！&lt;/strong&gt;Envoy 自己实现了一套流量转发机制，当你访问 ClusterIP 时，Envoy 就把流量转发到具体的 Pod 上去，&lt;strong&gt;不需要借助 kube-proxy 的 &lt;code&gt;iptables&lt;/code&gt; 或 &lt;code&gt;ipvs&lt;/code&gt; 规则&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;font color=&#34;#2780e3&#34;&gt;2. 从上面的摘要中可以看出，每个 Sidecar 都有一个绑定到 &lt;code&gt;0.0.0.0:15001&lt;/code&gt; 的监听器，IP tables 将 pod 的所有入站和出站流量路由到这里。此监听器把 &lt;code&gt;useOriginalDst&lt;/code&gt; 设置为 true，这意味着它将请求交给最符合请求原始目标的监听器。如果找不到任何匹配的虚拟监听器，它会将请求发送给返回 404 的 &lt;code&gt;BlackHoleCluster&lt;/code&gt;。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr --port 15001 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;virtual&amp;quot;,
        &amp;quot;address&amp;quot;: {
            &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
                &amp;quot;portValue&amp;quot;: 15001
            }
        },
        &amp;quot;filterChains&amp;quot;: [
            {
                &amp;quot;filters&amp;quot;: [
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;envoy.tcp_proxy&amp;quot;,
                        &amp;quot;config&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;BlackHoleCluster&amp;quot;,
                            &amp;quot;stat_prefix&amp;quot;: &amp;quot;BlackHoleCluster&amp;quot;
                        }
                    }
                ]
            }
        ],
        &amp;quot;useOriginalDst&amp;quot;: true
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#2780e3&#34;&gt;3. 我们的请求是到 &lt;code&gt;9080&lt;/code&gt; 端口的 HTTP 出站请求，这意味着它被切换到 &lt;code&gt;0.0.0.0:9080&lt;/code&gt; 虚拟监听器。然后，此监听器在其配置的 RDS 中查找路由配置。在这种情况下，它将查找由 Pilot 配置的 RDS 中的路由 &lt;code&gt;9080&lt;/code&gt;（通过 ADS）。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config listeners productpage-v1-76474f6fb7-pmglr --address 0.0.0.0 --port 9080 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;...
&amp;quot;rds&amp;quot;: {
    &amp;quot;config_source&amp;quot;: {
        &amp;quot;ads&amp;quot;: {}
    },
    &amp;quot;route_config_name&amp;quot;: &amp;quot;9080&amp;quot;
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#2780e3&#34;&gt;4. &lt;code&gt;9080&lt;/code&gt; 路由配置仅为每个服务提供虚拟主机。我们的请求正在前往 reviews 服务，因此 Envoy 将选择我们的请求与域匹配的虚拟主机。一旦在域上匹配，Envoy 会查找与请求匹配的第一条路径。在这种情况下，我们没有任何高级路由，因此只有一条路由匹配所有内容。这条路由告诉 Envoy 将请求发送到 &lt;code&gt;outbound|9080||reviews.default.svc.cluster.local&lt;/code&gt; 集群。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config routes productpage-v1-76474f6fb7-pmglr --name 9080 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;9080&amp;quot;,
        &amp;quot;virtualHosts&amp;quot;: [
            {
                &amp;quot;name&amp;quot;: &amp;quot;reviews.default.svc.cluster.local:9080&amp;quot;,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;reviews.default.svc.cluster.local&amp;quot;,
                    &amp;quot;reviews.default.svc.cluster.local:9080&amp;quot;,
                    &amp;quot;reviews&amp;quot;,
                    &amp;quot;reviews:9080&amp;quot;,
                    &amp;quot;reviews.default.svc.cluster&amp;quot;,
                    &amp;quot;reviews.default.svc.cluster:9080&amp;quot;,
                    &amp;quot;reviews.default.svc&amp;quot;,
                    &amp;quot;reviews.default.svc:9080&amp;quot;,
                    &amp;quot;reviews.default&amp;quot;,
                    &amp;quot;reviews.default:9080&amp;quot;,
                    &amp;quot;172.21.152.34&amp;quot;,
                    &amp;quot;172.21.152.34:9080&amp;quot;
                ],
                &amp;quot;routes&amp;quot;: [
                    {
                        &amp;quot;match&amp;quot;: {
                            &amp;quot;prefix&amp;quot;: &amp;quot;/&amp;quot;
                        },
                        &amp;quot;route&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|9080||reviews.default.svc.cluster.local&amp;quot;,
                            &amp;quot;timeout&amp;quot;: &amp;quot;0.000s&amp;quot;
                        },
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;font color=&#34;#2780e3&#34;&gt;5. 此集群配置为从 Pilot（通过 ADS）检索关联的端点。因此，Envoy 将使用 &lt;code&gt;serviceName&lt;/code&gt; 字段作为密钥来查找端点列表并将请求代理到其中一个端点。&lt;/font&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config clusters productpage-v1-76474f6fb7-pmglr --fqdn reviews.default.svc.cluster.local -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;outbound|9080||reviews.default.svc.cluster.local&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;EDS&amp;quot;,
        &amp;quot;edsClusterConfig&amp;quot;: {
            &amp;quot;edsConfig&amp;quot;: {
                &amp;quot;ads&amp;quot;: {}
            },
            &amp;quot;serviceName&amp;quot;: &amp;quot;outbound|9080||reviews.default.svc.cluster.local&amp;quot;
        },
        &amp;quot;connectTimeout&amp;quot;: &amp;quot;1.000s&amp;quot;,
        &amp;quot;circuitBreakers&amp;quot;: {
            &amp;quot;thresholds&amp;quot;: [
                {}
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的整个过程就是在不创建任何规则的情况下请求从 &lt;code&gt;productpage&lt;/code&gt; 到 &lt;code&gt;reviews&lt;/code&gt; 的过程，从 reviews 到网格内其他应用的流量与上面类似，就不展开讨论了。接下来分析创建规则之后的请求转发过程。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-virtualservice-和-destinationrule-配置解析-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. VirtualService 和 DestinationRule 配置解析&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;virtualservice&#34;&gt;VirtualService&lt;/h4&gt;

&lt;p&gt;首先创建一个 &lt;code&gt;VirtualService&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
    - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v1
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上一篇文章已经介绍过，&lt;code&gt;VirtualService&lt;/code&gt; 映射的就是 Envoy 中的 &lt;code&gt;Http Route Table&lt;/code&gt;，还是将目标锁定在 productpage 上，我们来查看一下路由配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config routes productpage-v1-76474f6fb7-pmglr --name 9080 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;9080&amp;quot;,
        &amp;quot;virtualHosts&amp;quot;: [
            {
                &amp;quot;name&amp;quot;: &amp;quot;reviews.default.svc.cluster.local:9080&amp;quot;,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;reviews.default.svc.cluster.local&amp;quot;,
                    &amp;quot;reviews.default.svc.cluster.local:9080&amp;quot;,
                    &amp;quot;reviews&amp;quot;,
                    &amp;quot;reviews:9080&amp;quot;,
                    &amp;quot;reviews.default.svc.cluster&amp;quot;,
                    &amp;quot;reviews.default.svc.cluster:9080&amp;quot;,
                    &amp;quot;reviews.default.svc&amp;quot;,
                    &amp;quot;reviews.default.svc:9080&amp;quot;,
                    &amp;quot;reviews.default&amp;quot;,
                    &amp;quot;reviews.default:9080&amp;quot;,
                    &amp;quot;172.21.152.34&amp;quot;,
                    &amp;quot;172.21.152.34:9080&amp;quot;
                ],
                &amp;quot;routes&amp;quot;: [
                    {
                        &amp;quot;match&amp;quot;: {
                            &amp;quot;prefix&amp;quot;: &amp;quot;/&amp;quot;
                        },
                        &amp;quot;route&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|9080|v1|reviews.default.svc.cluster.local&amp;quot;,
                            &amp;quot;timeout&amp;quot;: &amp;quot;0.000s&amp;quot;
                        },
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意对比一下没创建 VirtualService 之前的路由，现在路由的 &lt;code&gt;cluster&lt;/code&gt; 字段的值已经从之前的 &lt;code&gt;outbound|9080|reviews.default.svc.cluster.local&lt;/code&gt; 变为 &lt;code&gt;outbound|9080|v1|reviews.default.svc.cluster.local&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请注意：&lt;/strong&gt;我们现在还没有创建 DestinationRule！&lt;/p&gt;

&lt;p&gt;你可以尝试搜索一下有没有 &lt;code&gt;outbound|9080|v1|reviews.default.svc.cluster.local&lt;/code&gt; 这个集群，如果不出意外，你将找不到 &lt;code&gt;SUBSET=v1&lt;/code&gt; 的集群。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Jietu20180813-160027.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;由于找不到这个集群，所以该路由不可达，这就是为什么你打开 productpage 的页面会出现如下的报错：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Jietu20180813-160823.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h4 id=&#34;destinationrule&#34;&gt;DestinationRule&lt;/h4&gt;

&lt;p&gt;为了使上面创建的路由可达，我们需要创建一个 &lt;code&gt;DestinationRule&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: reviews
spec:
  host: reviews
  subsets:
  - name: v1
    labels:
      version: v1
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实 &lt;code&gt;DestinationRule&lt;/code&gt; 映射到 Envoy 的配置文件中就是 &lt;code&gt;Cluster&lt;/code&gt;。现在你应该能看到 &lt;code&gt;SUBSET=v1&lt;/code&gt; 的 Cluster 了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl proxy-config clusters productpage-v1-76474f6fb7-pmglr --fqdn reviews.default.svc.cluster.local --subset=v1 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;outbound|9080|v1|reviews.default.svc.cluster.local&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;EDS&amp;quot;,
        &amp;quot;edsClusterConfig&amp;quot;: {
            &amp;quot;edsConfig&amp;quot;: {
                &amp;quot;ads&amp;quot;: {}
            },
            &amp;quot;serviceName&amp;quot;: &amp;quot;outbound|9080|v1|reviews.default.svc.cluster.local&amp;quot;
        },
        &amp;quot;connectTimeout&amp;quot;: &amp;quot;1.000s&amp;quot;,
        &amp;quot;circuitBreakers&amp;quot;: {
            &amp;quot;thresholds&amp;quot;: [
                {}
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到了这一步，一切皆明了，后面的事情就跟之前的套路一样了，具体的 Endpoint 对应打了标签 &lt;code&gt;version=v1&lt;/code&gt; 的 Pod：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pod -l app=reviews,version=v1 -o wide

NAME                          READY     STATUS    RESTARTS   AGE       IP              NODE
reviews-v1-5b487cc689-njx5t   2/2       Running   0          11h       172.30.104.38   192.168.123.248
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://$PILOT_SVC_IP:8080/debug/edsz|grep &amp;quot;outbound|9080|v1|reviews.default.svc.cluster.local&amp;quot; -A 27 -B 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;clusterName&amp;quot;: &amp;quot;outbound|9080|v1|reviews.default.svc.cluster.local&amp;quot;,
  &amp;quot;endpoints&amp;quot;: [
    {
      &amp;quot;lbEndpoints&amp;quot;: [
        {
          &amp;quot;endpoint&amp;quot;: {
            &amp;quot;address&amp;quot;: {
              &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;172.30.104.38&amp;quot;,
                &amp;quot;portValue&amp;quot;: 9080
              }
            }
          },
          &amp;quot;metadata&amp;quot;: {
            &amp;quot;filterMetadata&amp;quot;: {
              &amp;quot;istio&amp;quot;: {
                  &amp;quot;uid&amp;quot;: &amp;quot;kubernetes://reviews-v1-5b487cc689-njx5t.default&amp;quot;
                }
            }
          }
        }
      ]
    }
  ]
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在再次用浏览器访问 productpage，你会发现报错已经消失了。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Jietu20180813-162629.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 参考&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/help/ops/traffic-management/proxy-cmd/&#34; target=&#34;_blank&#34;&gt;调试 Envoy 和 Pilot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;扫一扫关注微信公众号&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>干货与湿货分享第4期</title>
      <link>https://www.yangcs.net/posts/weekly-4/</link>
      <pubDate>Sat, 11 Aug 2018 18:17:12 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/weekly-4/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;这是《干货与湿货分享》系列的第四期，主要记录过去一周我所见到的听到的值得分享的东西。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-新闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;新闻&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;1-摩拜女员工举报领导性骚扰-https-3g-163-com-all-article-dope3qg700097u7r-html&#34;&gt;1. &lt;a href=&#34;https://3g.163.com/all/article/DOPE3QG700097U7R.html&#34; target=&#34;_blank&#34;&gt;摩拜女员工举报领导性骚扰&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cms-bucket.nosdn.127.net/2018/08/09/6fb4d8a192d7460fb8b02442b1fe75fa.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cms-bucket.nosdn.127.net/catchpic/8/83/836bd63860e69573562d0e06fd14ba24.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cms-bucket.nosdn.127.net/catchpic/3/3d/3d99e230238e37c9804b923a0f272278.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8月9日，网络上出现一张截图，截图内容为摩拜女员工举报领导性骚扰。针对此事，摩拜回复称被举报人已被停职并接受进一步调查。&lt;/strong&gt;网络截图显示，举报者为摩拜SPE前端组的一名普通员工，于2017年进入摩拜工作。据举报者描述，摩拜客户端&amp;amp;前端组负责人张耀春曾对多位下属性骚扰，受骚扰最严重的女同事被迫离职。&lt;/p&gt;

&lt;h4 id=&#34;2-中关村程序员在车流中改代码-http-www-cocoachina-com-cms-wap-php-action-article-id-24506&#34;&gt;2. &lt;a href=&#34;http://www.cocoachina.com/cms/wap.php?action=article&amp;amp;id=24506&#34; target=&#34;_blank&#34;&gt;中关村程序员在车流中改代码&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://api.cocoachina.com/uploads//20180809/1533784496266270.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;事件发生在早高峰时期，地点为中关村软件园，因为堵车厉害，楼主恰巧看到了这一幕，一名略微有些秃顶，穿着蓝白条纹短袖的程序员蹲在信号灯下调试代码，疑似信号灯的算法程序出现了bug，该名程序员正在现场紧急处理。在其四周，车辆已经拥堵得水泄不通，但在这名程序员看来，此刻他眼里只有急需解决的代码问题，眼前的其它都被忽略。&lt;/p&gt;

&lt;h4 id=&#34;3-特斯拉开出三倍工资抢上汽技术员工-http-tech-qq-com-a-20180807-002406-htm&#34;&gt;3. &lt;a href=&#34;http://tech.qq.com/a/20180807/002406.htm&#34; target=&#34;_blank&#34;&gt;特斯拉开出三倍工资抢上汽技术员工&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://inews.gtimg.com/newsapp_bt/0/3871231544/641&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;特斯拉在上海建设的、被称作“无敌舰”的工厂，目前正在大规模招募第一批“船员”。8月5日，特斯拉在其官方微信上首次发布热招职位，包括EPC工程总监、政府事务项目经理、施工经理、土木工程师、电气设计工程师、机械设计师以及法律顾问、高级财务经理、招聘人员等。&lt;/p&gt;

&lt;p&gt;一位知情人士告诉21世纪经济报道记者：“特斯拉上海工厂已经在抢人了，直接开出三倍工资，上汽的技术人员走了一大批。”&lt;/p&gt;

&lt;h4 id=&#34;4-李彦宏回应谷歌重返大陆-有信心再赢一次-https-tech-sina-com-cn-i-2018-08-07-doc-ihhkuskt0298624-shtml&#34;&gt;4. &lt;a href=&#34;https://tech.sina.com.cn/i/2018-08-07/doc-ihhkuskt0298624.shtml&#34; target=&#34;_blank&#34;&gt;李彦宏回应谷歌重返大陆：有信心再赢一次&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://n.sinaimg.cn/tech/transform/22/w550h1072/20180807/zMit-hhkuskt0328373.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Google 又双叒叕要回归中国，这是谷歌今年以来第5次传出“返华”的传闻，而有人民日报发文欢迎 Google 回归的消息，似乎印证这次应该是来真的了！&lt;/p&gt;

&lt;p&gt;人民日报近日在社交媒体平台 Twitter、Facebook 上刊登了一篇标题为 “Stability prerequisite for China’s internet opening up” 的文章，文章表示，“欢迎 Google 回到中国大陆，但前提是得遵守政府相关的法律政策。”作为主要的竞争对手，百度的李彦宏今天公开在朋友圈对传闻进行了回应“如果 Google 决定回到中国，我们非常有信心再PK一次，再赢一次”。&lt;/p&gt;

&lt;p&gt;很快就有调皮的小编开始做测验了，测试结果啪啪啪打脸。。。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://resource01.ulifestyle.com.hk/res/v3/image/content/2130000/2132767/20180807_googlebaidu_04_600.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h4 id=&#34;5-腾讯云承认自身错误导致用户数据丢失-https-36kr-com-p-5146916-html&#34;&gt;5. &lt;a href=&#34;https://36kr.com/p/5146916.html&#34; target=&#34;_blank&#34;&gt;腾讯云承认自身错误导致用户数据丢失&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1262.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;腾讯云服务最近发生了一起引发广泛关注的用户数据丢失事故。“前沿数控技术新媒体”8月5日晚间发微博称，在使用腾讯云8个月后，公司存储在腾讯云上的数据无可挽回地全部丢失。腾讯云公布的调查报告，承认是自己犯下的一系列错误导致用户数据丢失，并表示将尽力帮助客户解决问题，同时优化机制避免类似情况再度发生。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-工具-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;工具&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;1-ice-https-github-com-alibaba-ice&#34;&gt;1. &lt;a href=&#34;https://github.com/alibaba/ice&#34; target=&#34;_blank&#34;&gt;ice&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;飞冰是一套阿里巴巴开源的基于 React 的中后台应用解决方案，在阿里巴巴内部，已经有 270 多个来自几乎所有 BU 的项目在使用。&lt;/p&gt;

&lt;h4 id=&#34;2-feediary-不跟踪-纯文本-rss-阅读器-https-feediary-com&#34;&gt;2. &lt;a href=&#34;https://feediary.com/&#34; target=&#34;_blank&#34;&gt;Feediary – 不跟踪、纯文本 RSS 阅读器&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://apprcn.b0.upaiyun.com/Feediary-1.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;RSS 阅读器是有不少了，但可能每个阅读器都会标榜自己有多么多的功能，功能丰富到你 90% 都用不上。Feediary 这个 RSS 阅读器反而是相反，它功能不多，但够专注和够纯净。&lt;/p&gt;

&lt;p&gt;Feediary 是一款网页 RSS 阅读器，简单注册后就可以使用了。有免费版和收费版区分，最大区别就是免费版最多只可以添加 50 个 RSS 源，收费版当然就没什么限制了。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://apprcn.b0.upaiyun.com/Feediary-2.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h4 id=&#34;3-licketylink-http-lickety-link&#34;&gt;3. &lt;a href=&#34;http://lickety.link/&#34; target=&#34;_blank&#34;&gt;LicketyLink&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://cdn.ilovefreesoftware.com/wp-content/uploads/2018/08/create-a-new-sharing-link-with-custom-name-and-add-files.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这是一个可以在线共享文件的网站，并且对上传文件的大小没有任何限制，对下载速度也没有任何限制。我们都知道，百度云等其他国内网盘对上传文件大小有限制，而且在不买会员的情况下下载速度极慢！这个网站将会是你的救星。&lt;/p&gt;

&lt;p&gt;值得一提的是，该网站用一种很特别的方法来共享文件，它会先生成一个共享链接，然后你可以随意往这个链接里面添加或删除文件，共享链接不变，是不是很爽？还有一个大招就是你不用等待文件上传成功就可以分享给其他人了，我只能说还有谁？！&lt;/p&gt;

&lt;h4 id=&#34;4-sharefiles-https-sharefiles-app&#34;&gt;4. &lt;a href=&#34;https://sharefiles.app/&#34; target=&#34;_blank&#34;&gt;ShareFiles&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;另一个不限文件大小的在线共享网站。&lt;/p&gt;

&lt;h4 id=&#34;5-onlim-https-onlim-com&#34;&gt;5. &lt;a href=&#34;https://onlim.com/&#34; target=&#34;_blank&#34;&gt;Onlim&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/onlim.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Pnlim 是一个免费的在线社交媒体管理工具，你可以在这里面添加无限多的社交账户（支持 Facebook、Twitter 和 Slack 等）。同时还可以添加 RSS 源，所以你也可以把它当成一个 RSS 阅读器，颜值还是很高的。&lt;/p&gt;

&lt;h4 id=&#34;6-zhuye-kim-https-github-com-wenguonideshou-zhuye-kim&#34;&gt;6. &lt;a href=&#34;https://github.com/wenguonideshou/zhuye_kim&#34; target=&#34;_blank&#34;&gt;zhuye_kim&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/zhuye_kim_google.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/zhuye_kim_baidu.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;仿 zhuye.kim 的简单个人主页/导航程序，带后台&lt;/p&gt;

&lt;h4 id=&#34;7-cartoonify-https-www-kapwing-com-cartoonify&#34;&gt;7. &lt;a href=&#34;https://www.kapwing.com/cartoonify&#34; target=&#34;_blank&#34;&gt;Cartoonify&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://i.loli.net/2018/07/23/5b5548bc8df23.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Cartoonify 是 Google 一项很有趣的免费在线工具，使用人工智能将你上传的相片转为涂鸦手绘风格，它以 Draw This 做为基础，非常有意思，如果你想知道将相片丢给机器辨识、它会智能返回什么样的结果呢？&lt;/p&gt;

&lt;h4 id=&#34;8-my-free-mp3-https-my-free-mp3-net-cn&#34;&gt;8. &lt;a href=&#34;https://my-free-mp3.net/cn&#34; target=&#34;_blank&#34;&gt;my-free-mp3&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftwxawbt8aj30sm0ij75t.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;现在版权管理越来越严格，之前用百度音乐一个就行了，现在想下载一首歌要用到不同的 APP，不少大平台还只能试听不能下载。今天这个网页版的比较好用，输入歌曲名就可搜索了，同时输入歌曲名和歌手可提高精准度，点击后面的 Size-Kbps 可以查看码率，一般为 320K 音质，支持在线试听和下载，实在搜索不到换繁体字再搜。点后面下载会跳转到一个中间页面，点”ENTER”就可以下载了，个人测试多首音乐都可以下载。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://wx1.sinaimg.cn/mw690/0060lm7Tly1ftwxawt2r1j30xr0kmwhi.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-教程-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;教程&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;1-系统设计入门-https-github-com-donnemartin-system-design-primer&#34;&gt;1. &lt;a href=&#34;https://github.com/donnemartin/system-design-primer&#34; target=&#34;_blank&#34;&gt;系统设计入门&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;系统设计是一个很宽泛的话题。在互联网上，&lt;strong&gt;关于系统设计原则的资源也是多如牛毛。&lt;/strong&gt;这个仓库就是这些资源的组织收集，它可以帮助你学习如何构建可扩展的系统。&lt;/p&gt;

&lt;h4 id=&#34;2-命令行的艺术-https-github-com-jlevy-the-art-of-command-line-blob-master-readme-zh-md&#34;&gt;2. &lt;a href=&#34;https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md&#34; target=&#34;_blank&#34;&gt;命令行的艺术&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份作者在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。&lt;/p&gt;

&lt;h4 id=&#34;3-kubernetes-in-action-https-www-manning-com-books-kubernetes-in-action&#34;&gt;3. &lt;a href=&#34;https://www.manning.com/books/kubernetes-in-action&#34; target=&#34;_blank&#34;&gt;Kubernetes In Action&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-3d850923108ea1f17348d435fe098c23_1200x500.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这本书深入浅出的讲解了 Kubernetes 的构架和设计理念，非常难能可贵。通过这本书你将会学到如何在 non-deterministic 的分布式环境中，为 scheduler 和 controller 这种需要“唯一决策者设计”的组件提供 high availability 的同时，使 cluster 的调度决策稳定可靠的方法。&lt;/p&gt;

&lt;h4 id=&#34;4-理解-linux-进程-https-github-com-tobegit3hub-understand-linux-process&#34;&gt;4. &lt;a href=&#34;https://github.com/tobegit3hub/understand_linux_process&#34; target=&#34;_blank&#34;&gt;理解 Linux 进程&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;本书受 &lt;a href=&#34;http://www.duokan.com/book/41446&#34; target=&#34;_blank&#34;&gt;理解 Unix 进程&lt;/a&gt; 启发而作，用极简的篇幅深入学习进程知识。理解 Linux 进程用 Go 重写了所有示例程序，通过循序渐进的方法介绍 Linux 进程的工作原理和一切你所需要知道的概念。&lt;/p&gt;

&lt;h4 id=&#34;5-go语言高级编程-https-github-com-chai2010-advanced-go-programming-book&#34;&gt;5. &lt;a href=&#34;https://github.com/chai2010/advanced-go-programming-book&#34; target=&#34;_blank&#34;&gt;Go语言高级编程&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://github.com/chai2010/advanced-go-programming-book/raw/master/cover.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;本书涵盖 CGO、Go 汇编语言、RPC 实现、Web 框架实现、分布式系统等高阶主题，针对 Go 语言有一定经验想深入了解 Go 语言各种高级用法的开发人员。对于刚学习 Go 语言的读者，建议先从 &lt;a href=&#34;https://github.com/golang-china/gopl-zh&#34; target=&#34;_blank&#34;&gt;《Go语言圣经》&lt;/a&gt; 开始系统学习 Go 语言的基础知识。&lt;/p&gt;

&lt;h4 id=&#34;6-envoy为什么能战胜ngnix-线程模型分析篇-https-www-itcodemonkey-com-article-7042-html&#34;&gt;6. &lt;a href=&#34;https://www.itcodemonkey.com/article/7042.html&#34; target=&#34;_blank&#34;&gt;Envoy为什么能战胜Ngnix——线程模型分析篇&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;随着 Service Mesh 在最近一年的流行，Envoy 作为其中很关键的组件，也开始被广大技术人员熟悉。作者是 Envoy 的开发者之一，本文详细说明了 Envoy 的线程模型，对于理解 Envoy 如何工作非常有帮助。内容较为深入，建议细细品读。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;资源&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;1-programmer-job-blacklist-https-github-com-shengxinjing-programmer-job-blacklist&#34;&gt;1. &lt;a href=&#34;https://github.com/shengxinjing/programmer-job-blacklist&#34; target=&#34;_blank&#34;&gt;programmer-job-blacklist&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;这是一份程序员找工作黑名单，换工作和当技术合伙人需谨慎啊！每一个程序猿，每一个公司都有黑点，但是如果把黑点放大了，黑名单就没存在的意义了。&lt;/p&gt;

&lt;h4 id=&#34;2-杭州房产知识扫盲-https-github-com-houshanren-hangzhou-house-knowledge&#34;&gt;2. &lt;a href=&#34;https://github.com/houshanren/hangzhou_house_knowledge&#34; target=&#34;_blank&#34;&gt;杭州房产知识扫盲&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/hangzhou_house.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这是作者 2017 年买房经历总结出来的买房购房知识分享给大家，希望对大家有所帮助。买房不易，且买且珍惜。&lt;/p&gt;

&lt;h4 id=&#34;3-wallhalla-https-wallhalla-com&#34;&gt;3. &lt;a href=&#34;https://wallhalla.com/&#34; target=&#34;_blank&#34;&gt;Wallhalla&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://7xpi4m.com1.z0.glb.clouddn.com/201807282251_92.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;一个设计感十足的壁纸网站。该网站特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网站整体设计的非常简约大方；&lt;/li&gt;
&lt;li&gt;可以按照关键字、色彩、图片、标签进行搜索；&lt;/li&gt;
&lt;li&gt;Wallhalla 本身只是个图片搜索引擎，并不持有图片，但可以直接下载到原始图片；&lt;/li&gt;
&lt;li&gt;通过放大镜查看图片细节；&lt;/li&gt;
&lt;li&gt;展示图片的色彩组成和色系；&lt;/li&gt;
&lt;li&gt;可以随机或者最热门浏览图片&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-mojo-weixin-https-github-com-sjdy521-mojo-weixin&#34;&gt;4. &lt;a href=&#34;https://github.com/sjdy521/Mojo-Weixin&#34; target=&#34;_blank&#34;&gt;Mojo-Weixin&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;使用Perl语言编写的个人账号微信/weixin/wechat客户端框架（非GUI），可通过插件提供基于HTTP协议的api接口供其他语言或系统调用。可以利用微软小冰实现智能聊天回复、识别指定关键字发送美女图片、通过微信消息自定义问答知识库等各种功能应有尽有。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-奇闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;奇闻&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;1-历史上第一个真正能转的电动机&#34;&gt;1. 历史上第一个真正能转的电动机&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1264.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;法拉第单极电机的现代仿品&lt;/em&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;水银有毒，可用盐水代替&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;1821 年，法拉第搞出了一个真正能转的电动机，现在看来这个装置有点简陋。首先是一杯水银，水银是导电的，中间插进一根条形磁铁。上面挂钩上垂下来一根铜丝，另一头泡在水银里面，可以任意移动。顶上通电，电池另一头接到水银里边。这等于电流通过了水银和铁丝形成了一个回路。一通电，这个铁丝在围着水银里边的磁铁画圈圈。这是世界上第一个利用电磁力驱动的电动机，后来称为“单极电机”。&lt;/p&gt;

&lt;h4 id=&#34;2-维苏威火山&#34;&gt;2. 维苏威火山&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/8416081431.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;维苏威火山是欧洲最危险的火山，11 公里以外就是那不勒斯。公元 79 年的一次大喷发，埋葬了庞贝古城和附近的赫库兰尼姆、斯塔比亚等等城市。一开始连续发生了 4 天的地震，但是震级都不大，当时古罗马的人都不在乎。哪知道维苏威火山突然喷发了，火山灰云柱直冲 33km 高空。&lt;/p&gt;

&lt;p&gt;大量火山灰落到了附近的城市里面，房顶上累积了 3 厘米厚。夜里发生了 6 次火山碎屑流，火山喷发的时候，喷出的火山灰是滚烫的，加热了周围的空气，空气形成强大的上升气流，裹挟着火山灰往天上冒。但是温度下降了，热空气没那个力气把火山灰送入高空，火山灰很可能喷出来没多高就沿着山坡往下翻滚，于是热空气和火山灰裹挟着，形成了火山的碎屑流。到达赫库兰尼姆的时候，温度高达 500 度。因此城里的人瞬间碳化，定格在了那一刻。到达稍远的庞贝城的时候，温度降低到 300 度，因此庞贝城里面的遗骸留下了大量的遗体和衣服。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1265.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;庞贝城的悲惨景象&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;到了 1599 年的时候，因为挖掘地下引水工程，发现有雕塑和壁画，庞贝古城被发现。1738 年，命运悲惨的赫库兰尼姆被发现。1748 年，在那不勒斯王国国王夫妇的资助下，庞贝城也被挖出来了。如今这里都是世界文化遗产。&lt;/p&gt;

&lt;h4 id=&#34;3-夜明珠到底值不值钱&#34;&gt;3. 夜明珠到底值不值钱？&lt;/h4&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1267.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;em&gt;美丽的萤石&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;最早人们发现有一种东西叫做“萤石”，为什么起这个名字呢？因为在阳光照射过后，你迅速拿到黑暗中去看，会看到这种彩色的石头会发出荧光。有的石头荧光时间非常长，有的石头荧光时间非常短。今天市场上很多所谓的夜明珠，就是由发光时间比较长的萤石材料做成的。所以这些东西一点都不值钱。早在河姆渡时期就发现过用萤石来做装饰品。我们的老祖宗已经发现这东西是会发出荧光的。&lt;/p&gt;

&lt;p&gt;但是大家请注意，萤石这种材料千万不能和酸性的东西放在一起，和酸性的东西放在一起，会产生氟化氢，溶解在水里就是氢氟酸。1670年，有个德国人就发现，用萤石和硫酸放在一起，会冒出一种气体，这种气体居然能腐蚀玻璃。如果在玻璃表面涂上一层蜡，然后在蜡上刻出花纹，然后再用这种蒸汽去熏。等到你把蜡去掉就会发现，花纹已经刻在了玻璃上。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-欢迎关注-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;欢迎关注&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;该系列每周六发布，同步更新在我的个人&lt;a href=&#34;https://www.yangcs.net/&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;和微信公众号上。&lt;/p&gt;

&lt;p&gt;微信搜索 “云原生实验室” 或者扫描二维码即可关注。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>请求都去哪了？</title>
      <link>https://www.yangcs.net/posts/where-is-the-request-1/</link>
      <pubDate>Wed, 08 Aug 2018 16:56:31 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/where-is-the-request-1/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;通过前几篇文章的学习与实践，我们对 Gateway、VirtualService 和 Destinationrule 的概念和原理有了初步的认知，本篇将对这几个对象资源的配置文件进行深度地解析，具体细节将会深入到每一个配置项与 Envoy 配置项的映射关系。&lt;/p&gt;

&lt;p&gt;在开始之前，需要先搞清楚我们创建的这些对象资源最后都交给谁来处理了，负责处理这些资源的就是 pilot。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-pilot总体架构-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. pilot总体架构&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006tKfTcgy1ftppxdcmwvj31kw0vvtdl.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;首先我们回顾一下 pilot 总体架构，上面是&lt;a href=&#34;https://github.com/istio/old_pilot_repo/blob/master/doc/design.md&#34; target=&#34;_blank&#34;&gt;官方关于pilot的架构图&lt;/a&gt;，因为是 old_pilot_repo 目录下，可能与最新架构有出入，仅供参考。所谓的 pilot 包含两个组件：&lt;code&gt;pilot-agent&lt;/code&gt; 和 &lt;code&gt;pilot-discovery&lt;/code&gt;。图里的 &lt;code&gt;agent&lt;/code&gt; 对应 pilot-agent 二进制，&lt;code&gt;proxy&lt;/code&gt; 对应 Envoy 二进制，它们两个在同一个容器中，&lt;code&gt;discovery service&lt;/code&gt; 对应 pilot-discovery 二进制，在另外一个跟应用分开部署的单独的 Deployment 中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;discovery service&lt;/span&gt; : 从 Kubernetes apiserver list/watch &lt;code&gt;service&lt;/code&gt;、&lt;code&gt;endpoint&lt;/code&gt;、&lt;code&gt;pod&lt;/code&gt;、&lt;code&gt;node&lt;/code&gt; 等资源信息，监听 istio 控制平面配置信息（如VirtualService、DestinationRule等）， 翻译为 Envoy 可以直接理解的配置格式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;proxy&lt;/span&gt; : 也就是 Envoy，直接连接 discovery service，间接地从 Kubernetes 等服务注册中心获取集群中微服务的注册情况。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;agent&lt;/span&gt; : 生成 Envoy 配置文件，管理 Envoy 生命周期。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;service A/B&lt;/span&gt; : 使用了 Istio 的应用，如 Service A/B，的进出网络流量会被 proxy 接管。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单来说 Istio 做为管理面，集合了配置中心和服务中心两个功能，并把配置发现和服务发现以一组统一的 &lt;code&gt;xDS&lt;/code&gt; 接口提供出来，数据面的 Envoy 通过 xDS 获取需要的信息来做服务间通信和服务治理。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-pilot-discovery-为-envoy-提供的-xds-服务-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. pilot-discovery 为 Envoy 提供的 xds 服务&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;所谓-xds&#34;&gt;所谓 xds&lt;/h4&gt;

&lt;p&gt;pilot-discovery 为数据面（运行在 sidecar 中的 Envoy 等 proxy 组件）提供控制信息服务，也就是所谓的 discovery service 或者 xds 服务。这里的 &lt;code&gt;x&lt;/code&gt; 是一个代词，类似云计算里的 XaaS 可以指代 IaaS、PaaS、SaaS 等。在 Istio 中，xds 包括 &lt;code&gt;cds&lt;/code&gt;(cluster discovery service)、&lt;code&gt;lds&lt;/code&gt;(listener discovery service)、&lt;code&gt;rds&lt;/code&gt;(route discovery service)、&lt;code&gt;eds&lt;/code&gt;(endpoint discovery service)，而 &lt;code&gt;ads&lt;/code&gt;(aggregated discovery service) 是对这些服务的一个统一封装。&lt;/p&gt;

&lt;p&gt;以上 cluster、endpoint、route 等概念的详细介绍和实现细节可以参考 Envoy 在社区推广的 data plane api（&lt;a href=&#34;https://github.com/envoyproxy/data-plane-api&#34; target=&#34;_blank&#34;&gt;github.com/envoyproxy/data-plane-api&lt;/a&gt;），这里只做简单介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;endpoint&lt;/span&gt; : 一个具体的“应用实例”，对应 ip 和端口号，类似 Kubernetes 中的一个 Pod。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;cluster&lt;/span&gt; : 一个 &lt;code&gt;cluster&lt;/code&gt; 是一个“应用集群”，它对应提供相同服务的一个或多个 &lt;code&gt;endpoint&lt;/code&gt;。cluster 类似 Kubernetes 中 &lt;code&gt;Service&lt;/code&gt; 的概念，即一个 Kubernetes Service 对应一个或多个用同一镜像启动，提供相同服务的 Pod。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;route&lt;/span&gt; : 当我们做灰度发布、金丝雀发布时，同一个服务会同时运行多个版本，每个版本对应一个 cluster。这时需要通过 &lt;code&gt;route&lt;/code&gt; 规则规定请求如何路由到其中的某个版本的 cluster 上。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上这些内容实际上都是对 Envoy 等 proxy 的配置信息，而所谓的 cluster discovery service、route discovery service 等 xxx discovery service 就是 Envoy 等从 &lt;code&gt;pilot-discovery&lt;/code&gt; 动态获取 endpoint、cluster 等配置信息的协议和实现。为什么要做动态配置加载，自然是为了使用 &lt;code&gt;istioctl&lt;/code&gt; 等工具统一、灵活地配置 service mesh。至于如何通过 istioctl 来查看 xds 信息，下文将会详细介绍。&lt;/p&gt;

&lt;p&gt;而为什么要用 &lt;code&gt;ads&lt;/code&gt; 来“聚合”一系列 &lt;code&gt;xds&lt;/code&gt;，并非仅为了在同一个 gRPC 连接上实现多种 xds 来省下几个网络连接，ads 还有一个非常重要的作用是解决 &lt;code&gt;cds&lt;/code&gt;、&lt;code&gt;rds&lt;/code&gt; 信息更新顺序依赖的问题，从而保证以一定的顺序同步各类配置信息，这方面的讨论可以详见 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview#aggregated-discovery-service&#34; target=&#34;_blank&#34;&gt;Envoy官网&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;如何查看-xds&#34;&gt;如何查看 xds&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;pilot-discovery&lt;/code&gt; 在初始化阶段依次 init 了各种模块，其中 &lt;code&gt;discovery service&lt;/code&gt; 就是 xDS 相关实现。&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/&#34; target=&#34;_blank&#34;&gt;envoy API reference&lt;/a&gt; 可以查到 v1 和 v2 两个版本的 API 文档。&lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34;&gt;envoy control plane&lt;/a&gt; 给了 v2 grpc 接口相关的数据结构和接口。&lt;/p&gt;

&lt;p&gt;那么如何查看 xds 的信息呢？虽然 v2 是 &lt;code&gt;grpc&lt;/code&gt; 的接口，但是 pilot 提供了 &lt;code&gt;InitDebug&lt;/code&gt;，可以通过 debug 接口查询服务和 routes 等服务和配置信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看 eds&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先找到 Service istio-pilot 的 &lt;code&gt;Cluster IP&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export PILOT_SVC_IP=$(kubectl -n istio-system get svc istio-pilot -o go-template=&#39;{{.spec.clusterIP}}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后查看 eds：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://$PILOT_SVC_IP:8080/debug/edsz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[{
    &amp;quot;clusterName&amp;quot;: &amp;quot;outbound|9080||reviews.nino.svc.cluster.local&amp;quot;,
    &amp;quot;endpoints&amp;quot;: [{
        &amp;quot;lbEndpoints&amp;quot;: [{
            &amp;quot;endpoint&amp;quot;: {
                &amp;quot;address&amp;quot;: {
                    &amp;quot;socketAddress&amp;quot;: {
                        &amp;quot;address&amp;quot;: &amp;quot;10.244.0.56&amp;quot;,
                        &amp;quot;portValue&amp;quot;: 9080
                    }
                }
            }
        }, {
            &amp;quot;endpoint&amp;quot;: {
                &amp;quot;address&amp;quot;: {
                    &amp;quot;socketAddress&amp;quot;: {
                        &amp;quot;address&amp;quot;: &amp;quot;10.244.0.58&amp;quot;,
                        &amp;quot;portValue&amp;quot;: 9080
                    }
                }
            }
        }, {
            &amp;quot;endpoint&amp;quot;: {
                &amp;quot;address&amp;quot;: {
                    &amp;quot;socketAddress&amp;quot;: {
                        &amp;quot;address&amp;quot;: &amp;quot;10.244.2.25&amp;quot;,
                        &amp;quot;portValue&amp;quot;: 9080
                    }
                }
            }
        }]
    }]
}, {
    &amp;quot;clusterName&amp;quot;: &amp;quot;outbound|9080|v3|reviews.nino.svc.cluster.local&amp;quot;,
    &amp;quot;endpoints&amp;quot;: [{
        &amp;quot;lbEndpoints&amp;quot;: [{
            &amp;quot;endpoint&amp;quot;: {
                &amp;quot;address&amp;quot;: {
                    &amp;quot;socketAddress&amp;quot;: {
                        &amp;quot;address&amp;quot;: &amp;quot;10.244.0.58&amp;quot;,
                        &amp;quot;portValue&amp;quot;: 9080
                    }
                }
            }
        }]
    }]
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看 cds&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://$PILOT_SVC_IP:8080/debug/cdsz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[{&amp;quot;node&amp;quot;: &amp;quot;sidecar~172.30.104.45~fortio-deploy-56dcc85457-b2pkc.default~default.svc.cluster.local-10&amp;quot;, &amp;quot;addr&amp;quot;: &amp;quot;172.30.104.45:43876&amp;quot;, &amp;quot;connect&amp;quot;: &amp;quot;2018-08-07 06:31:08.161483005 +0000 UTC m=+54.337448884&amp;quot;,&amp;quot;Clusters&amp;quot;:[{
  &amp;quot;name&amp;quot;: &amp;quot;outbound|9080||details.default.svc.cluster.local&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;EDS&amp;quot;,
  &amp;quot;edsClusterConfig&amp;quot;: {
    &amp;quot;edsConfig&amp;quot;: {
      &amp;quot;ads&amp;quot;: {

      }
    },
    &amp;quot;serviceName&amp;quot;: &amp;quot;outbound|9080||details.default.svc.cluster.local&amp;quot;
  },
  &amp;quot;connectTimeout&amp;quot;: &amp;quot;1.000s&amp;quot;,
  &amp;quot;circuitBreakers&amp;quot;: {
    &amp;quot;thresholds&amp;quot;: [
      {

      }
    ]
  }
},
...
{
  &amp;quot;name&amp;quot;: &amp;quot;outbound|9090||prometheus-k8s.monitoring.svc.cluster.local&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;EDS&amp;quot;,
  &amp;quot;edsClusterConfig&amp;quot;: {
    &amp;quot;edsConfig&amp;quot;: {
      &amp;quot;ads&amp;quot;: {

      }
    },
    &amp;quot;serviceName&amp;quot;: &amp;quot;outbound|9090||prometheus-k8s.monitoring.svc.cluster.local&amp;quot;
  },
  &amp;quot;connectTimeout&amp;quot;: &amp;quot;1.000s&amp;quot;,
  &amp;quot;circuitBreakers&amp;quot;: {
    &amp;quot;thresholds&amp;quot;: [
      {

      }
    ]
  }
},
{
  &amp;quot;name&amp;quot;: &amp;quot;BlackHoleCluster&amp;quot;,
  &amp;quot;connectTimeout&amp;quot;: &amp;quot;5.000s&amp;quot;
}]}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看 ads&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://$PILOT_SVC_IP:8080/debug/adsz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-envoy-基本术语回顾-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. Envoy 基本术语回顾&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;为了让大家更容易理解后面所讲的内容，先来回顾一下 Envoy 的基本术语。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Listener&lt;/span&gt; : 监听器（listener）是服务(程序)监听者，就是真正干活的。 它是可以由下游客户端连接的命名网络位置（例如，端口、unix域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。一般是每台主机运行一个 Envoy，使用单进程运行，但是每个进程中可以启动任意数量的 Listener（监听器），目前只监听 TCP，每个监听器都独立配置一定数量的（L3/L4）网络过滤器。Listenter 也可以通过 Listener Discovery Service（LDS）动态获取。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Listener filter&lt;/span&gt; : Listener 使用 listener filter（监听器过滤器）来操作链接的元数据。它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。Listener filter 的 API 相对简单，因为这些过滤器最终是在新接受的套接字上运行。在链中可以互相衔接以支持更复杂的场景，例如调用速率限制。Envoy 已经包含了多个监听器过滤器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Http Route Table&lt;/span&gt; : HTTP 的路由规则，例如请求的域名，Path 符合什么规则，转发给哪个 Cluster。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Cluster&lt;/span&gt; : 集群（cluster）是 Envoy 连接到的一组逻辑上相似的上游主机。Envoy 通过服务发现发现集群中的成员。Envoy 可以通过主动运行状况检查来确定集群成员的健康状况。Envoy 如何将请求路由到集群成员由负载均衡策略确定。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详细信息可以参考 &lt;a href=&#34;https://jimmysong.io/posts/envoy-archiecture-and-terminology/&#34; target=&#34;_blank&#34;&gt;Envoy 的架构与基本术语&lt;/a&gt;，本文重点突出 &lt;code&gt;Listener&lt;/code&gt;、&lt;code&gt;Route&lt;/code&gt; 和 &lt;code&gt;Cluster&lt;/code&gt; 这三个基本术语，同时需要注意流量经过这些术语的先后顺序，请求首先到达 &lt;code&gt;Listener&lt;/code&gt;，然后通过 &lt;code&gt;Http Route Table&lt;/code&gt; 转到具体的 &lt;code&gt;Cluster&lt;/code&gt;，最后由具体的 Cluster 对请求做出响应。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-gateway-和-virtualservice-配置解析-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. Gateway 和 VirtualService 配置解析&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;还是拿之前 &lt;a href=&#34;https://www.yangcs.net/posts/istio-traffic-management/&#34; target=&#34;_blank&#34;&gt;Istio 流量管理&lt;/a&gt; 这篇文章中的例子来解析吧，首先创建了一个 &lt;code&gt;Gateway&lt;/code&gt;，配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: bookinfo-gateway
spec:
  selector:
    istio: ingressgateway # use istio default controller
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后又创建了一个 &lt;code&gt;VirtualService&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: bookinfo
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
  - bookinfo-gateway
  http:
  - match:
    - uri:
        exact: /productpage
    - uri:
        exact: /login
    - uri:
        exact: /logout
    - uri:
        prefix: /api/v1/products
    route:
    - destination:
        host: productpage
        port:
          number: 9080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;VirtualService&lt;/code&gt; 映射的就是 Envoy 中的 &lt;code&gt;Http Route Table&lt;/code&gt;，大家可以注意到上面的 VirtualService 配置文件中有一个 &lt;code&gt;gateways&lt;/code&gt; 字段，如果有这个字段，就表示这个 Http Route Table 是绑在 &lt;code&gt;ingressgateway&lt;/code&gt; 的 &lt;code&gt;Listener&lt;/code&gt; 中的；如果没有这个字段，就表示这个 Http Route Table 是绑在 Istio 所管理的所有微服务应用的 Pod 上的。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;为了分清主次，我决定将本文拆分成两篇文章来讲解，本篇主要围绕 ingressgateway 来解析 Gateway 和 VirtualService，而微服务应用本身的 VirtualService 和 DestinationRule 解析放到下一篇文章再说。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;显而易见，上面这个 VirtualService 映射的 Http Route Table 是被绑在 ingressgateway 中的，可以通过 &lt;code&gt;istioctl&lt;/code&gt; 来查看，istioctl 的具体用法请参考：&lt;a href=&#34;https://istio.io/zh/help/ops/traffic-management/debugging-pilot-envoy/&#34; target=&#34;_blank&#34;&gt;调试 Envoy 和 Pilot&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;首先查看 &lt;code&gt;Listener&lt;/code&gt; 的配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl -n istio-system pc listeners istio-ingressgateway-b6db8c46f-qcfks --port 80 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;0.0.0.0_80&amp;quot;,
        &amp;quot;address&amp;quot;: {
            &amp;quot;socketAddress&amp;quot;: {
                &amp;quot;address&amp;quot;: &amp;quot;0.0.0.0&amp;quot;,
                &amp;quot;portValue&amp;quot;: 80
            }
        },
        &amp;quot;filterChains&amp;quot;: [
            {
                &amp;quot;filters&amp;quot;: [
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;envoy.http_connection_manager&amp;quot;,
                        &amp;quot;config&amp;quot;: {
                            ...
                            &amp;quot;rds&amp;quot;: {
                                &amp;quot;config_source&amp;quot;: {
                                    &amp;quot;ads&amp;quot;: {}
                                },
                                &amp;quot;route_config_name&amp;quot;: &amp;quot;http.80&amp;quot;
                            },
                            ...
                        }
                    }
                ]
            }
        ]
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 &lt;code&gt;rds&lt;/code&gt; 配置项的 &lt;code&gt;route_config_name&lt;/code&gt; 字段可以知道该 Listener 使用的 Http Route Table 的名字是 &lt;code&gt;http.80&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;查看 &lt;code&gt;Http Route Table&lt;/code&gt; 配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl -n istio-system pc routes istio-ingressgateway-b6db8c46f-qcfks --name http.80 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;http.80&amp;quot;,
        &amp;quot;virtualHosts&amp;quot;: [
            {
                &amp;quot;name&amp;quot;: &amp;quot;bookinfo:80&amp;quot;,
                &amp;quot;domains&amp;quot;: [
                    &amp;quot;*&amp;quot;
                ],
                &amp;quot;routes&amp;quot;: [
                    {
                        &amp;quot;match&amp;quot;: {
                            &amp;quot;path&amp;quot;: &amp;quot;/productpage&amp;quot;
                        },
                        &amp;quot;route&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|9080||productpage.default.svc.cluster.local&amp;quot;,
                            &amp;quot;timeout&amp;quot;: &amp;quot;0.000s&amp;quot;,
                            &amp;quot;maxGrpcTimeout&amp;quot;: &amp;quot;0.000s&amp;quot;
                        },
                        ...
                    },
                    ...
                    {
                        &amp;quot;match&amp;quot;: {
                            &amp;quot;prefix&amp;quot;: &amp;quot;/api/v1/products&amp;quot;
                        },
                        &amp;quot;route&amp;quot;: {
                            &amp;quot;cluster&amp;quot;: &amp;quot;outbound|9080||productpage.default.svc.cluster.local&amp;quot;,
                            &amp;quot;timeout&amp;quot;: &amp;quot;0.000s&amp;quot;,
                            &amp;quot;maxGrpcTimeout&amp;quot;: &amp;quot;0.000s&amp;quot;
                        },
                        ...
                    },
                    ...
                ]
            }
        ],
        &amp;quot;validateClusters&amp;quot;: false
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;VirtualService 中的 &lt;code&gt;hosts&lt;/code&gt; 字段对应 Http Route Table 中 &lt;code&gt;virtualHosts&lt;/code&gt; 配置项的 &lt;code&gt;domains&lt;/code&gt; 字段。这里表示可以使用任何域名来通过 ingressgateway 访问服务（也可以直接通过 IP 来访问）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;VirtualService 中的 &lt;code&gt;exact&lt;/code&gt; 字段对应 Http Route Table 中 &lt;code&gt;routes.match&lt;/code&gt; 配置项的 &lt;code&gt;path&lt;/code&gt; 字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;VirtualService 中的 &lt;code&gt;prefix&lt;/code&gt; 字段对应 Http Route Table 中 &lt;code&gt;routes.match&lt;/code&gt; 配置项的 &lt;code&gt;prefix&lt;/code&gt; 字段。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;VirtualService 中的 &lt;code&gt;route.destination&lt;/code&gt; 配置项对应 Http Route Table 中 &lt;code&gt;routes.route&lt;/code&gt; 配置项的 &lt;code&gt;cluster&lt;/code&gt; 字段。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于 Envoy 中的 HTTP 路由解析可以参考我之前的文章：&lt;a href=&#34;https://www.yangcs.net/posts/routing-basics/&#34; target=&#34;_blank&#34;&gt;HTTP 路由解析&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;查看 &lt;code&gt;Cluster&lt;/code&gt; 配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl -n istio-system pc clusters istio-ingressgateway-b6db8c46f-qcfks --fqdn productpage.default.svc.cluster.local --port 9080 -o json
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    {
        &amp;quot;name&amp;quot;: &amp;quot;outbound|9080||productpage.default.svc.cluster.local&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;EDS&amp;quot;,
        &amp;quot;edsClusterConfig&amp;quot;: {
            &amp;quot;edsConfig&amp;quot;: {
                &amp;quot;ads&amp;quot;: {}
            },
            &amp;quot;serviceName&amp;quot;: &amp;quot;outbound|9080||productpage.default.svc.cluster.local&amp;quot;
        },
        &amp;quot;connectTimeout&amp;quot;: &amp;quot;1.000s&amp;quot;,
        &amp;quot;circuitBreakers&amp;quot;: {
            &amp;quot;thresholds&amp;quot;: [
                {}
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，&lt;code&gt;Cluster&lt;/code&gt; 最终将集群外通过 ingressgateway 发起的请求转发给实际的 &lt;code&gt;endpoint&lt;/code&gt;，也就是 Kubernetes 集群中的 Service &lt;code&gt;productpage&lt;/code&gt; 下面的 Pod（由 serviceName 字段指定）。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;实际上 istioctl 正是通过 pilot 的 xds 接口来查看 Listener 、Route 和 Cluster 等信息的。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;好了，现在请求已经转交给 productpage 了，那么接下来这个请求将会如何走完整个旅程呢？请听下回分解！&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 参考&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kubernetes.org.cn/4379.html&#34; target=&#34;_blank&#34;&gt;Service Mesh深度学习系列（三）| istio源码分析之pilot-discovery模块分析（中）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/help/ops/traffic-management/debugging-pilot-envoy/&#34; target=&#34;_blank&#34;&gt;调试 Envoy 和 Pilot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/posts/envoy-archiecture-and-terminology/&#34; target=&#34;_blank&#34;&gt;Envoy 的架构与基本术语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes 资源管理概述</title>
      <link>https://www.yangcs.net/posts/kubernetes-resource-management/</link>
      <pubDate>Fri, 03 Aug 2018 17:34:19 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/kubernetes-resource-management/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p id=&#34;div-border-left-red&#34;&gt;本文转载自 &lt;a href=&#34;http://cizixs.com/2018/06/25/kubernetes-resource-management&#34; target=&#34;_blank&#34;&gt;Cizixs 的博客&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-什么是资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 什么是资源？&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;在 kubernetes 中，有两个基础但是非常重要的概念：node 和 pod。node 翻译成节点，是对集群资源的抽象；pod 是对容器的封装，是应用运行的实体。node 提供资源，而 pod 使用资源，这里的资源分为计算（cpu、memory、gpu）、存储（disk、ssd）、网络（network bandwidth、ip、ports）。这些资源提供了应用运行的基础，正确理解这些资源以及集群调度如何使用这些资源，对于大规模的 kubernetes 集群来说至关重要，不仅能保证应用的稳定性，也可以提高资源的利用率。&lt;/p&gt;

&lt;p&gt;在这篇文章，我们主要介绍 CPU 和内存这两个重要的资源，它们虽然都属于计算资源，但也有所差距。CPU 可分配的是使用时间，也就是操作系统管理的时间片，每个进程在一定的时间片里运行自己的任务（另外一种方式是绑核，也就是把 CPU 完全分配给某个 pod 使用，但这种方式不够灵活会造成严重的资源浪费，kubernetes 中并没有提供）；而对于内存，系统提供的是内存大小。&lt;/p&gt;

&lt;p&gt;CPU 的使用时间是可压缩的，换句话说它本身无状态，申请资源很快，也能快速正常回收；而内存大小是不可压缩的，因为它是有状态的（内存里面保存的数据），申请资源很慢（需要计算和分配内存块的空间），并且回收可能失败（被占用的内存一般不可回收）。&lt;/p&gt;

&lt;p&gt;把资源分成 &lt;span id=&#34;inline-blue&#34;&gt;可压缩&lt;/span&gt; 和 &lt;span id=&#34;inline-blue&#34;&gt;不可压缩&lt;/span&gt;，是因为在资源不足的时候，它们的表现很不一样。对于不可压缩资源，如果资源不足，也就无法继续申请资源（内存用完就是用完了），并且会导致 pod 的运行产生无法预测的错误（应用申请内存失败会导致一系列问题）；而对于可压缩资源，比如 CPU 时间片，即使 pod 使用的 CPU 资源很多，CPU 使用也可以按照权重分配给所有 pod 使用，虽然每个人使用的时间片减少，但不会影响程序的逻辑。&lt;/p&gt;

&lt;p&gt;在 kubernetes 集群管理中，有一个非常核心的功能：就是为 pod 选择一个主机运行。调度必须满足一定的条件，其中最基本的是主机上要有足够的资源给 pod 使用。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*PfGIiTw68JLIUyo0FQY2dA.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;资源除了和调度相关之外，还和很多事情紧密相连，这正是这篇文章要解释的。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-kubernetes-资源的表示-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. kubernetes 资源的表示&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;用户在 pod 中可以配置要使用的资源总量，kubernetes 根据配置的资源数进行调度和运行。目前主要可以配置的资源是 CPU 和 memory，对应的配置字段是 &lt;code&gt;spec.containers[].resource.limits/request.cpu/memory&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;需要注意的是，用户是对每个容器配置 request 值，所有容器的资源请求之和就是 pod 的资源请求总量，而我们一般会说 pod 的资源请求和 limits。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;limits&lt;/code&gt; 和 &lt;code&gt;requests&lt;/code&gt; 的区别我们下面会提到，这里先说说比较容易理解的 cpu 和 memory。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CPU&lt;/code&gt; 一般用核数来标识，一核CPU 相对于物理服务器的一个超线程核，也就是操作系统 &lt;code&gt;/proc/cpuinfo&lt;/code&gt; 中列出来的核数。因为对资源进行了池化和虚拟化，因此 kubernetes 允许配置非整数个的核数，比如 &lt;code&gt;0.5&lt;/code&gt; 是合法的，它标识应用可以使用半个 CPU 核的计算量。CPU 的请求有两种方式，一种是刚提到的 &lt;code&gt;0.5&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt; 这种直接用数字标识 CPU 核心数；另外一种表示是 &lt;code&gt;500m&lt;/code&gt;，它等价于 &lt;code&gt;0.5&lt;/code&gt;，也就是说 &lt;code&gt;1 Core = 1000m&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;内存比较容易理解，是通过字节大小指定的。如果直接一个数字，后面没有任何单位，表示这么多字节的内存；数字后面还可以跟着单位， 支持的单位有 &lt;code&gt;E&lt;/code&gt;、&lt;code&gt;P&lt;/code&gt;、&lt;code&gt;T&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;、&lt;code&gt;M&lt;/code&gt;、&lt;code&gt;K&lt;/code&gt;，前者分别是后者的 &lt;code&gt;1000&lt;/code&gt; 倍大小的关系，此外还支持 &lt;code&gt;Ei&lt;/code&gt;、&lt;code&gt;Pi&lt;/code&gt;、&lt;code&gt;Ti&lt;/code&gt;、&lt;code&gt;Gi&lt;/code&gt;、&lt;code&gt;Mi&lt;/code&gt;、&lt;code&gt;Ki&lt;/code&gt;，其对应的倍数关系是 &lt;code&gt;2^10 = 1024&lt;/code&gt;。比如要使用 100M 内存的话，直接写成 &lt;code&gt;100Mi&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-节点可用资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 节点可用资源&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;理想情况下，我们希望节点上所有的资源都可以分配给 pod 使用，但实际上节点上除了运行 pods 之外，还会运行其他的很多进程：系统相关的进程（比如 sshd、udev等），以及 kubernetes 集群的组件（kubelet、docker等）。我们在分配资源的时候，需要给这些进程预留一些资源，剩下的才能给 pod 使用。预留的资源可以通过下面的参数控制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi]&lt;/code&gt;：控制预留给 kubernetes 集群组件的 CPU、memory 和存储资源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--system-reserved=[cpu=100mi][,][memory=100Mi][,][ephemeral-storage=1Gi]&lt;/code&gt;：预留给系统的 CPU、memory 和存储资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两块预留之后的资源才是 pod 真正能使用的，不过考虑到 eviction 机制（下面的章节会提到），kubelet 会保证节点上的资源使用率不会真正到 100%，因此 pod 的实际可使用资源会稍微再少一点。主机上的资源逻辑分配图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://i.loli.net/2018/06/25/5b3106f947190.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;需要注意的是，allocatable 不是指当前机器上可以分配的资源，而是指能分配给 pod 使用的资源总量，一旦 kubelet 启动这个值是不会变化的。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;allocatable 的值可以在 node 对象的 status 字段中读取，比如下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;status:
  allocatable:
    cpu: &amp;quot;2&amp;quot;
    ephemeral-storage: &amp;quot;35730597829&amp;quot;
    hugepages-2Mi: &amp;quot;0&amp;quot;
    memory: 3779348Ki
    pods: &amp;quot;110&amp;quot;
  capacity:
    cpu: &amp;quot;2&amp;quot;
    ephemeral-storage: 38770180Ki
    hugepages-2Mi: &amp;quot;0&amp;quot;
    memory: 3881748Ki
    pods: &amp;quot;110&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-kubernetes-资源对象-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. kubernetes 资源对象&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;在这部分，我们来介绍 kubernetes 中提供的让我们管理 pod 资源的原生对象。&lt;/p&gt;

&lt;h4 id=&#34;请求-requests-和上限-limits&#34;&gt;请求（requests）和上限（limits）&lt;/h4&gt;

&lt;p&gt;前面说过用户在创建 pod 的时候，可以指定每个容器的 Requests 和 Limits 两个字段，下面是一个实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;resources:
  requests:
    memory: &amp;quot;64Mi&amp;quot;
    cpu: &amp;quot;250m&amp;quot;
  limits:
    memory: &amp;quot;128Mi&amp;quot;
    cpu: &amp;quot;500m&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Requests&lt;/code&gt; 是容器请求要使用的资源，kubernetes 会保证 pod 能使用到这么多的资源。请求的资源是调度的依据，只有当节点上的可用资源大于 pod 请求的各种资源时，调度器才会把 pod 调度到该节点上（如果 CPU 资源足够，内存资源不足，调度器也不会选择该节点）。&lt;/p&gt;

&lt;p&gt;需要注意的是，调度器只关心节点上可分配的资源，以及节点上所有 pods 请求的资源，而&lt;strong&gt;不关心&lt;/strong&gt;节点资源的实际使用情况，换句话说，如果节点上的 pods 申请的资源已经把节点上的资源用满，即使它们的使用率非常低，比如说 CPU 和内存使用率都低于 10%，调度器也不会继续调度 pod 上去。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Limits&lt;/code&gt; 是 pod 能使用的资源上限，是实际配置到内核 cgroups 里面的配置数据。对于内存来说，会直接转换成 &lt;code&gt;docker run&lt;/code&gt; 命令行的 &lt;code&gt;--memory&lt;/code&gt; 大小，最终会配置到 cgroups 对应任务的 &lt;code&gt;/sys/fs/cgroup/memory/……/memory.limit_in_bytes&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;如果 limit 没有配置，则表明没有资源的上限，只要节点上有对应的资源，pod 就可以使用。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;使用 requests 和 limits 概念，我们能分配更多的 pod，提升整体的资源使用率。但是这个体系有个非常重要的问题需要考虑，那就是&lt;strong&gt;怎么去准确地评估 pod 的资源 requests？&lt;/strong&gt;如果评估地过低，会导致应用不稳定；如果过高，则会导致使用率降低。这个问题需要开发者和系统管理员共同讨论和定义。&lt;/p&gt;

&lt;h4 id=&#34;limit-range-默认资源配置&#34;&gt;limit range（默认资源配置)&lt;/h4&gt;

&lt;p&gt;为每个 pod 都手动配置这些参数是挺麻烦的事情，kubernetes 提供了 &lt;code&gt;LimitRange&lt;/code&gt; 资源，可以让我们配置某个 namespace 默认的 request 和 limit 值，比如下面的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &amp;quot;v1&amp;quot;
kind: &amp;quot;LimitRange&amp;quot;
metadata:
  name: you-shall-have-limits
spec:
  limits:
    - type: &amp;quot;Container&amp;quot;
      max:
        cpu: &amp;quot;2&amp;quot;
        memory: &amp;quot;1Gi&amp;quot;
      min:
        cpu: &amp;quot;100m&amp;quot;
        memory: &amp;quot;4Mi&amp;quot;
      default:
        cpu: &amp;quot;500m&amp;quot;
        memory: &amp;quot;200Mi&amp;quot;
      defaultRequest:
        cpu: &amp;quot;200m&amp;quot;
        memory: &amp;quot;100Mi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对应 namespace 创建的 pod 没有写资源的 requests 和 limits 字段，那么它会自动拥有下面的配置信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内存请求是 100Mi，上限是 200Mi&lt;/li&gt;
&lt;li&gt;CPU 请求是 200m，上限是 500m&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，如果 pod 自己配置了对应的参数，kubernetes 会使用 pod 中的配置。使用 LimitRange 能够让 namespace 中的 pod 资源规范化，便于统一的资源管理。&lt;/p&gt;

&lt;h4 id=&#34;资源配额-resource-quota&#34;&gt;资源配额（resource quota）&lt;/h4&gt;

&lt;p&gt;前面讲到的资源管理和调度可以认为 kubernetes 把这个集群的资源整合起来，组成一个资源池，每个应用（pod）会自动从整个池中分配资源来使用。默认情况下只要集群还有可用的资源，应用就能使用，并没有限制。kubernetes 本身考虑到了多用户和多租户的场景，提出了 namespace 的概念来对集群做一个简单的隔离。&lt;/p&gt;

&lt;p&gt;基于 namespace，kubernetes 还能够对资源进行隔离和限制，这就是 resource quota 的概念，翻译成资源配额，它限制了某个 namespace 可以使用的资源总额度。这里的资源包括 cpu、memory 的总量，也包括 kubernetes 自身对象（比如 pod、services 等）的数量。通过 resource quota，kubernetes 可以防止某个 namespace 下的用户不加限制地使用超过期望的资源，比如说不对资源进行评估就大量申请 16核 CPU 32G内存的 pod。&lt;/p&gt;

&lt;p&gt;下面是一个资源配额的实例，它限制了 namespace 只能使用 20核 CPU 和 1G 内存，并且能创建 10 个 pod、20个 rc、5个 service，可能适用于某个测试场景。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota
spec:
  hard:
    cpu: &amp;quot;20&amp;quot;
    memory: 1Gi
    pods: &amp;quot;10&amp;quot;
    replicationcontrollers: &amp;quot;20&amp;quot;
    resourcequotas: &amp;quot;1&amp;quot;
    services: &amp;quot;5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;resource quota 能够配置的选项还很多，比如 GPU、存储、configmaps、persistentvolumeclaims 等等，更多信息可以参考官方的文档。&lt;/p&gt;

&lt;p&gt;Resource quota 要解决的问题和使用都相对独立和简单，但是它也有一个限制：那就是它不能根据集群资源动态伸缩。一旦配置之后，resource quota 就不会改变，即使集群增加了节点，整体资源增多也没有用。kubernetes 现在没有解决这个问题，但是用户可以通过编写一个 controller 的方式来自己实现。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-应用优先级-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 应用优先级&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;qos-服务质量&#34;&gt;QoS（服务质量）&lt;/h4&gt;

&lt;p&gt;Requests 和 limits 的配置除了表明资源情况和限制资源使用之外，还有一个隐藏的作用：它决定了 pod 的 QoS 等级。&lt;/p&gt;

&lt;p&gt;上一节我们提到了一个细节：如果 pod 没有配置 limits ，那么它可以使用节点上任意多的可用资源。这类 pod 能灵活使用资源，但这也导致它不稳定且危险，对于这类 pod 我们一定要在它占用过多资源导致节点资源紧张时处理掉。优先处理这类 pod，而不是资源使用处于自己请求范围内的 pod 是非常合理的想法，而这就是 pod QoS 的含义：根据 pod 的资源请求把 pod 分成不同的重要性等级。&lt;/p&gt;

&lt;p&gt;kubernetes 把 pod 分成了三个 QoS 等级：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Guaranteed&lt;/span&gt; ：优先级最高，可以考虑数据库应用或者一些重要的业务应用。除非 pods 使用超过了它们的 limits，或者节点的内存压力很大而且没有 QoS 更低的 pod，否则不会被杀死&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Burstable&lt;/span&gt; ：这种类型的 pod 可以多于自己请求的资源（上限有 limit 指定，如果 limit 没有配置，则可以使用主机的任意可用资源），但是重要性认为比较低，可以是一般性的应用或者批处理任务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Best Effort&lt;/span&gt; ：优先级最低，集群不知道 pod 的资源请求情况，调度不考虑资源，可以运行到任意节点上（从资源角度来说），可以是一些临时性的不重要应用。pod 可以使用节点上任何可用资源，但在资源不足时也会被优先杀死&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pod 的 requests 和 limits 是如何对应到这三个 QoS 等级上的，可以用下面一张表格概括：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://i.loli.net/2018/06/25/5b307f4bc7d42.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;看到这里，你也许看出来一个问题了：&lt;strong&gt;如果不配置 requests 和 limits，pod 的 QoS 竟然是最低的&lt;/strong&gt;。没错，所以推荐大家理解 QoS 的概念，并且按照需求&lt;strong&gt;一定要给 pod 配置 requests 和 limits 参数&lt;/strong&gt;，不仅可以让调度更准确，也能让系统更加稳定。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;按照现在的方法根据 pod 请求的资源进行配置不够灵活和直观，更理想的情况是用户可以直接配置 pod 的 QoS，而不用关心具体的资源申请和上限值。但 kubernetes 目前还没有这方面的打算。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Pod 的 QoS 还决定了容器的 OOM（out-of-memory）值，它们对应的关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/06/25/5b307a5b3557c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，QoS 越高的 pod oom 值越低，也就越不容易被系统杀死。对于 Bustable pod，它的值是根据 request 和节点内存总量共同决定的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;oomScoreAdjust := 1000 - (1000*memoryRequest)/memoryCapacity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;memoryRequest&lt;/code&gt; 是 pod 申请的资源，&lt;code&gt;memoryCapacity&lt;/code&gt; 是节点的内存总量。可以看到，申请的内存越多，oom 值越低，也就越不容易被杀死。&lt;/p&gt;

&lt;p&gt;QoS 的作用会在后面介绍 eviction 的时候详细讲解。&lt;/p&gt;

&lt;h4 id=&#34;pod-优先级-priority&#34;&gt;Pod 优先级（priority）&lt;/h4&gt;

&lt;p&gt;除了 QoS，kubernetes 还允许我们自定义 pod 的优先级，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: scheduling.k8s.io/v1alpha1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: &amp;quot;This priority class should be used for XYZ service pods only.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优先级的使用也比较简单，只需要在 &lt;code&gt;pod.spec.PriorityClassName&lt;/code&gt; 指定要使用的优先级名字，即可以设置当前 pod 的优先级为对应的值。&lt;/p&gt;

&lt;p&gt;Pod 的优先级在调度的时候会使用到。首先，待调度的 pod 都在同一个队列中，启用了 pod priority 之后，调度器会根据优先级的大小，把优先级高的 pod 放在前面，提前调度。&lt;/p&gt;

&lt;p&gt;另外，如果在调度的时候，发现某个 pod 因为资源不足无法找到合适的节点，调度器会尝试 preempt 的逻辑。 简单来说，调度器会试图找到这样一个节点：找到它上面优先级低于当前要调度 pod 的所有 pod，如果杀死它们，能腾足够的资源，调度器会执行删除操作，把 pod 调度到节点上。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-6-驱逐-eviction-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;6. 驱逐（Eviction）&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;至此，我们讲述的都是理想情况下 kubernetes 的工作状况，我们假设资源完全够用，而且应用也都是在使用规定范围内的资源。&lt;/p&gt;

&lt;p&gt;但现实不会如此简单，在管理集群的时候我们常常会遇到资源不足的情况，在这种情况下我们要&lt;strong&gt;保证整个集群可用&lt;/strong&gt;，并且尽可能&lt;strong&gt;减少应用的损失&lt;/strong&gt;。保证集群可用比较容易理解，首先要保证系统层面的核心进程正常，其次要保证 kubernetes 本身组件进程不出问题；但是如果量化应用的损失呢？首先能想到的是如果要杀死 pod，要尽量减少总数。另外一个就和 pod 的优先级相关了，那就是尽量杀死不那么重要的应用，让重要的应用不受影响。&lt;/p&gt;

&lt;p&gt;Pod 的驱逐是在 kubelet 中实现的，因为 kubelet 能动态地感知到节点上资源使用率实时的变化情况。其核心的逻辑是：kubelet 实时监控节点上各种资源的使用情况，一旦发现某个不可压缩资源出现要耗尽的情况，就会主动终止节点上的 pod，让节点能够正常运行。被终止的 pod 所有容器会停止，状态会被设置为 failed。&lt;/p&gt;

&lt;h4 id=&#34;驱逐触发条件&#34;&gt;驱逐触发条件&lt;/h4&gt;

&lt;p&gt;那么哪些资源不足会导致 kubelet 执行驱逐程序呢？目前主要有三种情况：实际内存不足、节点文件系统的可用空间（文件系统剩余大小和 inode 数量）不足、以及镜像文件系统的可用空间（包括文件系统剩余大小和 inode 数量）不足。&lt;/p&gt;

&lt;p&gt;下面这图是具体的触发条件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/06/24/5b2f1a966a703.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有了数据的来源，另外一个问题是触发的时机，也就是到什么程度需要触发驱逐程序？kubernetes 运行用户自己配置，并且支持两种模式：按照百分比和按照绝对数量。比如对于一个 32G 内存的节点当可用内存少于 10% 时启动驱逐程序，可以配置 &lt;code&gt;memory.available&amp;lt;10%&lt;/code&gt; 或者 &lt;code&gt;memory.available&amp;lt;3.2Gi&lt;/code&gt;。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;默认情况下，kubelet 的驱逐规则是 &lt;code&gt;memory.available&lt;100Mi&lt;/code&gt;，对于生产环境这个配置是不可接受的，所以一定要根据实际情况进行修改。&lt;/p&gt;
&lt;/div&gt;

&lt;h4 id=&#34;软驱逐-soft-eviction-和硬驱逐-hard-eviction&#34;&gt;软驱逐（soft eviction）和硬驱逐（hard eviction）&lt;/h4&gt;

&lt;p&gt;因为驱逐 pod 是具有毁坏性的行为，因此必须要谨慎。有时候内存使用率增高只是暂时性的，有可能 20s 内就能恢复，这时候启动驱逐程序意义不大，而且可能会导致应用的不稳定，我们要考虑到这种情况应该如何处理；另外需要注意的是，如果内存使用率过高，比如高于 95%（或者 90%，取决于主机内存大小和应用对稳定性的要求），那么我们不应该再多做评估和考虑，而是赶紧启动驱逐程序，因为这种情况再花费时间去判断可能会导致内存继续增长，系统完全崩溃。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，kubernetes 引入了 soft eviction 和 hard eviction 的概念。&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;软驱逐&lt;/span&gt; 可以在资源紧缺情况并没有哪些严重的时候触发，比如内存使用率为 85%，软驱逐还需要配置一个时间指定软驱逐条件持续多久才触发，也就是说 kubelet 在发现资源使用率达到设定的阈值之后，并不会立即触发驱逐程序，而是继续观察一段时间，如果资源使用率高于阈值的情况持续一定时间，才开始驱逐。并且驱逐 pod 的时候，会遵循 grace period ，等待 pod 处理完清理逻辑。和软驱逐相关的启动参数是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--eviction-soft&lt;/code&gt;：软驱逐触发条件，比如 &lt;code&gt;memory.available&amp;lt;1Gi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--eviction-sfot-grace-period&lt;/code&gt;：触发条件持续多久才开始驱逐，比如 memory.available=2m30s&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--eviction-max-pod-grace-period&lt;/code&gt;：kill pod 时等待 grace period 的时间让 pod 做一些清理工作，如果到时间还没有结束就做 kill&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面两个参数必须同时配置，软驱逐才能正常工作；后一个参数会和 pod 本身配置的 grace period 比较，选择较小的一个生效。&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;硬驱逐&lt;/span&gt; 更加直接干脆，kubelet 发现节点达到配置的硬驱逐阈值后，立即开始驱逐程序，并且不会遵循 grace period，也就是说立即强制杀死 pod。对应的配置参数只有一个 &lt;code&gt;--evictio-hard&lt;/code&gt;，可以选择上面表格中的任意条件搭配。&lt;/p&gt;

&lt;p&gt;设置这两种驱逐程序是为了平衡节点稳定性和对 pod 的影响，软驱逐照顾到了 pod 的优雅退出，减少驱逐对 pod 的影响；而硬驱逐则照顾到节点的稳定性，防止资源的快速消耗导致节点不可用。&lt;/p&gt;

&lt;p&gt;软驱逐和硬驱逐可以单独配置，不过还是推荐两者都进行配置，一起使用。&lt;/p&gt;

&lt;h4 id=&#34;驱逐哪些-pods&#34;&gt;驱逐哪些 pods？&lt;/h4&gt;

&lt;p&gt;上面我们已经整体介绍了 kubelet 驱逐 pod 的逻辑和过程，那这里就牵涉到一个具体的问题：&lt;strong&gt;要驱逐哪些 pod？&lt;/strong&gt;驱逐的重要原则是尽量减少对应用程序的影响。&lt;/p&gt;

&lt;p&gt;如果是存储资源不足，kubelet 会根据情况清理状态为 Dead 的 pod 和它的所有容器，以及清理所有没有使用的镜像。如果上述清理并没有让节点回归正常，kubelet 就开始清理 pod。&lt;/p&gt;

&lt;p&gt;一个节点上会运行多个 pod，驱逐所有的 pods 显然是不必要的，因此要做出一个抉择：在节点上运行的所有 pod 中选择一部分来驱逐。虽然这些 pod 乍看起来没有区别，但是它们的地位是不一样的，正如乔治·奥威尔在《动物庄园》的那句话：&lt;/p&gt;

&lt;p id=&#34;div-border-left-purple&#34;&gt;所有动物生而平等，但有些动物比其他动物更平等。&lt;/p&gt;

&lt;p&gt;Pod 也是不平等的，有些 pod 要比其他 pod 更重要。只管来说，系统组件的 pod 要比普通的 pod 更重要，另外运行数据库的 pod 自然要比运行一个无状态应用的 pod 更重要。kubernetes 又是怎么决定 pod 的优先级的呢？这个问题的答案就藏在我们之前已经介绍过的内容里：pod requests 和 limits、优先级（priority），以及 pod 实际的资源使用。&lt;/p&gt;

&lt;p&gt;简单来说，kubelet 会根据以下内容对 pod 进行排序：pod 是否使用了超过请求的紧张资源、pod 的优先级、然后是使用的紧缺资源和请求的紧张资源之间的比例。具体来说，kubelet 会按照如下的顺序驱逐 pod：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用的紧张资源超过请求数量的 &lt;code&gt;BestEffort&lt;/code&gt; 和 &lt;code&gt;Burstable pod&lt;/code&gt;，这些 pod 内部又会按照优先级和使用比例进行排序&lt;/li&gt;
&lt;li&gt;紧张资源使用量低于 requests 的 &lt;code&gt;Burstable&lt;/code&gt; 和 &lt;code&gt;Guaranteed&lt;/code&gt; 的 pod 后面才会驱逐，只有当系统组件（kubelet、docker、journald 等）内存不够，并且没有上面 QoS 比较低的 pod 时才会做。执行的时候还会根据 priority 排序，优先选择优先级低的 pod&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;防止波动&#34;&gt;防止波动&lt;/h4&gt;

&lt;p&gt;这里的波动有两种情况，我们先说说第一种。驱逐条件出发后，如果 kubelet 驱逐一部分 pod，让资源使用率低于阈值就停止，那么很可能过一段时间资源使用率又会达到阈值，从而再次出发驱逐，如此循环往复……为了处理这种问题，我们可以使用 &lt;code&gt;--eviction-minimum-reclaim&lt;/code&gt; 解决，这个参数配置每次驱逐至少清理出来多少资源才会停止。&lt;/p&gt;

&lt;p&gt;另外一个波动情况是这样的：Pod 被驱逐之后并不会从此消失不见，常见的情况是 kubernetes 会自动生成一个新的 pod 来取代，并经过调度选择一个节点继续运行。如果不做额外处理，有理由相信 pod 选择原来节点的可能性比较大（因为调度逻辑没变，而它上次调度选择的就是该节点），之所以说可能而不是绝对会再次选择该节点，是因为集群 pod 的运行和分布和上次调度时极有可能发生了变化。&lt;/p&gt;

&lt;p&gt;无论如何，如果被驱逐的 pod 再次调度到原来的节点，很可能会再次触发驱逐程序，然后 pod 再次被调度到当前节点，循环往复…… 这种事情当然是我们不愿意看到的，虽然看似复杂，但这个问题解决起来非常简单：驱逐发生后，kubelet 更新节点状态，调度器感知到这一情况，暂时不往该节点调度 pod 即可。&lt;code&gt;--eviction-pressure-transition-period&lt;/code&gt; 参数可以指定 kubelet 多久才上报节点的状态，因为默认的上报状态周期比较短，频繁更改节点状态会导致驱逐波动。&lt;/p&gt;

&lt;p&gt;做一个总结，下面是一个使用了上面多种参数的驱逐配置实例（你应该能看懂它们是什么意思了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;–-eviction-soft=memory.available&amp;lt;80%,nodefs.available&amp;lt;2Gi \
–-eviction-soft-grace-period=memory.available=1m30s,nodefs.available=1m30s \
–-eviction-max-pod-grace-period=120 \
–-eviction-hard=memory.available&amp;lt;500Mi,nodefs.available&amp;lt;1Gi \
–-eviction-pressure-transition-period=30s \
--eviction-minimum-reclaim=&amp;quot;memory.available=0Mi,nodefs.available=500Mi,imagefs.available=2Gi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-7-碎片整理和重调度-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;7. 碎片整理和重调度&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Kubernetes 的调度器在为 pod 选择运行节点的时候，只会考虑到调度那个时间点集群的状态，经过一系列的算法选择一个&lt;strong&gt;当时最合适&lt;/strong&gt;的节点。但是集群的状态是不断变化的，用户创建的 pod 也是动态的，随着时间变化，原来调度到某个节点上的 pod 现在看来可能有更好的节点可以选择。比如考虑到下面这些情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调度 pod 的条件已经不再满足，比如节点的 taints 和 labels 发生了变化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新节点加入了集群。如果默认配置了把 pod 打散，那么应该有一些 pod 最好运行在新节点上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点的使用率不均匀。调度后，有些节点的分配率和使用率比较高，另外一些比较低&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点上有资源碎片。有些节点调度之后还剩余部分资源，但是又低于任何 pod 的请求资源；或者 memory 资源已经用完，但是 CPU 还有挺多没有使用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想要解决上述的这些问题，都需要把 pod 重新进行调度（把 pod 从当前节点移动到另外一个节点）。但是默认情况下，一旦 pod 被调度到节点上，除非给杀死否则不会移动到另外一个节点的。&lt;/p&gt;

&lt;p&gt;为此 kubernetes 社区孵化了一个称为 &lt;a href=&#34;https://github.com/kubernetes-incubator/descheduler&#34; target=&#34;_blank&#34;&gt;descheduler&lt;/a&gt; 的项目，专门用来做重调度。重调度的逻辑很简单：找到上面几种情况中已经不是最优的 pod，把它们驱逐掉（eviction）。&lt;/p&gt;

&lt;p&gt;目前，descheduler 不会决定驱逐的 pod 应该调度到哪台机器，而是&lt;strong&gt;假定默认的调度器会做出正确的调度抉择&lt;/strong&gt;。也就是说，之所以 pod 目前不合适，不是因为调度器的算法有问题，而是因为集群的情况发生了变化。如果让调度器重新选择，调度器现在会把 pod 放到合适的节点上。这种做法让 descheduler 逻辑比较简单，而且避免了调度逻辑出现在两个组件中。&lt;/p&gt;

&lt;p&gt;Descheduler 执行的逻辑是可以配置的，目前有几种场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RemoveDuplicates&lt;/code&gt;：RS、deployment 中的 pod 不能同时出现在一台机器上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LowNodeUtilization&lt;/code&gt;：找到资源使用率比较低的 node，然后驱逐其他资源使用率比较高节点上的 pod，期望调度器能够重新调度让资源更均衡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RemovePodsViolatingInterPodAntiAffinity&lt;/code&gt;：找到已经违反 Pod Anti Affinity 规则的 pods 进行驱逐，可能是因为反亲和是后面加上去的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RemovePodsViolatingNodeAffinity&lt;/code&gt;：找到违反 Node Affinity 规则的 pods 进行驱逐，可能是因为 node 后面修改了 label&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，为了保证应用的稳定性，descheduler 并不会随意地驱逐 pod，还是会尊重 pod 运行的规则，包括 pod 的优先级（不会驱逐 Critical pod，并且按照优先级顺序进行驱逐）和 PDB（如果违反了 PDB，则不会进行驱逐），并且不会驱逐没有 deployment、rs、jobs 的 pod 不会驱逐，daemonset pod 不会驱逐，有 local storage 的 pod 也不会驱逐。&lt;/p&gt;

&lt;p&gt;Descheduler 不是一个常驻的任务，每次执行完之后会退出，因此推荐使用 CronJob 来运行。&lt;/p&gt;

&lt;p&gt;总的来说，descheduler 是对原生调度器的补充，用来解决原生调度器的调度决策随着时间会变得失效，或者不够优化的缺陷。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-8-资源动态调整-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;8. 资源动态调整&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;动态调整的思路：应用的实际流量会不断变化，因此使用率也是不断变化的，为了应对应用流量的变化，我们应用能够自动调整应用的资源。比如在线商品应用在促销的时候访问量会增加，我们应该自动增加 pod 运算能力来应对；当促销结束后，有需要自动降低 pod 的运算能力防止浪费。&lt;/p&gt;

&lt;p&gt;运算能力的增减有两种方式：改变单个 pod 的资源，已经增减 pod 的数量。这两种方式对应了 kubernetes 的 HPA 和 VPA。&lt;/p&gt;

&lt;h4 id=&#34;horizontal-pod-autoscaling-横向-pod-自动扩展&#34;&gt;Horizontal Pod AutoScaling（横向 Pod 自动扩展）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/2018/02/autoscaler_kubernetes.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;横向 pod 自动扩展的思路是这样的：kubernetes 会运行一个 controller，周期性地监听 pod 的资源使用情况，当高于设定的阈值时，会自动增加 pod 的数量；当低于某个阈值时，会自动减少 pod 的数量。自然，这里的阈值以及 pod 的上限和下限的数量都是需要用户配置的。&lt;/p&gt;

&lt;p&gt;上面这句话隐藏了一个重要的信息：HPA 只能和 RC、deployment、RS 这些可以动态修改 replicas 的对象一起使用，而无法用于单个 pod、daemonset（因为它控制的 pod 数量不能随便修改）等对象。&lt;/p&gt;

&lt;p&gt;目前官方的监控数据来源是 metrics server 项目，可以配置的资源只有 CPU，但是用户可以使用自定义的监控数据（比如 prometheus），其他资源（比如 memory）的 HPA 支持也已经在路上了。&lt;/p&gt;

&lt;h4 id=&#34;vertical-pod-autoscaling&#34;&gt;Vertical Pod AutoScaling&lt;/h4&gt;

&lt;p&gt;和 HPA 的思路相似，只不过 VPA 调整的是单个 pod 的 request 值（包括 CPU 和 memory）。VPA 包括三个组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Recommander&lt;/code&gt;：消费 metrics server 或者其他监控组件的数据，然后计算 pod 的资源推荐值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Updater&lt;/code&gt;：找到被 vpa 接管的 pod 中和计算出来的推荐值差距过大的，对其做 update 操作（目前是 evict，新建的 pod 在下面 admission controller 中会使用推荐的资源值作为 request）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Admission Controller&lt;/code&gt;：新建的 pod 会经过该 Admission Controller，如果 pod 是被 vpa 接管的，会使用 recommander 计算出来的推荐值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，这三个组件的功能是互相补充的，共同实现了动态修改 pod 请求资源的功能。相对于 HPA，目前 VPA 还处于 alpha，并且还没有合并到官方的 kubernetes release 中，后续的接口和功能很可能会发生变化。&lt;/p&gt;

&lt;h4 id=&#34;cluster-auto-scaler&#34;&gt;Cluster Auto Scaler&lt;/h4&gt;

&lt;p&gt;随着业务的发展，应用会逐渐增多，每个应用使用的资源也会增加，总会出现集群资源不足的情况。为了动态地应对这一状况，我们还需要 CLuster Auto Scaler，能够根据整个集群的资源使用情况来增减节点。&lt;/p&gt;

&lt;p&gt;对于公有云来说，Cluster Auto Scaler 就是监控这个集群因为资源不足而 pending 的 pod，根据用户配置的阈值调用公有云的接口来申请创建机器或者销毁机器。对于私有云，则需要对接内部的管理平台。&lt;/p&gt;

&lt;p&gt;目前 HPA 和 VPA 不兼容，只能选择一个使用，否则两者会相互干扰。而且 VPA 的调整需要重启 pod，这是因为 pod 资源的修改是比较大的变化，需要重新走一下 apiserver、调度的流程，保证整个系统没有问题。目前社区也有计划在做原地升级，也就是说不通过杀死 pod 再调度新 pod 的方式，而是直接修改原有 pod 来更新。&lt;/p&gt;

&lt;p&gt;理论上 HPA 和 VPA 是可以共同工作的，HPA 负责瓶颈资源，VPA 负责其他资源。比如对于 CPU 密集型的应用，使用 HPA 监听 CPU 使用率来调整 pods 个数，然后用 VPA 监听其他资源（memory、IO）来动态扩展这些资源的 request 大小即可。当然这只是理想情况。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-9-总结-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;9. 总结&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;从前面介绍的各种 kubernetes 调度和资源管理方案可以看出来，提高应用的资源使用率、保证应用的正常运行、维护调度和集群的公平性是件非常复杂的事情，kubernetes 并没有完美的方法，而是对各种可能的问题不断提出一些针对性的方案。&lt;/p&gt;

&lt;p&gt;集群的资源使用并不是静态的，而是随着时间不断变化的，目前 kubernetes 的调度决策都是基于调度时集群的一个静态资源切片进行的，动态地资源调整是通过 kubelet 的驱逐程序进行的，HPA 和 VPA 等方案也不断提出，相信后面会不断完善这方面的功能，让 kubernetes 更加智能。&lt;/p&gt;

&lt;p&gt;资源管理和调度、应用优先级、监控、镜像中心等很多东西相关，是个非常复杂的领域。在具体的实施和操作的过程中，常常要考虑到企业内部的具体情况和需求，做出针对性的调整，并且需要开发者、系统管理员、SRE、监控团队等不同小组一起合作。但是这种付出从整体来看是值得的，提升资源的利用率能有效地节约企业的成本，也能让应用更好地发挥出作用。&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Vistio—使用 Netflix 的 Vizceral 可视化 Istio service mesh</title>
      <link>https://www.yangcs.net/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/</link>
      <pubDate>Fri, 03 Aug 2018 15:29:37 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p id=&#34;div-border-left-red&#34;&gt;本文转载自 &lt;a href=&#34;https://jimmysong.io/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/&#34; target=&#34;_blank&#34;&gt;Jimmy Song 的博客&lt;/a&gt;，并且有很多改动。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/vizceral&#34; target=&#34;_blank&#34;&gt;Vizceral&lt;/a&gt; 是 &lt;code&gt;Netflix&lt;/code&gt; 发布的一个开源项目，用于近乎实时地监控应用程序和集群之间的网络流量。&lt;a href=&#34;https://github.com/nmnellis/vistio&#34; target=&#34;_blank&#34;&gt;Vistio&lt;/a&gt; 是使用 Vizceral 对 Istio 和网格监控的改进。它利用 &lt;code&gt;Istio Mixer&lt;/code&gt; 生成的指标，然后将其输入 Prometheus。Vistio 查询 &lt;code&gt;Prometheus&lt;/code&gt; 并将数据存储在本地以允许重播流量。关于 Vizceral 可以参考这篇文章：&lt;a href=&#34;https://medium.com/netflix-techblog/vizceral-open-source-acc0c32113fe&#34; target=&#34;_blank&#34;&gt;Vizceral Open Source&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/YJqKg8M5xnNlqYtNr5Jsmw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vizceral 有两个可视化级别，全局可视化和集群级别可视化。在全局范围内（如上所示），您可以通过 Istio Ingress Gateway 等入口点将从 Internet 到 Istio 服务网格网络的网络流量可视化，或者您可以在 Istio 服务网格网络中显示总网络流量。&lt;/p&gt;

&lt;p&gt;在集群级别（如下所示），您可以可视化内部网格的流量。通过设置警告和错误级别警报，当应用程序出现问题时可以被快速检测出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-mesh1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-在-istio-服务网格中安装-vistio-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 在 Istio 服务网格中安装 Vistio&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;依赖&#34;&gt;依赖&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;Istio 1.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;假设&#34;&gt;假设&lt;/h4&gt;

&lt;p&gt;以下 Demo 使得这些假设更容易部署。如果您的环境设置不同，则可能需要将代码下载到本地并编辑一些文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Prometheus 部署在 &lt;code&gt;istio-system&lt;/code&gt; namespace 下，可以通过 &lt;code&gt;http://prometheus.istio-system:9090&lt;/code&gt; 地址访问&lt;/li&gt;
&lt;li&gt;Istio mixer 启用了 &lt;code&gt;istio_request_count metric&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Kubernetes 集群包含有 &lt;code&gt;standard StorageClass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为了便于部署已安装了 Helm（可选）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;由于测试环境大多数都没有外部网络存储，无法创建 StorageClass，待会儿我们可以将这部分的配置修改为 &lt;code&gt;hostPath&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;

&lt;p&gt;如果您还尚未部署服务网格，可以按照此 &lt;a href=&#34;https://istio.io/docs/guides/bookinfo/&#34; target=&#34;_blank&#34;&gt;Istio Bookinfo Demo&lt;/a&gt; 中的说明部署 Istio 及其示例应用程序。您需要能够在应用程序之间生成流量。要测试指标是否从 Mixer 正确发送到 Prometheus，您可以打开 Prometheus 查询 &lt;code&gt;istio_request_bytes_count&lt;/code&gt;，应该会看到多个条目。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-prometheus.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-部署-vistio-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 部署 Vistio&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;您可以选择通过 &lt;code&gt;kubectl&lt;/code&gt; 或者 &lt;code&gt;Helm&lt;/code&gt; 来部署 Vistio，下面会主要介绍 Helm 部署方式。有些变量可能需要根据您自己的环境来修改。&lt;/p&gt;

&lt;p&gt;如果你想通过 Helm 部署 Vistio，你将需要在 GitHub 上下载项目来获取 Helm 模板。此外，如果上述假设之一不符合您的需求（例如 prometheus url 不同），则应手动编辑文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/nmnellis/vistio.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;使用-helm-部署&#34;&gt;使用 Helm 部署&lt;/h4&gt;

&lt;p&gt;由于我们使用的是 Istio 1.0 版本，而 Vistio 已经有相当一段时间没有更新了，很多配置项已经不适用了，需要改动很多地方。&lt;/p&gt;

&lt;p&gt;切换到 Vistio 项目的根目录，修改 &lt;code&gt;values-with-ingress.yaml&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim helm/vistio/values-with-ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;vistioConfig:
  graphName: Vistio
  globalLevel:
    maxVolume: 2000000
    clusterConnections:
      # Total requests per second coming into the ingress controller from internet
      # 将 istio_request_count 修改为 istio_request_bytes_count
      # 将 destination_service=&amp;quot;istio-ingressgateway.istio-system.svc.cluster.local&amp;quot; 修改为 source_workload=&amp;quot;istio-ingressgateway&amp;quot;
      - query: sum(rate(istio_request_bytes_count{source_workload=&amp;quot;istio-ingressgateway&amp;quot;}[1m])) by (response_code)
        prometheusURL: http://prometheus.istio-system:9090
        ...
  clusterLevel:
    # Cluster name must match &#39;target&#39; name in global
    - cluster: istio-mesh
      maxVolume: 3000
      serviceConnections:
      # 将 istio_request_count 修改为 istio_request_bytes_count
      # 将 source_service 修改为 source_app
        - query: sum(rate(istio_request_bytes_count[1m])) by (source_app,destination_service,response_code)
          prometheusURL: http://prometheus.istio-system:9090
          source:
            # 将 source_service 修改为 source_app
            label: source_app
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 &lt;code&gt;values.yaml&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim helm/vistio/values.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;...
######################################
## Vistio-web
######################################
web:
  env:
    # Vistio-web 需要调用 Vistio-api 的 url，而且这个 url 必须是通过浏览器可以访问的，所以可以使用 ingress，后面将会创建
    updateURL: &amp;quot;http://vistio-api.istio.io/graph&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 &lt;code&gt;statefulset.yaml&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim helm/vistio/templates/statefulset.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: vistio-api
  ...
spec:
  replicas: {{ .Values.api.replicaCount }}
  serviceName: vistio
  template:
    metadata:
    ...
    spec:
      volumes:
        - name: config
          configMap:
            name: vistio-api-config
        # 添加 volume vistio-db
        - name: vistio-db
          hostPath:
            path: /data/vistio
  # 将 volumeClaimTemplates 配置项注释或删除
  #volumeClaimTemplates:
  #- metadata:
  #    annotations:
  #      volume.beta.kubernetes.io/storage-class: {{ .Values.api.storage.class }}
  #    name: vistio-db
  #  spec:
  #    accessModes:
  #    - ReadWriteOnce
  #    resources:
  #      requests:
  #        storage: {{ .Values.api.storage.size }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;同时你需要在运行 vistio-api 的节点上提前创建 &lt;code&gt;/data/vistio&lt;/code&gt; 目录。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;运行 &lt;code&gt;helm install&lt;/code&gt; 部署 Vistio。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm install helm/vistio -f helm/vistio/values-with-ingress.yaml --name vistio --namespace default
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pod

vistio-api-0                      1/1       Running   0          2m
vistio-web-5c44b7f76d-hmjdc       1/1       Running   0          2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-验证和暴露-vistio-web-api-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 验证和暴露 Vistio Web/API&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;暴露-vistio-web-api&#34;&gt;暴露 Vistio Web/API&lt;/h4&gt;

&lt;p&gt;为 Service vistio-api 和 vistio-web 创建 &lt;code&gt;Ingress&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat ingress.yaml

---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: vistio-web
  namespace: default
spec:
  rules:
  - host: vistio-web.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: vistio-web
          servicePort: 8080
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: vistio-api
  namespace: default
spec:
  rules:
  - host: vistio-api.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: vistio-api
          servicePort: 9091
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl create -f ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你的本地电脑上添加两条 hosts：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$Ingree_host vistio-web.istio.io
$Ingree_host vistio-api.istio.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 &lt;code&gt;$Ingree_host&lt;/code&gt; 替换为 Ingress Controller 运行节点的 IP。&lt;/p&gt;

&lt;h4 id=&#34;验证-visito-api&#34;&gt;验证 visito-api&lt;/h4&gt;

&lt;p&gt;vistio-web 调用 vistio-api 来渲染服务网格。访问 &lt;code&gt;http://vistio-api.istio.io/graph&lt;/code&gt; 您应该会看到类似下列的输出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/LkvzHsN0VzZSOD_wy7sCgQ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;访问-vistio&#34;&gt;访问 Vistio&lt;/h4&gt;

&lt;p&gt;如果一切都已经启动并准备就绪，您就可以访问 Vistio UI，开始探索服务网格网络，访问&lt;code&gt;http://vistio-web.istio.io&lt;/code&gt; 您将会看到类似下图的输出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-web.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-探索-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 探索&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;在全局范围内，您将看到Istio网格内所有请求的总和，如果你点击 &lt;code&gt;istio-mesh&lt;/code&gt; 气泡，就能查看你的网状网络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-mesh1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在你的 Istio 网格中，您可以使用许多可视化工具来帮助您查明故障的应用程序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WM6lx-4bms7YBO-EHs_a2g.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用屏幕右上方的过滤器可以快速过滤出错误率较高的应用程序。通过高级配置，当错误率超过特定值时，也可以触发警报。警报将显示给定应用程序的当前错误率趋势。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-问题排查-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 问题排查&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;访问 &lt;code&gt;http://vistio-api.istio.io/graph&lt;/code&gt;，如果你从 vistio-api 中看到以下输出，表示某些功能无法正常工作。正确的输出显示在教程上面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/TcFuNvCvk5C53rO4vXLkw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;检查 vistio-api 日志中是否有错误——在大多数情况下，vistio-api 将记录与 Prometheus 通信时遇到的任何问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl logs -f $(kubectl get pod -l app=vistio-api -o go-template=&#39;{{range .items}}{{.metadata.name}}{{end}}&#39;) -c vistio-api
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;验证 Prometheus 查询——vistio-api 使用以下查询检索其数据。您应该确保 Prometheus 内部的数据都存在。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Global Level Query
sum(rate(istio_request_bytes_count{source_workload=&amp;quot;istio-ingressgateway&amp;quot;}[1m])) by (response_code)
# Cluster Level Query
sum(rate(istio_request_bytes_count[1m])) by (source_app,destination_service,response_code)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交 Issue——如果遇到问题无法解决请提交 Issue：&lt;a href=&#34;https://github.com/nmnellis/vistio/issues&#34; target=&#34;_blank&#34;&gt;https://github.com/nmnellis/vistio/issues&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Istio 服务网格中的网关</title>
      <link>https://www.yangcs.net/posts/istio-ingress/</link>
      <pubDate>Thu, 02 Aug 2018 13:29:08 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/istio-ingress/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在一个典型的网格中，通常有一个或多个用于终结外部 TLS 链接，将流量引入网格的负载均衡器（我们称之为 gateway）。 然后流量通过边车网关（sidecar gateway）流经内部服务。 应用程序使用外部服务的情况也很常见（例如访问 Google Maps API），一些情况下，这些外部服务可能被直接调用；但在某些部署中，网格中所有访问外部服务的流量可能被要求强制通过专用的出口网关（Egress gateway）。 下图描绘了网关在网格中的使用情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/blog/2018/v1alpha3-routing/gateways.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;Istio服务网格中的网关&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code&gt;Gateway&lt;/code&gt; 是一个独立于平台的抽象，用于对流入专用中间设备的流量进行建模。下图描述了跨多个配置资源的控制流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/blog/2018/v1alpha3-routing/virtualservices-destrules.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;不同v1alpha3元素之间的关系&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-gateway-介绍-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. Gateway 介绍&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#Gateway&#34; target=&#34;_blank&#34;&gt;Gateway&lt;/a&gt; 用于为 HTTP / TCP 流量配置负载均衡器，并不管该负载均衡器将在哪里运行。 网格中可以存在任意数量的 Gateway，并且多个不同的 Gateway 实现可以共存。 实际上，通过在配置中指定一组工作负载（Pod）标签，可以将 Gateway 配置绑定到特定的工作负载，从而允许用户通过编写简单的 Gateway Controller 来重用现成的网络设备。&lt;/p&gt;

&lt;p&gt;对于入口流量管理，您可能会问： 为什么不直接使用 Kubernetes Ingress API ？ 原因是 Ingress API 无法表达 Istio 的路由需求。 Ingress 试图在不同的 HTTP 代理之间取一个公共的交集，因此只能支持最基本的 HTTP 路由，最终导致需要将代理的其他高级功能放入到注解（annotation）中，而注解的方式在多个代理之间是不兼容的，无法移植。&lt;/p&gt;

&lt;p&gt;Istio &lt;code&gt;Gateway&lt;/code&gt; 通过将 L4-L6 配置与 L7 配置分离的方式克服了 &lt;code&gt;Ingress&lt;/code&gt; 的这些缺点。 &lt;code&gt;Gateway&lt;/code&gt; 只用于配置 L4-L6 功能（例如，对外公开的端口，TLS 配置），所有主流的L7代理均以统一的方式实现了这些功能。 然后，通过在 &lt;code&gt;Gateway&lt;/code&gt; 上绑定 &lt;code&gt;VirtualService&lt;/code&gt; 的方式，可以使用标准的 Istio 规则来控制进入 &lt;code&gt;Gateway&lt;/code&gt; 的 HTTP 和 TCP 流量。&lt;/p&gt;

&lt;p&gt;例如，下面这个简单的 &lt;code&gt;Gateway&lt;/code&gt; 配置了一个 Load Balancer，以允许访问 host &lt;code&gt;bookinfo.com&lt;/code&gt; 的 https 外部流量进入网格中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: bookinfo-gateway
spec:
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - bookinfo.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要为进入上面的 Gateway 的流量配置相应的路由，必须为同一个 host 定义一个 &lt;a href=&#34;https://www.yangcs.net/posts/istio-traffic-management/&#34; target=&#34;_blank&#34;&gt;VirtualService&lt;/a&gt;（参考上一篇博文），并使用配置中的 &lt;code&gt;gateways&lt;/code&gt; 字段绑定到前面定义的 &lt;code&gt;Gateway&lt;/code&gt; 上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: bookinfo
spec:
  hosts:
    - bookinfo.com
  gateways:
  - bookinfo-gateway # &amp;lt;---- bind to gateway
    http:
  - match:
    - uri:
        prefix: /reviews
    route:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gateway 可以用于建模边缘代理或纯粹的内部代理，如第一张图所示。 无论在哪个位置，所有网关都可以用相同的方式进行配置和控制。&lt;/p&gt;

&lt;p&gt;下面通过一个示例来演示如何配置 Istio 以使用 Istio  Gateway 在服务网格外部公开服务。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-使用-istio-网关配置-ingress-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 使用 Istio 网关配置 Ingress&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;让我们看看如何为 Gateway 在 HTTP 80 端口上配置流量。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个 Istio Gateway&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  $ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
  apiVersion: networking.istio.io/v1alpha3
  kind: Gateway
  metadata:
    name: httpbin-gateway
  spec:
    selector:
      istio: ingressgateway # use Istio default gateway implementation
    servers:
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
      - &amp;quot;httpbin.example.com&amp;quot;
  EOF    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为通过 Gateway 进入的流量配置路由&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  $ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: httpbin
  spec:
    hosts:
    - &amp;quot;httpbin.example.com&amp;quot;
    gateways:
    - httpbin-gateway
    http:
    - match:
      - uri:
          prefix: /status
      - uri:
          prefix: /delay
      route:
      - destination:
          port:
            number: 8000
          host: httpbin
  EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们 为服务创建了一个 &lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService&#34; target=&#34;_blank&#34;&gt;VirtualService&lt;/a&gt; 配置 &lt;code&gt;httpbin&lt;/code&gt; ，其中包含两条路由规则，允许路径 &lt;code&gt;/status&lt;/code&gt; 和 路径的流量 &lt;code&gt;/delay&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService-gateways&#34; target=&#34;_blank&#34;&gt;网关&lt;/a&gt;列表指定，只有通过我们的要求 &lt;code&gt;httpbin-gateway&lt;/code&gt; 是允许的。所有其他外部请求将被拒绝，并返回 404 响应。&lt;/p&gt;

&lt;p&gt;请注意，在此配置中，来自网格中其他服务的内部请求不受这些规则约束，而是简单地默认为循环路由。要将这些（或其他规则）应用于内部调用，我们可以&lt;strong&gt;将特殊值 &lt;code&gt;mesh&lt;/code&gt; 添加到 &lt;code&gt;gateways&lt;/code&gt; 的列表中&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 curl 访问 httpbin 服务。&lt;/p&gt;

&lt;p&gt;首先获取 Ingress Gateway 的 IP 和 端口，参考上一篇文章：&lt;a href=&#34;https://www.yangcs.net/posts/istio-traffic-management/&#34; target=&#34;_blank&#34;&gt;Istio 流量管理&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -HHost:httpbin.example.com http://$INGRESS_HOST:$INGRESS_PORT/status/200
    
HTTP/1.1 200 OK
server: envoy
date: Thu, 02 Aug 2018 04:18:41 GMT
content-type: text/html; charset=utf-8
access-control-allow-origin: *
access-control-allow-credentials: true
content-length: 0
x-envoy-upstream-service-time: 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，我们使用该 &lt;code&gt;-H&lt;/code&gt; 标志将 Host &lt;code&gt;HTTP Header&lt;/code&gt; 设置为 “httpbin.example.com”。这是必需的，因为我们的 ingress &lt;code&gt;Gateway&lt;/code&gt; 被配置为处理 “httpbin.example.com”，但在我们的测试环境中，我们没有该主机的 DNS 绑定，并且只是将我们的请求发送到 ingress IP。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;访问任何未明确公开的其他 URL。您应该看到一个 HTTP 404 错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -HHost:httpbin.example.com http://$INGRESS_HOST:$INGRESS_PORT/headers
    
HTTP/1.1 404 Not Found
date: Thu, 02 Aug 2018 04:21:39 GMT
server: envoy
transfer-encoding: chunked
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-使用浏览器访问-ingress-服务-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 使用浏览器访问 Ingress 服务&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;如果你想在浏览器中输入 httpbin 服务的 URL 来访问是行不通的，因为我们没有办法像使用 curl 一样告诉浏览器假装访问 &lt;code&gt;httpbin.example.com&lt;/code&gt;，只能通过向 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件中添加 hosts 来解决这个问题。&lt;/p&gt;

&lt;p&gt;但是麻烦又来了，目前这种状况下即使你添加了 hosts，也仍然无法访问，因为 Istio Gateway 使用的是 NodePort 模式，暴露出来的不是 80 端口和 443 端口，而我们要想通过域名来访问服务，必须要求 Gateway 暴露出来的端口是 80 和 443。&lt;/p&gt;

&lt;p&gt;所以我们只能曲线救国了，通过修改 Ingress Gateway 的 &lt;code&gt;Deployment&lt;/code&gt;，将 80 端口和 443 端口配置为 &lt;code&gt;hostPort&lt;/code&gt; 模式，然后再通过 Node 亲和性将 &lt;code&gt;Gateway&lt;/code&gt; 调度到某个固定的主机上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n istio-system edit deployment istio-ingressgateway
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: istio-ingressgateway
  namespace: istio-system
  ...
spec:
  ...
  template:
    ...
    spec:
      affinity:
        nodeAffinity:
          ...
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/hostname
                operator: In
                values:
                - 192.168.123.248   # 比如你想调度到这台主机上
      containers:
        - name: ISTIO_META_POD_NAME
        ...
        - containerPort: 80
          hostPort: 80
          protocol: TCP
        - containerPort: 443
          hostPort: 443
          protocol: TCP
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改完之后保存退出，等待 Gateway 的 Pod 重新调度，然后在你的浏览器所在的本地电脑上添加一条 hosts：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;192.168.123.248 httpbin.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新配置 &lt;code&gt;VirtualService&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$  cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
 apiVersion: networking.istio.io/v1alpha3
 kind: VirtualService
 metadata:
   name: httpbin
 spec:
   hosts:
   - &amp;quot;httpbin.example.com&amp;quot;
     gateways:
   - httpbin-gateway
     http:
   - match:
     - uri:
         prefix: /status
     - uri:
         prefix: /delay
     - uri:
         prefix: /headers
     route:
     - destination:
         port:
           number: 8000
         host: httpbin
 EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就可以在浏览器中输入 URL：&lt;code&gt;http://httpbin.example.com/headers&lt;/code&gt; 来访问服务啦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Jietu20180802-130152.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-清理-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 清理&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;删除 Gateway、VirtualService 和 httpbin 服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl delete gateway httpbin-gateway
$ istioctl delete virtualservice httpbin
$ kubectl delete --ignore-not-found=true -f samples/httpbin/httpbin.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 参考&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/docs/tasks/traffic-management/ingress/&#34; target=&#34;_blank&#34;&gt;控制 Ingress 流量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/docs/concepts/traffic-management/#gateway&#34; target=&#34;_blank&#34;&gt;Gateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Istio 流量管理</title>
      <link>https://www.yangcs.net/posts/istio-traffic-management/</link>
      <pubDate>Wed, 01 Aug 2018 20:59:11 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/istio-traffic-management/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Istio 从 0.8 版本开始出现了一个新的 API 组：&lt;a href=&#34;http://networking.istio.io/v1alpha3&#34; target=&#34;_blank&#34;&gt;networking.istio.io/v1alpha3&lt;/a&gt;，应该会替代现有的 &lt;a href=&#34;http://config.istio.io/v1alpha2&#34; target=&#34;_blank&#34;&gt;config.istio.io/v1alpha2&lt;/a&gt; API。新的 API 不管是结构上还是功能上、以及命名上，都有很大差异。如果不作特殊说明，本文所有的示例将采用新版 API。&lt;/p&gt;

&lt;p&gt;本文将通过简单的示例来演示通过 Istio 实现应用的金丝雀部署。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;正常情况下 istioctl 和 kubectl 都可以用来操作这些对象，但是 kubectl 缺乏验证功能，因此调试阶段使用 &lt;code&gt;istioctl&lt;/code&gt; 会更方便一些。&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;p-id-h2-1-bookinfo-应用介绍-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. Bookinfo 应用介绍&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;以 Bookinfo 应用为示例，它由四个单独的微服务构成，用来演示多种 Istio 特性。这个应用模仿在线书店的一个分类，显示一本书的信息。页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。&lt;/p&gt;

&lt;p&gt;Bookinfo 应用分为四个单独的微服务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;productpage&lt;/code&gt; ：&lt;code&gt;productpage&lt;/code&gt; 微服务会调用 &lt;code&gt;details&lt;/code&gt; 和 &lt;code&gt;reviews&lt;/code&gt; 两个微服务，用来生成页面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;details&lt;/code&gt; ：这个微服务包含了书籍的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reviews&lt;/code&gt; ：这个微服务包含了书籍相关的评论。它还会调用 ratings 微服务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ratings&lt;/code&gt; ：&lt;code&gt;ratings&lt;/code&gt; 微服务中包含了由书籍评价组成的评级信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;reviews&lt;/code&gt; 微服务有 3 个版本：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;v1 版本不会调用 &lt;code&gt;ratings&lt;/code&gt; 服务。&lt;/li&gt;
&lt;li&gt;v2 版本会调用 &lt;code&gt;ratings&lt;/code&gt; 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。&lt;/li&gt;
&lt;li&gt;v3 版本会调用 &lt;code&gt;ratings&lt;/code&gt; 服务，并使用 1 到 5 个红色星形图标来显示评分信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图展示了这个应用的端到端架构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/docs/examples/bookinfo/noistio.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;Istio 注入之前的 Bookinfo 应用&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Bookinfo 是一个异构应用，几个微服务是由不同的语言编写的。这些服务对 Istio 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个服务、多个语言构成，并且 &lt;code&gt;reviews&lt;/code&gt; 服务具有多个版本。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-部署-bookinfo-应用-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 部署 Bookinfo 应用&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;要在 Istio 中运行这一应用，无需对应用自身做出任何改变。我们只要简单的在 Istio 环境中对服务进行配置和运行，具体一点说就是把 Envoy sidecar 注入到每个服务之中。这个过程所需的具体命令和配置方法由运行时环境决定，而部署结果较为一致，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/docs/examples/bookinfo/withistio.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;Bookinfo 应用&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;所有的微服务都和 Envoy sidecar 集成在一起，被集成服务所有的出入流量都被 sidecar 所劫持，这样就为外部控制准备了所需的 Hook，然后就可以利用 Istio 控制平面为应用提供服务路由、遥测数据收集以及策略实施等功能。&lt;/p&gt;

&lt;p&gt;接下来可以根据 Istio 的运行环境，按照下面的讲解完成应用的部署。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 Istio 安装目录。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动应用容器：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果集群用的是&lt;a href=&#34;https://istio.io/docs/setup/kubernetes/sidecar-injection/#manual-sidecar-injection&#34; target=&#34;_blank&#34;&gt;手工 Sidecar 注入&lt;/a&gt;，使用如下命令：
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  $ kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://istio.io/docs/reference/commands/istioctl/#istioctl-kube-inject&#34; target=&#34;_blank&#34;&gt;istioctl kube-inject&lt;/a&gt; 命令用于在在部署应用之前修改 &lt;code&gt;bookinfo.yaml&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果集群使用的是&lt;a href=&#34;https://istio.io/docs/setup/kubernetes/sidecar-injection/#automatic-sidecar-injection&#34; target=&#34;_blank&#34;&gt;自动 Sidecar 注入&lt;/a&gt;，只需简单的 &lt;code&gt;kubectl&lt;/code&gt; 就能完成服务的部署。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  $ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令会启动全部的四个服务，其中也包括了 &lt;code&gt;reviews&lt;/code&gt; 服务的三个版本（&lt;code&gt;v1&lt;/code&gt;、&lt;code&gt;v2&lt;/code&gt; 以及 &lt;code&gt;v3&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给应用定义 Ingress gateway：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确认所有的服务和 Pod 都已经正确的定义和启动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get services
  
NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                         AGE
details       ClusterIP   10.254.86.98     &amp;lt;none&amp;gt;        9080/TCP                        3h
kubernetes    ClusterIP   10.254.0.1       &amp;lt;none&amp;gt;        443/TCP                         149d
productpage   ClusterIP   10.254.199.214   &amp;lt;none&amp;gt;        9080/TCP                        3h
ratings       ClusterIP   10.254.102.147   &amp;lt;none&amp;gt;        9080/TCP                        3h
reviews       ClusterIP   10.254.249.86    &amp;lt;none&amp;gt;        9080/TCP                        3h
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pods
  
NAME                              READY     STATUS    RESTARTS   AGE
details-v1-6456dbdb9-crqnw        2/2       Running   0          3h
productpage-v1-6f6887645c-52qhn   2/2       Running   0          3h
ratings-v1-648cf76d8f-g65s5       2/2       Running   0          3h
reviews-v1-7dcbc85bb5-j748n       2/2       Running   0          3h
reviews-v2-65fd78f5df-r8n6r       2/2       Running   0          3h
reviews-v3-95c85969c-zmpfx        2/2       Running   0          3h
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确定 Ingress 的 IP 和端口&lt;/p&gt;

&lt;p&gt;执行以下命令以确定 &lt;code&gt;ingressgateway&lt;/code&gt; 是否启用了 NodePort 模式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n istio-system get svc istio-ingressgateway

NAME                   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                                                                     AGE
istio-ingressgateway   NodePort   10.254.160.93   &amp;lt;none&amp;gt;        80:31380/TCP,443:31390/TCP,31400:31400/TCP,15011:25059/TCP,8060:36612/TCP,15030:25049/TCP,15031:36810/TCP   3h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确定 ingress IP：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export INGRESS_HOST=$(kubectl -n istio-system get po -l istio=ingressgateway -o go-template=&#39;{{range .items}}{{.status.hostIP}}{{end}}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确定端口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export INGRESS_PORT=$(kubectl -n istio-system get svc istio-ingressgateway -o go-template=&#39;{{range .spec.ports}}{{if eq .name &amp;quot;http&amp;quot;}}{{.nodePort}}{{end}}{{end}}&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置 &lt;code&gt;GATEWAY_URL&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面可以用 &lt;code&gt;curl&lt;/code&gt; 命令来确认 Bookinfo 应用的运行情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -o /dev/null -s -w &amp;quot;%{http_code}\n&amp;quot; http://${GATEWAY_URL}/productpage

200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以用浏览器打开网址 &lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;，来浏览应用的 Web 页面。如果刷新几次应用的页面，就会看到页面中会随机展示 &lt;code&gt;reviews&lt;/code&gt; 服务的不同版本的效果（红色、黑色的星形或者没有显示）。&lt;code&gt;reviews&lt;/code&gt; 服务出现这种情况是因为我们还没有使用 Istio 来控制版本的路由。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-金丝雀部署-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 金丝雀部署&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;由于 Bookinfo 示例部署了三个版本的 reviews 微服务，因此我们需要设置默认路由。 否则，如果您当多次访问应用程序，您会注意到有时输出包含星级评分，有时又没有。 这是因为没有为应用明确指定缺省路由时，Istio 会将请求随机路由到该服务的所有可用版本上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/docs/concepts/traffic-management/ServiceModel_Versions.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;此任务假定您尚未设置任何路由。 如果您已经为示例应用程序创建了存在冲突的路由规则，则需要在下面的命令中使用 &lt;code&gt;replace&lt;/code&gt; 代替 &lt;code&gt;create&lt;/code&gt;。 请注意：本文档假设还没有设置任何路由规则。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;首先将所有微服务的默认路由设置为 v1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl create -f samples/bookinfo/networking/virtual-service-all-v1.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl create -f samples/bookinfo/networking/destination-rule-all.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过下面的命令来显示已创建的路由规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl get virtualservices -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: details
  ...
spec:
  hosts:
  - details
  http:
  - route:
    - destination:
        host: details
        subset: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: productpage
  ...
spec:
  gateways:
  - bookinfo-gateway
  - mesh
  hosts:
  - productpage
  http:
  - route:
    - destination:
        host: productpage
        subset: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: ratings
  ...
spec:
  hosts:
  - ratings
  http:
  - route:
    - destination:
        host: ratings
        subset: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
  ...
spec:
  hosts:
  - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v1
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于路由规则是通过异步方式分发到代理的，因此在尝试访问应用程序之前，您应该等待几秒钟，以便规则传播到所有 pod 上。&lt;/p&gt;

&lt;p&gt;现在在浏览器中打开 Bookinfo 应用程序的 URL (&lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;)，你应该可以看到 Bookinfo 应用程序的 &lt;code&gt;productpage&lt;/code&gt; 页面。 请注意， &lt;code&gt;productpage&lt;/code&gt; 页面显示的内容中没有评分星级，这是因为 &lt;code&gt;reviews:v1&lt;/code&gt; 服务不会访问 ratings 服务。&lt;/p&gt;

&lt;p&gt;由于新的 API 引入了一些新的配置资源，而且不向后兼容，所以很有必要来解释一下上面两个 yaml 文件提到的两个新概念：&lt;code&gt;VirtualService&lt;/code&gt; 和 &lt;code&gt;DestinationRule&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;virtualservice&#34;&gt;VirtualService&lt;/h4&gt;

&lt;p&gt;过去的路由分配比较简单，使用标签即可。新的版本中，提出了 VirtualService 的概念。&lt;span id=&#34;inline-blue&#34;&gt;VirtualService&lt;/span&gt; 由一组路由规则构成，用于对服务实体（在 K8S 中对应为 Pod）进行寻址。一旦有流量符合其中规则的选择条件，就会发送流量给对应的服务（或者服务的一个版本/子集）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;VirtualService&lt;/code&gt; 描述了一个或多个用户可寻址目标到网格内实际工作负载之间的映射。其中可寻址的目标服务使用 &lt;code&gt;hosts&lt;/code&gt; 字段来指定，而网格内的实际工作负载由每个 &lt;code&gt;route&lt;/code&gt; 配置项中的 &lt;code&gt;destination&lt;/code&gt; 字段指定。在上面的示例中，这两个地址是相同的，但实际上用户可寻址目标可以是任何用于定位服务的、具有可选通配符前缀或 CIDR 前缀的 DNS 名称。&lt;/p&gt;

&lt;p&gt;流量的特征除了请求数据之外，还包括流量的来源，这样就能根据一些上下文来进行灵活的定义了。&lt;/p&gt;

&lt;p&gt;例如，以下规则定义来自打了标签 &lt;code&gt;app=sleep&lt;/code&gt; 的 Pod 对 php-server 的请求，都转向 v1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3

kind: VirtualService

metadata:

  name: sleep-server-route

spec:

  hosts:

  - &amp;quot;php-server&amp;quot;

  http:

  - match:

    - sourceLabels:

        app: sleep

    route:

    - destination:

        name: php-server

        subset: v1

  - route:

    - destination:

        name: php-server

        subset: v2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里的匹配策略是具有从上到下的优先级的，也就是说，最下一条就是缺省路由。所以没有打标签 app=sleep 的 Pod 对 php-server 的请求，都转向 v2。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而本文的 Bookinfo 示例中创建的路由规则表示：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有对 details 的请求，都转向 details 的 v1 版本。&lt;/li&gt;
&lt;li&gt;所有对 productpage 的请求，都转向 productpage 的 v1 版本。&lt;/li&gt;
&lt;li&gt;所有对 ratings 的请求，都转向 ratings 的 v1 版本。&lt;/li&gt;
&lt;li&gt;所有对 reviews 的请求，都转向 reviews 的 v1 版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，&lt;code&gt;match&lt;/code&gt; 中不再包含 &lt;code&gt;source&lt;/code&gt;，这里使用标签来过滤。写完应用之后，我们再次访问 Bookinfo 应用程序的 URL (&lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;)，会发现并没有生效。这是因为，&lt;strong&gt;在 v3 版本的 API 中，目标规则不再是透明了&lt;/strong&gt;，路由定义必须以目标策略为基础。&lt;/p&gt;

&lt;h4 id=&#34;destinationrule&#34;&gt;DestinationRule&lt;/h4&gt;

&lt;p&gt;因此这里需要定义一个 &lt;span id=&#34;inline-blue&#34;&gt;DestinationRule&lt;/span&gt; 对象，来满足上面的目标需求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: productpage
spec:
  host: productpage
  subsets:
  - name: v1
    labels:
      version: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: reviews
spec:
  host: reviews
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
  - name: v3
    labels:
      version: v3
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: ratings
spec:
  host: ratings
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
  - name: v2-mysql
    labels:
      version: v2-mysql
  - name: v2-mysql-vm
    labels:
      version: v2-mysql-vm
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: details
spec:
  host: details
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DestinationRule 用于配置在将流量转发到服务时应用的策略集。这些策略应由服务提供者撰写，用于描述断路器、负载均衡、TLS 设置等。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DestinationRule 的 &lt;code&gt;host&lt;/code&gt; 可以包含通配符前缀，以允许单个规则应用于多个服务。&lt;/li&gt;
&lt;li&gt;DestinationRule 定义了目的 host 的子集 &lt;code&gt;subsets&lt;/code&gt; （例如：命名版本）。 这些 subset 用于 &lt;code&gt;VirtualService&lt;/code&gt; 的路由规则设置中，可以将流量导向服务的某些特定版本。通过这种方式为版本命名后，可以在不同的虚拟服务中明确地引用这些命名版本的 subset，简化 Istio 代理发出的统计数据，并可以将 subsets 编码到 SNI 头中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在再次访问 Bookinfo 应用程序的 URL (&lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;)，会发现规则已经生效了。&lt;/p&gt;

&lt;h4 id=&#34;示例一-将-10-请求发送到-v2-版本而其余-90-发送到-v1-版本-br&#34;&gt;示例一：将 10% 请求发送到 v2 版本而其余 90% 发送到 v1 版本&lt;br /&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
    - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v1
      weight: 90
    - destination:
        host: reviews
        subset: v2
      weight: 10
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在的规则就是刷新 productpage 页面，90% 的概率看到黑色星标的评论，10%的概率看不到星标。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;因为使用Envoy sidecar的实现，你需要刷新页面很多次才能看到接近规则配置的概率分布。&lt;/p&gt;

&lt;h4 id=&#34;示例二-将-jason-用户的请求全部发到-v2-版本&#34;&gt;示例二：将 jason 用户的请求全部发到 v2 版本&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
    - reviews
  http:
  - match:
    - headers:
        end-user:
          exact: jason
    route:
    - destination:
        host: reviews
        subset: v2
  - route:
    - destination:
        host: reviews
        subset: v1
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;jason&lt;/code&gt; 用户登陆 productpage 页面，你可以看到每个刷新页面时，页面上都有一个1到5颗星的评级。如果你使用其他用户登陆的话，将因继续使用 &lt;code&gt;reviews:v1&lt;/code&gt; 而看不到星标评分。&lt;/p&gt;

&lt;h4 id=&#34;示例三-全部切换到-v3-版本&#34;&gt;示例三：全部切换到 v3 版本&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
  - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v3
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在不论你使用什么用户登陆 productpage 页面，你都可以看到带红色星标评分的评论了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 参考&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.fleeto.us/post/istio-route-alpha1v3/&#34; target=&#34;_blank&#34;&gt;摸索：Istio 路由规则 Alpha v3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/docs/tasks/traffic-management/request-routing/&#34; target=&#34;_blank&#34;&gt;配置请求路由&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Istio 1.0 部署</title>
      <link>https://www.yangcs.net/posts/istio-1.0-deploy/</link>
      <pubDate>Wed, 01 Aug 2018 15:33:46 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/istio-1.0-deploy/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;北京时间 2018 年 8 月 1 日（建军节）凌晨 0 点，Istio 宣布推出 1.0 正式版本，并表示已可用于生产环境。这距离最初的 0.1 版本发布已过去一年多的时间。这个项目的组件相对比较复杂，原有的一些选项是靠 ConfigMap 以及 istioctl 分别调整的，现在通过重新设计的 &lt;code&gt;Helm Chart&lt;/code&gt;，安装选项用 &lt;code&gt;values.yml&lt;/code&gt; 或者 helm 命令行的方式来进行集中管理了。&lt;/p&gt;

&lt;p&gt;在安装 Istio 之前要确保 Kubernetes 集群（仅支持 &lt;code&gt;v1.9&lt;/code&gt; 及以后版本）已部署并配置好本地的 kubectl 客户端。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-下载-istio-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 下载 Istio&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget https://github.com/istio/istio/releases/download/1.0.0/istio-1.0.0-linux.tar.gz
$ tar zxf istio-1.0.0-linux.tar.gz
$ cp istio-1.0.0/bin/istioctl /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-2-使用-helm-部署-istio-服务-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 使用 Helm 部署 Istio 服务&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;克隆 Istio 仓库：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/istio/istio.git
$ cd istio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装包内的 Helm 目录中包含了 Istio 的 Chart，官方提供了两种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用 Helm 生成 &lt;code&gt;istio.yaml&lt;/code&gt;，然后自行安装。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;Tiller&lt;/code&gt; 直接安装。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很明显，两种方法并没有什么本质区别，这里我们采用第一种方法来部署。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm template install/kubernetes/helm/istio --name istio --namespace istio-system --set sidecarInjectorWebhook.enabled=true --set ingress.service.type=NodePort --set gateways.istio-ingressgateway.type=NodePort --set gateways.istio-egressgateway.type=NodePort --set tracing.enabled=true --set servicegraph.enabled=true --set prometheus.enabled=true --set tracing.jaeger.enabled=true --set grafana.enabled=true &amp;gt; istio.yaml

$ kubectl create namespace istio-system
$ kubectl create -f istio.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里说的是使用 &lt;code&gt;install/kubernetes/helm/istio&lt;/code&gt; 目录中的 Chart 进行渲染，生成的内容保存到 &lt;code&gt;./istio.yaml&lt;/code&gt; 文件之中。将 &lt;code&gt;sidecarInjectorWebhook.enabled&lt;/code&gt; 设置为 true，从而使自动注入属性生效。&lt;/p&gt;

&lt;p&gt;部署完成后，可以检查 &lt;code&gt;isotio-system&lt;/code&gt; namespace 中的服务是否正常运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n istio-system get pods -o go-template=&#39;{{range .items}}{{.metadata.name}}{{&amp;quot;\n&amp;quot;}}{{end}}&#39;

istio-citadel-f5779fbbb-brbxd
istio-cleanup-secrets-jjqg5
istio-egressgateway-6c5cc7dd86-l2c82
istio-galley-6bf8f6f4b7-twvzl
istio-ingressgateway-fbfdfc5c7-fg9xh
istio-pilot-85df58955d-g5bfh
istio-policy-74c48c8ccb-wd6h6
istio-sidecar-injector-cf5999cf8-h9smx
istio-statsd-prom-bridge-55965ff9c8-2hmzf
istio-telemetry-cb49594cc-gfd84
istio-tracing-77f9f94b98-9xvzs
prometheus-7456f56c96-xcdh4
servicegraph-5b8d7b4d5-lzhth
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;过去的 istio-ca 现已更名 &lt;code&gt;istio-citadel&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istio-cleanup-secrets&lt;/code&gt; 是一个 job，用于清理过去的 Istio 遗留下来的 CA 部署（包括 sa、deploy 以及 svc 三个对象）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;egressgateway&lt;/code&gt;、&lt;code&gt;ingress&lt;/code&gt; 以及 &lt;code&gt;ingressgateway&lt;/code&gt;，可以看出边缘部分的变动很大，以后会另行发文。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;p-id-h2-3-prometheus-grafana-servicegraph-和-jaeger-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. Prometheus、Grafana、Servicegraph 和 Jaeger&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;等所有 Pod 启动后，可以通过 NodePort、Ingress 或者 kubectl proxy 来访问这些服务。比如可以通过 &lt;code&gt;Ingress&lt;/code&gt; 来访问服务。&lt;/p&gt;

&lt;p&gt;首先为 Prometheus、Grafana、Servicegraph 和 Jaeger 服务创建 Ingress：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat ingress.yaml

---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: prometheus
  namespace: istio-system
spec:
  rules:
  - host: prometheus.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: prometheus
          servicePort: 9090
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: grafana
  namespace: istio-system
spec:
  rules:
  - host: grafana.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: grafana
          servicePort: 3000
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: servicegraph
  namespace: istio-system
spec:
  rules:
  - host: servicegraph.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: servicegraph
          servicePort: 8088
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: tracing
  namespace: istio-system
spec:
  rules:
  - host: tracing.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: tracing
          servicePort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl create -f ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你的本地电脑上添加四条 &lt;code&gt;hosts&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$Ingree_host prometheus.istio.io
$Ingree_host grafana.istio.io
$Ingree_host servicegraph.istio.io
$Ingree_host tracing.istio.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 &lt;code&gt;$Ingree_host&lt;/code&gt; 替换为 Ingress Controller 运行节点的 IP。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;http://grafana.istio.io&lt;/code&gt; 访问 Grafana 服务：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-mesh.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-service.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;http://servicegraph.istio.io&lt;/code&gt; 访问 ServiceGraph 服务，展示服务之间调用关系图。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/force/forcegraph.html&lt;/code&gt; : As explored above, this is an interactive &lt;a href=&#34;https://d3js.org/&#34; target=&#34;_blank&#34;&gt;D3.js&lt;/a&gt; visualization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-servicegraph.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/dotviz&lt;/code&gt; : is a static &lt;a href=&#34;https://www.graphviz.org/&#34; target=&#34;_blank&#34;&gt;Graphviz&lt;/a&gt; visualization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/servicegraph-dotviz1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/dotgraph&lt;/code&gt; : provides a [DOT](&lt;a href=&#34;https://www.wikiwand.com/en/DOT_(graph_description_language&#34; target=&#34;_blank&#34;&gt;https://www.wikiwand.com/en/DOT_(graph_description_language&lt;/a&gt;) serialization.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/d3graph&lt;/code&gt; : provides a JSON serialization for D3 visualization.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/graph&lt;/code&gt; : provides a generic JSON serialization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 &lt;code&gt;http://tracing.istio.io/&lt;/code&gt; 访问 Jaeger 跟踪页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/zipkin-jaeger.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;http://prometheus.istio.io/&lt;/code&gt; 访问 Prometheus 页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-prometheus.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;如果你已经部署了 &lt;code&gt;Prometheus-operator&lt;/code&gt;，可以不必部署 Grafana，直接将 &lt;code&gt;addons/grafana/dashboards&lt;/code&gt; 目录下的 Dashboard 模板复制出来放到 Prometheus-operator 的 Grafana 上，然后添加 istio-system 命名空间中的 Prometheus 数据源就可以监控 Istio 了。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-4-mesh-expansion-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. Mesh Expansion&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Istio 还支持管理非 Kubernetes 管理的应用。此时，需要在应用所在的 VM 或者物理中部署 Istio，具体步骤请参考 &lt;a href=&#34;https://istio.io/docs/setup/kubernetes/mesh-expansion/&#34; target=&#34;_blank&#34;&gt;Mesh Expansion&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;部署好后，就可以向 Istio 注册应用，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# istioctl register servicename machine-ip portname:port
$ istioctl -n onprem register mysql 1.2.3.4 3306
$ istioctl -n onprem register svc1 1.2.3.4 http:7000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-5-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 参考&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.fleeto.us/post/istio-0.8.0-helm/&#34; target=&#34;_blank&#34;&gt;Istio 0.8 的 Helm Chart 解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>干货与湿货分享第3期</title>
      <link>https://www.yangcs.net/posts/weekly-3/</link>
      <pubDate>Sun, 29 Jul 2018 09:38:28 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/weekly-3/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;这是《干货与湿货分享》系列的第三期，主要记录过去一周我所见到的听到的值得分享的东西。（由于本周六事情比较多，所以推迟到了周日发布）&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-新闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;新闻&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-单身税时代即将来临-https-wallstreetcn-com-articles-3343352&#34;&gt;1. &lt;a href=&#34;https://wallstreetcn.com/articles/3343352&#34; target=&#34;_blank&#34;&gt;单身税时代即将来临&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://wpimg.wallstcn.com/088c1b19-0bf8-4f39-ab78-60ca5330bebb&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&#34;http://i.ce.cn/newwap/yw/gd/201806/29/W020180629472333441689.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;单身税的历史可以追溯到 2015 年韩国的新政，低生育率逼得韩国产生了这一政策。现在我国也要变相实行这一政策，很多单身狗就受不了了，各种吐槽。&lt;/p&gt;

&lt;p&gt;很可惜，国家不包分配对象，男的都说找对象难，女的相对于男的来说，对象也很难找。这时候我觉得只有 Python 能够通过数据分析帮你找对象了。。。。&lt;/p&gt;

&lt;h3 id=&#34;2-中国撤回-facebook-在华成立子公司的许可-https-cn-reuters-com-article-china-facebookapproval-pulls-0725-idcnkbs1kg029&#34;&gt;2. &lt;a href=&#34;https://cn.reuters.com/article/china-facebookapproval-pulls-0725-idCNKBS1KG029&#34; target=&#34;_blank&#34;&gt;中国撤回 Facebook 在华成立子公司的许可&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://static.leiphone.com/uploads/new/article/740_740/201807/5b574f2450c6f.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;前几日，一家名为“脸书科技（杭州）有限公司”的企业已经于 2018 年 7 月 18 日完成注册，注册资本为 3000 万美元，法定代表人为张京梅。值得一提是，这家公司由 Facebook Hong Kong Limited 100% 持股，是一家完全意义上的外资公司，可以确认，这家公司正是 Facebook 的全资子公司。&lt;/p&gt;

&lt;p&gt;但好景不长，几天之后注册信息消失了，许可证也被撤回。知情人士表示，这一态度突变并没有完全终结 Facebook 设立该公司的机会，但可能性也不是特别大，一首凉凉送给扎克伯格。。。&lt;/p&gt;

&lt;h3 id=&#34;3-世纪月全食遇上火星冲-世人抬头看-红月亮-奇景-https-www-bbc-com-zhongwen-simp-science-44990456&#34;&gt;3. &lt;a href=&#34;https://www.bbc.com/zhongwen/simp/science-44990456&#34; target=&#34;_blank&#34;&gt;世纪月全食遇上火星冲：世人抬头看“红月亮”奇景&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/moonlight.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;北京香港台湾时间周六（7月28日）凌晨，地球运行到刚好在太阳与月球之间的位置，阻挡了大部份通常会照射到月球的光线，为各地的天文爱好者上演本世纪最长的月全食。在世纪月全食发生之际，也是15年来最大、最亮的“火星冲”，闪耀红光的火星与“红月亮”相距不到10度。&lt;/p&gt;

&lt;h3 id=&#34;4-苹果申请新专利要在-macbook-上提供无线充电功能-http-www-toodaylab-com-72394&#34;&gt;4. &lt;a href=&#34;http://www.toodaylab.com/72394&#34; target=&#34;_blank&#34;&gt;苹果申请新专利要在 MacBook 上提供无线充电功能&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://files.toodaylab.com/2018/07/bpr_charge_20180728225512_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;据 GSMArena 的报道，美国专利商标局日前披露了一项苹果申请中的专利，简单的说就是在笔记本电脑上提供无线充电功能，未来只需要把手机放在电脑上就能给手机充电。这或许是在 Touch Bar 之后，苹果在电脑硬件上又给出了一个新的可能性？&lt;/p&gt;

&lt;h3 id=&#34;5-苹果为日本水灾受灾户提供免费产品维修服务-https-cn-engadget-com-2018-07-27-apple-will-repair-devices-damaged-by-flooding-in-japan-for-free&#34;&gt;5. &lt;a href=&#34;https://cn.engadget.com/2018/07/27/apple-will-repair-devices-damaged-by-flooding-in-japan-for-free/&#34; target=&#34;_blank&#34;&gt;苹果为日本水灾受灾户提供免费产品维修服务&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://s.aolcdn.com/hss/storage/midas/67604f767cab4a28a9ae9b1eda12401c/206557896/flood-ed.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;流年不利的日本，今年天灾似乎一个接着一个，稍早发生在本州中部与西部的大水灾更是已经造成了 225 人死亡、800 万人撤离，成为日本自 1982 年来最惨重的一次水灾。为了表示对受灾区复兴的支持，苹果宣布了因水灾受损的 iPhone、Mac、iPad、iPod、Apple Watch 和 Apple Display 等产品（配件、Beats 系列不在列）都可以免费获得维修服务，只要先拨打支持电话 0120-27753-5 申请，再寄送给苹果即可。如果修得好的话，苹果会在维修完成后，再将产品寄回，服务期间一直到九月底为止。&lt;/p&gt;

&lt;h3 id=&#34;6-亚马逊面部识别系统闹乌龙-28名美国会议员被误认成罪犯-http-news-ifeng-com-a-20180728-59468283-0-shtml&#34;&gt;6. &lt;a href=&#34;http://news.ifeng.com/a/20180728/59468283_0.shtml&#34; target=&#34;_blank&#34;&gt;亚马逊面部识别系统闹乌龙，28名美国会议员被误认成罪犯&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://p0.ifengimg.com/pmop/2018/0728/9475AB140B7F2C4677A85B6CD790291551F2903E_size275_w600_h413.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;商业巨头亚马逊 2016 年推出图像识别 AI 系统 “Rekognition”，还积极向美国警方推销以帮助其办案。不过近日，“Rekognition” 却闹了一个大乌龙：28名美国国会议员被它识别成了罪犯。&lt;/p&gt;

&lt;p&gt;这一错误也让发起这项测试、反对警方使用 “Rekognition” 的美国公民自由联盟（ACLU）抓到把柄，他们表示，测试结果引起了民众对警方使用该系统的严重担忧。&lt;/p&gt;

&lt;h3 id=&#34;7-广义相对论首次在超大黑洞附近获验证-http-www-stdaily-com-index-kejixinwen-2018-07-29-content-694417-shtml&#34;&gt;7. &lt;a href=&#34;http://www.stdaily.com/index/kejixinwen/2018-07/29/content_694417.shtml&#34; target=&#34;_blank&#34;&gt;广义相对论首次在超大黑洞附近获验证&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;又一次，爱因斯坦被证明是正确的。一个国际天文学家团队两天前宣布，他们利用大型地面望远镜对银河系中心进行观测，第一次证实超大黑洞附近的引力场效应与广义相对论百余年前的预测“完美符合”。&lt;/p&gt;

&lt;p&gt;根据爱因斯坦的广义相对论，光线在强引力场作用下会出现拉伸现象，波长变长，向红波方向偏移，这被称为引力红移效应。黑洞具有超强引力，甚至连光都无法从中逃逸，被认为是检验广义相对论强引力场理论的“完美实验室”。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-工具-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;工具&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-随身卡包-支持-100-多个商家和品牌会员卡的微信小程序-https-www-appinn-com-suishen-kabao&#34;&gt;1. &lt;a href=&#34;https://www.appinn.com/suishen-kabao/&#34; target=&#34;_blank&#34;&gt;随身卡包 – 支持 100 多个商家和品牌会员卡的微信小程序&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://img3.appinn.com/images/201807/img_20180713_134250.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;随身卡包 是一款非常方便实用的微信小程序，它可以将多达 100 多家商家与品牌的会员卡集合在一起，以后出门再也不用带会员卡了。&lt;/p&gt;

&lt;p&gt;随身卡包 的分享功能也非常易用，只需要在卡片详细页面点击菜单、分享，就能分享给微信好友了，好友拿到了无需注册，只需要点一下“收下”，以后就能继续使用了。&lt;/p&gt;

&lt;p&gt;在微信小程序中直接搜索 &lt;strong&gt;“随身卡包”&lt;/strong&gt; 即可。&lt;/p&gt;

&lt;h3 id=&#34;2-werss-将-微信公众号-转换为-rss-https-werss-app&#34;&gt;2. &lt;a href=&#34;https://werss.app/&#34; target=&#34;_blank&#34;&gt;WeRss – 将「微信公众号」转换为 RSS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;WeRss 是一款能够将「微信公众号」转换为 RSS 地址的服务，免费用户支持最多订阅 8 个公众号，并且支持将多个公众号聚合成一个 RSS，需要微信扫码登录。&lt;/p&gt;

&lt;p&gt;微信公众号这种差不多替代了 RSS 的玩法，让很多 RSS 用户很头痛啊，之前有不少方法可以转换为 RSS 订阅地址，结果死掉的差不多了。&lt;/p&gt;

&lt;p&gt;WeRss 是一个新的选择。有个注意事项是每个人都必须使用自己的微信扫码登录，获取 RSS 地址来订阅。&lt;/p&gt;

&lt;h3 id=&#34;3-问题疫苗查询-微信小程序-https-m-sohu-com-a-243389844-114774-pvid-000115-3w-a&#34;&gt;3. &lt;a href=&#34;https://m.sohu.com/a/243389844_114774/?pvid=000115_3w_a&#34; target=&#34;_blank&#34;&gt;“问题疫苗查询” 微信小程序&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;继阿里、百度都上线疫苗查询工具后，日前腾讯官方也宣布推出了问题疫苗查询微信小程序“腾通讯安心计划”，供用户查询和了解疫苗安全。&lt;/p&gt;

&lt;p&gt;用户进入“腾通讯安心计划”小程序后，点击“疫苗查询入口”手动输入接种证上的疫苗批次号，即可查询该批疫苗是否被监管部门列入“无效疫苗”。&lt;/p&gt;

&lt;h3 id=&#34;4-疫苗批号反查生产企业-http-ym-pppet-net&#34;&gt;4. &lt;a href=&#34;http://ym.pppet.net/&#34; target=&#34;_blank&#34;&gt;疫苗批号反查生产企业&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;伪劣疫苗牵动每一位中国人的心，面对假劣疫苗，同事连夜做了个通过疫苗批号反查生产企业的工具，希望有一点帮助。&lt;/p&gt;

&lt;h3 id=&#34;5-go-cloud-https-github-com-google-go-cloud&#34;&gt;5. &lt;a href=&#34;https://github.com/google/go-cloud&#34; target=&#34;_blank&#34;&gt;go-cloud&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;还在为兼容不同的云平台 SDK 而烦恼吗？go-cloud 通过封装不同云平台的接口，向用户提供统一的 API。例如：阿里云和腾讯云的存储桶 API 不一样，但是通过 go-cloud 的封装，可以使用统一的 API 调用&lt;/p&gt;

&lt;h3 id=&#34;6-go-mysql-https-github-com-siddontang-go-mysql&#34;&gt;6. &lt;a href=&#34;https://github.com/siddontang/go-mysql&#34; target=&#34;_blank&#34;&gt;go-mysql&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;监听 MySQL binlog 的库，可以用来把主库 MySQL 的变化同步到 Redis、elasticsearch 等。同时提供了一个类似阿里 canal 的工具库，监听并解析 binlog 变化。让管理数据和了解数据状态变得更加轻松&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-教程-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;教程&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-follow-me-install-kubernetes-cluster-https-github-com-opsnull-follow-me-install-kubernetes-cluster&#34;&gt;1. &lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34; target=&#34;_blank&#34;&gt;follow-me-install-kubernetes-cluster&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/follow-me-install-kubernetes-cluster-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;部署 kubernetes 集群教程。该教程介绍使用二进制部署最新 kubernetes 集群的所有步骤，而不是使用 kubeadm 等自动化方式来部署集群。这样有助于理解系统各组件的交互原理，进而能够快速定位、解决实际中遇到的问题。&lt;/p&gt;

&lt;h3 id=&#34;2-go-fundamental-programming-https-github-com-unknwon-go-fundamental-programming&#34;&gt;2. &lt;a href=&#34;https://github.com/Unknwon/go-fundamental-programming&#34; target=&#34;_blank&#34;&gt;go-fundamental-programming&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;《Go 编程基础》是一套针对 Google 出品的 Go 语言的视频语音教程，主要面向新手级别的学习者。&lt;/p&gt;

&lt;h3 id=&#34;3-web-series-https-github-com-wxyyxc1992-web-series&#34;&gt;3. &lt;a href=&#34;https://github.com/wxyyxc1992/Web-Series&#34; target=&#34;_blank&#34;&gt;Web-Series&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;现代 Web 开发导论，内容大纲如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基础篇&lt;/li&gt;
&lt;li&gt;进阶篇&lt;/li&gt;
&lt;li&gt;架构优化篇&lt;/li&gt;
&lt;li&gt;React 篇&lt;/li&gt;
&lt;li&gt;Vue 篇&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-spark-study-https-github-com-shijinkui-spark-study&#34;&gt;4. &lt;a href=&#34;https://github.com/shijinkui/spark_study&#34; target=&#34;_blank&#34;&gt;spark_study&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Spark 源码阅读笔记。&lt;/p&gt;

&lt;h3 id=&#34;5-the-flask-mega-tutorial-zh-https-github-com-luhuisicnu-the-flask-mega-tutorial-zh&#34;&gt;5. &lt;a href=&#34;https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh&#34; target=&#34;_blank&#34;&gt;The-Flask-Mega-Tutorial-zh&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;翻译自 Miguel Grinberg 的 blog &lt;a href=&#34;https://blog.miguelgrinberg.com&#34; target=&#34;_blank&#34;&gt;https://blog.miguelgrinberg.com&lt;/a&gt; 的2017年新版 The Flask Mega-Tutorial 教程。&lt;/p&gt;

&lt;h3 id=&#34;6-progit2-https-git-scm-com-book-zh-v2&#34;&gt;6. &lt;a href=&#34;https://git-scm.com/book/zh/v2&#34; target=&#34;_blank&#34;&gt;progit2&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/progit2-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;《Pro Git 第二版》在线中文阅读&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;资源&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-best-app-https-github-com-hzlzh-best-app&#34;&gt;1. &lt;a href=&#34;https://github.com/hzlzh/Best-App&#34; target=&#34;_blank&#34;&gt;Best-App&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;苹果系统下的优秀软件、硬件、技巧、周边设备的集合。&lt;/p&gt;

&lt;h3 id=&#34;2-interviewmap-https-github-com-interviewmap-interviewmap&#34;&gt;2. &lt;a href=&#34;https://github.com/InterviewMap/InterviewMap&#34; target=&#34;_blank&#34;&gt;InterviewMap&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/InterviewMap-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这是一份制作精良、系统的面试图谱。内容包括：前端、计算机网络、算法、数据结构等方面。相信认真学习完这份资料，你会找到自己心仪的工作。&lt;/p&gt;

&lt;h3 id=&#34;3-night-reading-go-https-github-com-developer-learning-night-reading-go&#34;&gt;3. &lt;a href=&#34;https://github.com/developer-learning/night-reading-go&#34; target=&#34;_blank&#34;&gt;night-reading-go&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Go 夜读，该项目每周四晚上更新 Go 源码阅读以及线下技术讨论。难得的中文 Golang 源码解析，包含文档和YouTube 视频，干货满满。&lt;/p&gt;

&lt;h3 id=&#34;4-cpp-cheat-sheet-https-github-com-gibsjose-cpp-cheat-sheet&#34;&gt;4. &lt;a href=&#34;https://github.com/gibsjose/cpp-cheat-sheet&#34; target=&#34;_blank&#34;&gt;cpp-cheat-sheet&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;能够帮你通过 Google 和 NASA 面试的 C++ 数据结构和算法的 cheat sheet（英文）。&lt;/p&gt;

&lt;h3 id=&#34;5-vjtools-https-github-com-vipshop-vjtools&#34;&gt;5. &lt;a href=&#34;https://github.com/vipshop/vjtools&#34; target=&#34;_blank&#34;&gt;vjtools&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;唯品会的 Java 技术干货分享&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-奇闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;奇闻&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-晚上睡觉要关wifi吗-http-www-tanmizhi-com-html-4043-html&#34;&gt;1. &lt;a href=&#34;http://www.tanmizhi.com/html/4043.html&#34; target=&#34;_blank&#34;&gt;晚上睡觉要关wifi吗?&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://www.tanmizhi.com/img/allimg/07/18-1PF91F323.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;随着信息化时代的到来，基本上家家户户都有了WiFi，在家上网速度快，并且非常的方便。WiFi 现在几乎是遍布了我们生活的任何一个地方，就算你关掉了 WiFi，但是别人的WiFi也围绕着你。网传WiFi致癌，导致很多人对 WiFi 产生了恐惧的心里。有新闻还报道过，男子因为害怕WiFi的辐射对妻子肚子里的胎儿不利，而请求整栋楼的WiFi都关闭掉。这篇文章就为大家来揭秘一下晚上睡觉到底要不要关wifi。&lt;/p&gt;

&lt;h3 id=&#34;2-越南女兵不穿内衣真相-http-www-tanmizhi-com-html-4040-html&#34;&gt;2. &lt;a href=&#34;http://www.tanmizhi.com/html/4040.html&#34; target=&#34;_blank&#34;&gt;越南女兵不穿内衣真相&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://www.tanmizhi.com/img/allimg/07/18-1PF9154925.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;越南女兵是全球有名的，在越南战争的时候，越南女兵甚至起到了主力军的作用，但是很多越南女兵都是不穿内衣的“真空上阵”。越南女兵在被俘虏的时候，会主动的脱下自己的军装外套，露出迷人的身体出来。如果在敌军比较少的时候，她们会趁机用机枪扫射，不惜与敌人同归于尽。&lt;/p&gt;

&lt;h3 id=&#34;3-什么食物最解辣-https-zhuanlan-zhihu-com-p-40274806&#34;&gt;3. &lt;a href=&#34;https://zhuanlan.zhihu.com/p/40274806&#34; target=&#34;_blank&#34;&gt;什么食物最解辣？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-9b847a64d1f235aee45556c26a997c85_1200x500.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在所有的味感中，辣味是比较特殊的一种口感。&lt;strong&gt;它是辛香料中的一些成分引起的尖利刺痛感和特殊灼烧感的总和&lt;/strong&gt;，不但能刺激舌和口腔的触觉神经引起痛觉，同时也会刺激鼻腔，有时对皮肤也产生灼烧感。&lt;/p&gt;

&lt;p&gt;那么到底怎么解辣呢？真相竟然是牛奶！原因是牛奶中的酪蛋白能将辣椒素包裹起来带走，防止其刺伤我们口腔，能起到很好的解辣效果。&lt;/p&gt;

&lt;h3 id=&#34;4-女程序员该如何求救&#34;&gt;4. 女程序员该如何求救？&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1180.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;设想一个故事场景：如果一个女程序员落难到一个孤岛上，该如何求救？然后就有人用漫画告诉了我们最佳答案。。。我也觉得 php 是世界上最好的语言，不接受反驳！&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-欢迎关注-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;欢迎关注&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;该系列每周六发布，同步更新在我的&lt;a href=&#34;https://www.yangcs.net/&#34; target=&#34;_blank&#34;&gt;个人博客&lt;/a&gt;和微信公众号上。&lt;/p&gt;

&lt;p&gt;微信搜索 “云原生实验室” 或者扫描二维码即可关注。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>干货与湿货分享第2期</title>
      <link>https://www.yangcs.net/posts/weekly-2/</link>
      <pubDate>Sat, 21 Jul 2018 11:01:26 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/weekly-2/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;这是《干货与湿货分享》系列的第二期，主要记录过去一周我所见到的听到的值得分享的东西。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-新闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;新闻&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-谷歌推出首款微信小程序-猜画小歌-https-techcrunch-cn-2018-07-18-google-launches-its-first-wechat-mini-program-as-its-china-experiments-continue&#34;&gt;1. &lt;a href=&#34;https://techcrunch.cn/2018/07/18/google-launches-its-first-wechat-mini-program-as-its-china-experiments-continue/&#34; target=&#34;_blank&#34;&gt;谷歌推出首款微信小程序“猜画小歌”&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1130.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了让每个人都有机会体验人工智能技术驱动下的人机交互，近日，谷歌推出了旗下首款微信小程序“猜画小歌”，也是一款有趣的社交微信小程序。官方表示，猜画小歌由来自 Google AI 的神经网络驱动，该网络源自全世界最大的、囊括超过 5000 万个手绘素描的数据群。&lt;/p&gt;

&lt;p&gt;当天中午体验了下，简直停不下来，立马发了朋友圈告知好友，然后就看到朋友圈内诞生了各种灵魂画作，选一个比较有代表性的给你们感受下：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1129.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;建议大家第一时间体验，感觉 Google 这个小程序要孕育出一大堆灵魂画手，秀出自己的灵魂画作吧！&lt;/p&gt;

&lt;h3 id=&#34;2-微信批量封号-https-chinadigitaltimes-net-chinese-2018-07-e3-80-90-e7-ab-8b-e6-ad-a4-e5-ad-98-e7-85-a7-e3-80-91-e6-89-b9-e9-87-8f-e5-b0-81-e5-8f-b7-e5-be-ae-e4-bf-a1-e5-b0-81-e5-bb-ba-e6-97-b6-e4-bb-a3-e5-88-b0-e6-9d-a5&#34;&gt;2. &lt;a href=&#34;https://chinadigitaltimes.net/chinese/2018/07/%E3%80%90%E7%AB%8B%E6%AD%A4%E5%AD%98%E7%85%A7%E3%80%91%E6%89%B9%E9%87%8F%E5%B0%81%E5%8F%B7-%E5%BE%AE%E4%BF%A1%E5%B0%81%E5%BB%BA%E6%97%B6%E4%BB%A3%E5%88%B0%E6%9D%A5/&#34; target=&#34;_blank&#34;&gt;微信批量封号&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;近日，中国数字时代发现，微博、推特、豆瓣等平台，集中出现一些声称遭遇微信封号的网友，数量较多，其中多数网友被封号原因推测都与“传播谣言”、“散布有害言论”、“妄议时政”等相关，也有一些网友对于被封号原因表示不解。&lt;/p&gt;

&lt;p&gt;从网友反馈看，微信近期较有可能是重点对微信群内的“有害信息”进行监控，而后对个别账号进行定点清除，甚至对整群进行封禁。&lt;/p&gt;

&lt;p&gt;从内容尺度上看，微信显然在近期大大收紧了管理尺度，这对一些网友来说有些始料未及。例如，有网友称自己发表了对“泼墨门事件”的评论而遭封号；有网友称自己在朋友圈转发了“**门下大雨”导致封号…..&lt;/p&gt;

&lt;p&gt;但在中国，由于微信经常与个人社交相关联，许多人被封号封群后又不得不重新创建，于是有网友调侃“我们进入了一个封建时期”。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/wechat1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/wechat2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/wechat3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-android-免费模式或将终结-https-36kr-com-p-5143943-html&#34;&gt;3. &lt;a href=&#34;https://36kr.com/p/5143943.html&#34; target=&#34;_blank&#34;&gt;Android 免费模式或将终结&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://pic.36krcnd.com/201807/18232502/o6d9dnyk6lsmtvyu.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;7月18日晚间消息，因谷歌 Android 垄断一案，欧盟委员会今日正式宣布，对谷歌处以 43.4 亿欧元(约合 50.4 亿美元)的罚款。&lt;/p&gt;

&lt;p&gt;对此，谷歌 CEO 桑达尔·皮查伊（Sundar Pichai）发表文章，警告称由于欧盟的决定，Android 可能无法保持免费。&lt;/p&gt;

&lt;p&gt;欧盟对谷歌发出 50 亿美元的罚单后，谷歌 CEO 桑德·皮查在谷歌官网发文抗议。&lt;/p&gt;

&lt;p&gt;他认为，欧盟委员会针对 Android 及其商业模式的罚单定忽略了 Android 手机与 iOS 手机竞争的事实。也忽略了 Android 为成千上万的手机制造商和移动网络运营商提供了多少选择，正是这些手机制造商和移动运营商在生产并销售 Android 设备。此外，世界各地有数百万的企业依靠开发 Android 应用为生；数十亿的消费者使用着廉价的安卓手机。&lt;/p&gt;

&lt;h3 id=&#34;4-google印度工程师被活活打死-https-www-cnbeta-com-articles-tech-748631-htm&#34;&gt;4. &lt;a href=&#34;https://www.cnbeta.com/articles/tech/748631.htm&#34; target=&#34;_blank&#34;&gt;Google印度工程师被活活打死&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/efa942f659a7e12.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;据外媒报道，近日，印度一位32岁的 Google 软件工程师 Mohammad Azam 遭遇不幸，被人活活打死，而原因竟然是村民听信谣言，以为这位工程师是个人贩子。报道称，Azam 和他们的两位友人去外地见另外一位朋友，回程途中休息的时候碰到一群小学生经过，出于好心拿出巧克力分给孩子们。&lt;/p&gt;

&lt;p&gt;这本来是一个友善的举动，却引起了周围村民的误会，因为社交媒体上在热传有儿童绑架犯逃窜的消息。&lt;/p&gt;

&lt;p&gt;村民们觉得 Azam 一行人很可疑，但没有去查证就认定他们是绑架犯，还在 WhatsApp 等社交渠道上发出了他们的照片，并声称他们就是绑架犯，别让他们跑了。&lt;/p&gt;

&lt;p&gt;很快，越来越多的村民闻讯赶来，拦住了 Azam 一行人的汽车，用棍棒、石头发起攻击。Azam怎么解释都没人听，就连警察赶来也无济于事。&lt;/p&gt;

&lt;p&gt;最后，车子被砸得稀烂，Azam 被打死，另外两人也受了重伤。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/6e5e9c0eea7bc5c.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-整个社区联合起来强奸一个孩子-https-cn-nytimes-com-world-20180719-rape-chennai-india-utm-source-tw-nytimeschinese-utm-medium-social-utm-campaign-cur&#34;&gt;5. &lt;a href=&#34;https://cn.nytimes.com/world/20180719/rape-chennai-india/?utm_source=tw-nytimeschinese&amp;amp;utm_medium=social&amp;amp;utm_campaign=cur&#34; target=&#34;_blank&#34;&gt;整个社区联合起来强奸一个孩子&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/merlin.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;新德里——警方表示，数月来，一群男子一直在轮奸一名11岁的女孩。&lt;/p&gt;

&lt;p&gt;警方表示，这名女孩与父母住在金奈一个封闭式社区，这些男子给她喝下掺有药物的软饮。警方还说，他们拍下了强奸这名女孩的场面，挥舞着刀子威胁她，如果告诉家人的话就公开这些视频。&lt;/p&gt;

&lt;p&gt;这些男子并非这个封闭式社区的闯入者，而是向居民打招呼、操作电梯、为公寓送饮水机的社区雇员。&lt;/p&gt;

&lt;h3 id=&#34;6-马化腾朋友圈辟谣-https-getpocket-com-redirect-url-https-3a-2f-2fm-mydrivers-com-2fnewsview-2f585157-html-3fref-3dandroid-app-253a-2f-2fcom-google-android-googlequicksearchbox-2fhttps-2fwww-google-com-formcheck-e3cf5ad1969099a5c614a0e851dfa82b&#34;&gt;6. &lt;a href=&#34;https://getpocket.com/redirect?url=https%3A%2F%2Fm.mydrivers.com%2Fnewsview%2F585157.html%3Fref%3Dandroid-app%253A%2F%2Fcom.google.android.googlequicksearchbox%2Fhttps%2Fwww.google.com&amp;amp;formCheck=e3cf5ad1969099a5c614a0e851dfa82b&#34; target=&#34;_blank&#34;&gt;马化腾朋友圈辟谣&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/726c1d06f96.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;近日，一则“王思聪表白马化腾女儿”的传闻在网上传播，&lt;strong&gt;对此马化腾本人在朋友圈辟谣回应，称“这两天集中爆发的针对我家人的谣言越来越卑劣”，表示“一定会追查到底”。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外认证为腾讯公关总监的腾讯张军微博也发布了该朋友圈截图，表示该朋友圈为“Pony的辟谣”，侧面证实了马化腾本人回应的真实性。&lt;/p&gt;

&lt;p&gt;不过也许是考虑到抑制谣言传播，目前张军已经删除了自己的辟谣微博，代之转发了一条新浪科技的辟谣报道。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/d20b8f8b16.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-工具-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;工具&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-hexoeditor-https-github-com-zhuzhuyule-hexoeditor&#34;&gt;1. &lt;a href=&#34;https://github.com/zhuzhuyule/HexoEditor&#34; target=&#34;_blank&#34;&gt;HexoEditor&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这是一款为 Hexo 做了优化的非常清新的 Markdown 编辑器，使用 Electron 做框架，修改自 &lt;a href=&#34;https://github.com/Moeditor/Moeditor&#34; target=&#34;_blank&#34;&gt;Moeditor&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/gif-tag.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-router7-https-github-com-rtr7-router7&#34;&gt;2. &lt;a href=&#34;https://github.com/rtr7/router7&#34; target=&#34;_blank&#34;&gt;router7&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一款用 Go 语言编写的软路由操作系统。该项目目前还只是个 demo，更多功能请继续关注。&lt;/p&gt;

&lt;h3 id=&#34;3-infinity-新标签页-https-cn-infinitynewtab-com&#34;&gt;3. &lt;a href=&#34;https://cn.infinitynewtab.com/&#34; target=&#34;_blank&#34;&gt;Infinity 新标签页&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/infinity.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Infinity，基于过去对新标签页的认识，重新定义了新标签页，一个追求极简美学和一站式服务体验。新一代的标签页，一个更好用，更强大的新标签页。&lt;/p&gt;

&lt;h3 id=&#34;4-camtd-chrome-多线程下载管理器插件-https-github-com-jae-jae-camtd&#34;&gt;4. &lt;a href=&#34;https://github.com/jae-jae/Camtd&#34; target=&#34;_blank&#34;&gt;Camtd - Chrome 多线程下载管理器插件&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/6874.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如果你跟我一样不满 Chrome 默认的下载管理器，或许 Camtd 这款多线程下载管理器插件正适合你，它基于 Aria2 和 AriaNg，可满速下载百度网盘文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;演示：满速下载百度网盘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/1bcf69d6.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-yomail-http-www-nextechat-com&#34;&gt;5. &lt;a href=&#34;http://www.nextechat.com/&#34; target=&#34;_blank&#34;&gt;Yomail&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://img3.appinn.com/images/201611/yomail_app12x.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;邮件作为一项古老的计算机技术，相应的邮件客户端也是层出不穷。有 Mailbox 这类带有创新的交互方式的，也有 Inbox、Spark 这类智能整理收件箱的，Airmail 这类把邮件和其他软件串联的设计更是让你重新审视邮件的意义。&lt;/p&gt;

&lt;p&gt;不过这些试图「重新发明邮件」的客户端，并没有特别针对国内环境做设计。如果你不太热衷于尝试这些国外的邮件客户端，又不满足于国内邮件服务商的官方网页或客户端，想在工作中更好处理邮件，可以试试 YoMail。&lt;/p&gt;

&lt;h3 id=&#34;6-irreader-一个-rss-阅读器-http-irreader-netqon-com&#34;&gt;6. &lt;a href=&#34;http://irreader.netqon.com/&#34; target=&#34;_blank&#34;&gt;Irreader 一个 RSS 阅读器&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://irreader.netqon.com/libs/c/1.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;irreader 是一个 RSS 阅读器，除了 RSS 之外，也可以订阅网页和 podcast，有一个内置的源市场，内建 Podcast 播放。&lt;/p&gt;

&lt;p&gt;最后再来一张 marketing 长图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://irreader.netqon.com/libs/mkt_0.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;7-人人影视-tv-版-http-app-yyets-com&#34;&gt;7. &lt;a href=&#34;http://app.yyets.com/&#34; target=&#34;_blank&#34;&gt;人人影视 TV 版&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://img3.appinn.com/images/201807/banner01.jpg!o&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;据小道消息，人人影视 TV 版的测试版已经可以安装使用，支持边下边播，以及下载到本地。&lt;/p&gt;

&lt;p&gt;目前的人人影视已经拥有各大平台客户端：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网页版&lt;/li&gt;
&lt;li&gt;iPhone、iPad&lt;/li&gt;
&lt;li&gt;Android&lt;/li&gt;
&lt;li&gt;Android TV&lt;/li&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;li&gt;macOS&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-id-h2-教程-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;教程&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-linux-内存管理-https-segmentfault-com-a-1190000008125006&#34;&gt;1. &lt;a href=&#34;https://segmentfault.com/a/1190000008125006&#34; target=&#34;_blank&#34;&gt;Linux 内存管理&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在linux下，使用 top，vmstat,free 等命令查看系统或者进程的内存使用情况时，经常看到 buff/cache memeory，swap，avail Mem 等，他们都代表什么意思呢？这篇文章将来聊一聊 Linux 下的内存管理并解答这个问题。&lt;/p&gt;

&lt;h3 id=&#34;2-etcd-架构与实现解析-http-jolestar-com-etcd-architecture&#34;&gt;2. &lt;a href=&#34;http://jolestar.com/etcd-architecture/&#34; target=&#34;_blank&#34;&gt;Etcd 架构与实现解析&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。网上关于 Etcd 的使用介绍的文章不少，但分析具体架构实现的文章不多，同时 Etcd v3的文档也非常稀缺。本文通过分析 Etcd 的架构与实现，了解其优缺点以及瓶颈点，一方面可以学习分布式系统的架构，另外一方面也可以保证在业务中正确使用 Etcd，知其然同时知其所以然，避免误用。&lt;/p&gt;

&lt;h3 id=&#34;3-learning-sicp-https-github-com-deathking-learning-sicp&#34;&gt;3. &lt;a href=&#34;https://github.com/DeathKing/Learning-SICP&#34; target=&#34;_blank&#34;&gt;Learning-SICP&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://camo.githubusercontent.com/0328cc5987e0ade0ba05d452171c90cbe4f61c43/687474703a2f2f67726f7570732e637361696c2e6d69742e6564752f6d61632f636c61737365732f362e3030312f6162656c736f6e2d737573736d616e2d6c656374757265732f77697a6172642e6a7067&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;《计算机程序的构造和解释》系列公开课，视频是两位作者（Harold Abelson、Gerald Jay Sussman）在1986年7月给 Hewlett-Packard 公司员工培训时的录像。这门课程只提供了英文字幕，本项目旨在将这些英文字幕翻译为中文，方便广大的 &lt;code&gt;Scheme/Lisp&lt;/code&gt; 学习者。&lt;/p&gt;

&lt;h3 id=&#34;4-tcpdump-示例教程-https-hackertarget-com-tcpdump-examples&#34;&gt;4. &lt;a href=&#34;https://hackertarget.com/tcpdump-examples/&#34; target=&#34;_blank&#34;&gt;Tcpdump 示例教程&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;tcpdump 是一个运行在命令行下的嗅探工具。它允许用户拦截和显示发送或收到过网络连接到该计算机的 TCP/IP 和其他数据包。一般情况下，非 HTTP 协议的网络分析，在服务器端用 tcpdump 比较多，在客户端用 wireshark 比较多，两个抓包软件的语法是一样的。&lt;/p&gt;

&lt;h3 id=&#34;5-envoy-官方文档中文版-http-www-servicemesher-com-envoy&#34;&gt;5. &lt;a href=&#34;http://www.servicemesher.com/envoy/&#34; target=&#34;_blank&#34;&gt;Envoy 官方文档中文版&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/envoyproxy11.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Envoy ——为云原生应用而设计、开源的边缘和服务代理、Istio Service Mesh 默认的数据平面，最新官方文档中文版，由 ServiceMesher社区倾情奉献。&lt;/p&gt;

&lt;h3 id=&#34;6-编写和优化go代码-https-github-com-dgryski-go-perfbook-blob-master-performance-zh-md&#34;&gt;6. &lt;a href=&#34;https://github.com/dgryski/go-perfbook/blob/master/performance-zh.md&#34; target=&#34;_blank&#34;&gt;编写和优化Go代码&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;本文档概述了编写高性能Go代码的最佳实践。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;资源&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-vistio-https-github-com-nmnellis-vistio&#34;&gt;1. &lt;a href=&#34;https://github.com/nmnellis/vistio&#34; target=&#34;_blank&#34;&gt;Vistio&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://github.com/nmnellis/vistio/raw/master/documentation/sample.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/vizceral&#34; target=&#34;_blank&#34;&gt;Vizceral&lt;/a&gt; 是 Netflix 发布的一个开源项目，用于近乎实时地监控应用程序和集群之间的网络流量。Vistio 是使用 Vizceral 对 Istio 和网格监控的改进。它利用 Istio Mixer 生成的指标，然后将其输入 Prometheus。Vistio 查询 Prometheus 并将数据存储在本地以允许重播流量。&lt;/p&gt;

&lt;h3 id=&#34;2-一个在线运行代码的网站-https-yxi-io&#34;&gt;2. &lt;a href=&#34;https://yxi.io/&#34; target=&#34;_blank&#34;&gt;一个在线运行代码的网站&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这是一个可以在线运行短代码的网站，前端用 Vuejs 做的，后端用 Docker 提供不同语言的运行环境。目前支持的语言 Bash, C, C++, Go, Haskell, Java, Perl, PHP, Python, Ruby, Rust.&lt;/p&gt;

&lt;h3 id=&#34;3-sofamesh-https-zhuanlan-zhihu-com-p-39931845&#34;&gt;3. &lt;a href=&#34;https://zhuanlan.zhihu.com/p/39931845&#34; target=&#34;_blank&#34;&gt;SOFAMesh&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;蚂蚁金服自主研发的分布式中间件（Scalable Open Financial Architecture，简称 SOFA ）推出的第三轮的开源产品：&lt;code&gt;SOFAMesh&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;SOFAMesh 是基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案。在继承 Istio 强大功能和丰富特性的基础上，为满足大规模部署下的性能要求以及应对落地实践中的实际情况，有如下改进：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;采用 Golang 编写的 MOSN 取代 Envoy&lt;/li&gt;
&lt;li&gt;合并Mixer到数据平面以解决性能瓶颈&lt;/li&gt;
&lt;li&gt;增强 Pilot 以实现更灵活的服务发现机制&lt;/li&gt;
&lt;li&gt;增加对 SOFA RPC、Dubbo 的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-rio-https-github-com-ibuildthecloud-rio&#34;&gt;4. &lt;a href=&#34;https://github.com/ibuildthecloud/rio&#34; target=&#34;_blank&#34;&gt;rio&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我也不知道这玩意儿到底是个什么东西，据项目 README 介绍，这是个和 Docker 一样有趣的东西，而且是一种新奇的技术，像 service mesh 一样。&lt;/p&gt;

&lt;h3 id=&#34;5-nabla-containers-https-nabla-containers-github-io&#34;&gt;5. &lt;a href=&#34;https://nabla-containers.github.io/&#34; target=&#34;_blank&#34;&gt;Nabla containers&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一种新型容器，专门为主机上的强隔离而设计。&lt;/p&gt;

&lt;h3 id=&#34;6-golb-https-github-com-onestraw-golb&#34;&gt;6. &lt;a href=&#34;https://github.com/onestraw/golb&#34; target=&#34;_blank&#34;&gt;golb&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/golb.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Go 语言编写的新型负载均衡器。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-欢迎关注-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;欢迎关注&lt;/p&gt;&lt;/h2&gt;

&lt;p&gt;该系列每周六发布，同步更新在我的&lt;a href=&#34;https://www.yangcs.net/&#34; target=&#34;_blank&#34;&gt;个人博客&lt;/a&gt;和微信公众号上。&lt;/p&gt;

&lt;p&gt;微信搜索 “云原生实验室” 或者扫描二维码即可关注。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>干货与湿货分享第1期</title>
      <link>https://www.yangcs.net/posts/weekly-1/</link>
      <pubDate>Sat, 14 Jul 2018 05:31:48 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/weekly-1/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;人类社会未来几十年肯定会发生天翻地覆的变化，自从我坚信这一点之后，我就把所有的精力都投在了技术领域。所有的变化从根本上来说都是技术的变革引起的，只有掌握了技术，才有可能应对这些变化。&lt;/p&gt;

&lt;p&gt;我相信未来绝大多数的机会都是技术带来的，虽然其他行业依然可以赚钱，但我仍然觉得最有前景的是技术人员，因为当人工智能爆发以后，必将引发第四次工业革命，未来一定是人工智能在帮你看病和打官司。&lt;/p&gt;

&lt;p&gt;由于技术变化日新月异，新观点新工具层出不穷，让人有点目不暇接。我的私人收藏夹里已经屯了好几吨的货，这个时候我想知识如果不分享，就会变得没有意义。所以决定写成文章分享出来，也许会收获一些志同道合的朋友，将来可以一起做一些有用的事情。&lt;/p&gt;

&lt;p&gt;这是《干货分享》系列的第一期，主要记录过去一周我所见到的听到的值得分享的东西，这里只涉及技术，不涉及其他领域。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-新闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;新闻&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-paypal-向已故女子发账号违规通知-http-jandan-net-2018-07-14-paypal-terms-html&#34;&gt;1. &lt;a href=&#34;http://jandan.net/2018/07/14/paypal-terms.html&#34; target=&#34;_blank&#34;&gt;PayPal 向已故女子发账号违规通知&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://img.jandan.net/news/2018/07/dbf68dc1b4f586fa112e7d130d790eb8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;PayPal 最近遭遇了一起让无数网友感到愤怒的公关危机，事件起因是该公司竟然向一位已故女士发去了一封信件，解释她的死亡违反了帐户持有人相关的政策。她的丈夫还没从失去爱妻的悲痛中缓过来，又遇到了这么一件丧心病狂的事情。周二的时候，Howard Durdle 怒而将该文件发到 Twitter 和 Facebook 等社群上。&lt;/p&gt;

&lt;h3 id=&#34;2-google-chrome-浏览器将带来新面孔-https-imcn-me-html-y2018-33653-html&#34;&gt;2. &lt;a href=&#34;https://imcn.me/html/y2018/33653.html&#34; target=&#34;_blank&#34;&gt;Google Chrome 浏览器将带来新面孔&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://imcn.me/wp-content/uploads/2018/07/chrome-new-look-macos.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;无论是经历了技术更迭还是审美升级，谷歌 Chrome 浏览器的用户界面依然巍然不动，多年来都保存同一个样式。但是改变很快就会来了，这两日谷歌透露，预计将于 9 月 2 号（Chrome 的生日）将 Material Design 作为正式版 Chrome 的默认用户界面，视觉重新设计基于更圆、更柔和，更具触感的 Material Design 2（在Android P 中完全展示并且与 Chrome OS 桌面零散地结合）。&lt;/p&gt;

&lt;h3 id=&#34;3-htc-首款区块链手机-exodus-正式开放登记-https-cn-engadget-com-2018-07-10-htc-exodus-registration&#34;&gt;3. &lt;a href=&#34;https://cn.engadget.com/2018/07/10/htc-exodus-registration/&#34; target=&#34;_blank&#34;&gt;HTC 首款区块链手机 Exodus 正式开放登记&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://o.aolcdn.com/images/dims?thumbnail=600%2C400&amp;amp;quality=80&amp;amp;image_uri=https%3A%2F%2Fs.aolcdn.com%2Fhss%2Fstorage%2Fmidas%2Fc00a959b6f5784ba6ef5451cf350cc93%2F206517826%2Fdims.jpg&amp;amp;client=cbc79c14efcebee57402&amp;amp;signature=dd0892fd01c1d886694e61e2704ce82836f94b24&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;阵子在 U12+ 的发布会之前，HTC 突然再透露了他们正准备另一台全新的手机产品 Exodus，这是一台趁着近年科技界对区块链技术的追求而生的区块链手机。今天 HTC 再释出更多有关这台 Exodus 的信息，而且也在今天正式开放登记计划，让有兴趣的朋友预约登记，抢先在今年的第三季体验这台 Exodus 手机。&lt;/p&gt;

&lt;h3 id=&#34;4-日本第二次私人火箭发射失败-https-cn-engadget-com-2018-07-01-japan-interstellar-private-rocket-crash&#34;&gt;4. &lt;a href=&#34;https://cn.engadget.com/2018/07/01/japan-interstellar-private-rocket-crash/&#34; target=&#34;_blank&#34;&gt;日本第二次私人火箭发射失败&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://s.aolcdn.com/hss/storage/midas/ca779bdc8b01018cd047f96dc1e46bf1/206496734/this-combo-of-video-grabs-provided-by-interstellars-technologies-the-picture-id987515668.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;由颇具争议的企业家堀江贵文于 2005 年创立的 Interstellar Technologies 公司，和 SpaceX、Blue Origins、Rocket Labs 等有不少相似之处，都希望在新一代的私人太空领域中占据立足之地。然而和这三者不同的是，虽然 Interstellar Technologies 发射的是一枚相对简单得多的火箭（仅长 10m、直径 50cm），发射高度也只是勉强构到 100km 线，并不能进入轨道，但到目前为止还没有成功的记录。&lt;/p&gt;

&lt;p&gt;第一次试射发生在 2017 年，当时的 Momo 火箭在发射 66 秒后因为失去与地面的联系而自毁，只达到了 20km 的高度，而这次更是在发射后没几秒便又垂直落下，以一团火球告终。除了从视频中可以很明显看出发射后没三秒引擎就突然「没力」之外，Interstellar Technologies 没有给更进一步的原因或说明。&lt;/p&gt;

&lt;h3 id=&#34;5-苹果前华人工程师窃密被捕-http-www-sohu-com-a-240500768-610300&#34;&gt;5. &lt;a href=&#34;http://www.sohu.com/a/240500768_610300&#34; target=&#34;_blank&#34;&gt;苹果前华人工程师窃密被捕&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cdn-fs.d1ev.com/d/file/custom/30018/file/201807/1531280057974180.jpg!w720&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;7月7日，一名曾在苹果自动驾驶汽车项目工作的工程师在加州圣何塞机场准备登机飞往中国时，被美国联邦调查局（FBI）的执法人员逮捕。据知情人士称，这位名为 Xiaolang Zhang（张晓浪）的工程师跳槽入职国内创业公司小鹏汽车。&lt;/p&gt;

&lt;p&gt;根据提交给加州北区法院的文件，美国联邦调查局于本周指控苹果前员工 Xiaolang Zhang 窃取商业机密。而法院文件显示，目前共有5000名员工在为苹果的自动驾驶汽车项目工作。&lt;/p&gt;

&lt;h3 id=&#34;6-特斯拉计划在上海建全资工厂-https-www-ifanr-com-1063536&#34;&gt;6. &lt;a href=&#34;https://www.ifanr.com/1063536&#34; target=&#34;_blank&#34;&gt;特斯拉计划在上海建全资工厂&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://images.ifanr.cn/wp-content/uploads/2018/07/WechatIMG4071531228156_.pic_hd.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在特斯拉宣布将在上海临港地区独资建厂的两天后，CEO 埃隆·马斯克低调访华。此行分别敲定了上海建厂和北京建立科技创新中心事宜，随后他就匆匆离开。&lt;/p&gt;

&lt;p&gt;本项目直接涵盖了电动车最重要的研发、制造、销售三大环节，计划兴建的有特斯拉（上海）有限公司和特斯拉（上海）电动汽车研发创新中心以及代号 Gigafactory 3 的特斯拉超级工厂。&lt;/p&gt;

&lt;p&gt;虽然马老板行踪保密至极，没透露一丝风声，不过，还是有人记录下了马老板在华的奇妙经历。&lt;/p&gt;

&lt;p&gt;比如，街头吃煎饼果子：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/s_c98cb49fa3c7472ca75a3b7b8c2cc75f.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-工具-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;工具&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-baidupcs-go-https-github-com-iikira-baidupcs-go&#34;&gt;1. &lt;a href=&#34;https://github.com/iikira/BaiduPCS-Go&#34; target=&#34;_blank&#34;&gt;BaiduPCS-Go&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;关于百度网盘大家都是又爱又恨吧，毕竟要拿来存东西，分享什么的，但是这个下载 限速实在是难以忍受呀。这里给大家介绍一款全平台通用的下载神器：&lt;code&gt;BaiduPCS--go&lt;/code&gt;。使用 Go 语言编写，支持网盘内目录 (文件夹) 下载, 支持多个文件或目录下载, 支持断点续传和高并发高速下载。&lt;/p&gt;

&lt;h3 id=&#34;2-ivideo-https-github-com-phobal-ivideo&#34;&gt;2. &lt;a href=&#34;https://github.com/phobal/ivideo&#34; target=&#34;_blank&#34;&gt;ivideo&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一个可以观看国内主流视频平台所有视频的客户端（Mac、Windows、Linux），包括 VIP 资源。&lt;/p&gt;

&lt;h3 id=&#34;3-dochub-https-github-com-truthhun-dochub&#34;&gt;3. &lt;a href=&#34;https://github.com/TruthHun/DocHub&#34; target=&#34;_blank&#34;&gt;DocHub&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;参考百度文库，使用Beego（Golang）开发的开源文库系统。&lt;/p&gt;

&lt;h3 id=&#34;4-annie-https-github-com-iawia002-annie&#34;&gt;4. &lt;a href=&#34;https://github.com/iawia002/annie&#34; target=&#34;_blank&#34;&gt;annie&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一个可以下载 YouTube 视频的命令行工具，与 &lt;a href=&#34;https://github.com/soimort/you-get&#34; target=&#34;_blank&#34;&gt;youget&lt;/a&gt; 类似，但使用 Go 语言编写，除了支持 YouTube 之外，还可以下载国内各大视频网站的视频&lt;/p&gt;

&lt;h3 id=&#34;5-painter-https-github-com-kujiale-mobile-painter&#34;&gt;5. &lt;a href=&#34;https://github.com/Kujiale-Mobile/Painter&#34; target=&#34;_blank&#34;&gt;Painter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;小程序生成图片库，轻松通过 json 方式绘制一张可以发到朋友圈的图片&lt;/p&gt;

&lt;h3 id=&#34;6-taro-https-github-com-nervjs-taro&#34;&gt;6. &lt;a href=&#34;https://github.com/NervJS/taro&#34; target=&#34;_blank&#34;&gt;taro&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。&lt;/p&gt;

&lt;h3 id=&#34;7-termtosvg-https-github-com-nbedos-termtosvg&#34;&gt;7. &lt;a href=&#34;https://github.com/nbedos/termtosvg&#34; target=&#34;_blank&#34;&gt;termtosvg&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;将终端会话记录为 SVG 动画&lt;/p&gt;

&lt;h3 id=&#34;8-jib-http-github-com-googlecontainertools-jib&#34;&gt;8. &lt;a href=&#34;http://github.com/GoogleContainerTools/jib&#34; target=&#34;_blank&#34;&gt;Jib&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;谷歌开源的 Java 应用容器生成工具，不用写 Dockerfile，构造过程中自动生成一个 Docker 容器。&lt;/p&gt;

&lt;h3 id=&#34;9-简悦-simpread-https-github-com-kenshin-simpread&#34;&gt;9. &lt;a href=&#34;https://github.com/Kenshin/simpread&#34; target=&#34;_blank&#34;&gt;简悦 ( SimpRead ) &lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://raw.githubusercontent.com/521xueweihan/HelloGitHub/master/content/27/img/simpread-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;让你瞬间进入沉浸式阅读的扩展，还原阅读的本质，提升你的阅读体验。使用它可以为你剔除页面上无关的干扰信息，让用户专注于阅读主要的内容。通过这个项目，还可以学习如何开发 Chrome 扩展。&lt;/p&gt;

&lt;h3 id=&#34;10-aesma-http-www-aesma-cn&#34;&gt;10. &lt;a href=&#34;http://www.aesma.cn/&#34; target=&#34;_blank&#34;&gt;Aesma&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;说到网盘离线下载，115网盘和百度网盘肯定是第一时间进入你脑海里的网盘，毕竟是大公司，功能还是非常不错的，离线下载速度杠杠的，基本秒下载，然后可以直接在线观看。但唯一的遗憾就是。。。太。。。贵。。。年费会员接近300元的价格，还是让不少喜欢看片的伙伴们在充值和不充值之间犹豫徘徊。&lt;/p&gt;

&lt;p&gt;百度网盘提供免费BT离线下载功能，但在线观看速度会有一定的限制，且很多资源无法离线，版权或其他原因。&lt;/p&gt;

&lt;p&gt;最近出了一个 Aesma 阿斯离线云网盘，官网自称可能是目前最好用的离线下载工具，看来还是有几把刷子。据悉，Aesma 是破解的的 115 的数据流，所以离线下载和在线播放性能还是毋庸置疑的。&lt;/p&gt;

&lt;p&gt;网盘之前可以免费试用，不过现在推广期已过，开始收费了，但费用并不高，经济会员仅仅6元每月，普通会员10元每月，最贵的高级会员也就16元每月，还是比115或者百度网盘便宜了不少。更多详情大家可以自行探索。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-教程-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;教程&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-deeplearningbook读书笔记-https-github-com-exacity-simplified-deeplearning&#34;&gt;1. &lt;a href=&#34;https://github.com/exacity/simplified-deeplearning&#34; target=&#34;_blank&#34;&gt;DeepLearningBook读书笔记&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DeepLearningBook是目前第一本系统和完整的介绍深度学习的书籍，其作者包括深度学习领域的奠基人、处于研究生涯中期的领域中坚、更有近年来涌现的新星，非常适合搭建理论基础。但是直至去年，本书只有英文原版，对于大多数开发者来说，啃一本800页7*9英寸的书籍，难度可想而知。 好消息是，在翻译人员的不懈努力下，DeepLearningBook中文版也已在GitHub上公开，中文翻译版已经由人民邮电出版社出版。&lt;/p&gt;

&lt;h3 id=&#34;2-go语言高级编程-https-github-com-chai2010-advanced-go-programming-book&#34;&gt;2. &lt;a href=&#34;https://github.com/chai2010/advanced-go-programming-book&#34; target=&#34;_blank&#34;&gt;Go语言高级编程&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;《Go语言高级编程》该书针对 Go 语言有一定经验，想更加深入了解 Go 语言各种高级用法的开发人员。&lt;/p&gt;

&lt;h3 id=&#34;3-后端架构师技术图谱-https-github-com-xingshaocheng-architect-awesome&#34;&gt;3. &lt;a href=&#34;https://github.com/xingshaocheng/architect-awesome&#34; target=&#34;_blank&#34;&gt;后端架构师技术图谱&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;后端架构师的技术图谱，非常全面，从数据结构、常用算法到分布式系统设计模式应有尽有。&lt;/p&gt;

&lt;h3 id=&#34;4-深度学习框架-pytorch-入门与实践-https-github-com-chenyuntc-pytorch-book&#34;&gt;4. &lt;a href=&#34;https://github.com/chenyuntc/pytorch-book&#34; target=&#34;_blank&#34;&gt;深度学习框架 PyTorch：入门与实践&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;书籍《深度学习框架 PyTorch：入门与实践》的示例代码，可以作为一个独立的 PyTorch 入门指南和教程。内容结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://raw.githubusercontent.com/521xueweihan/HelloGitHub/master/content/25/img/pytorch-book-show-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-自己动手做聊天机器人-https-github-com-warmheartli-chatbotcourse&#34;&gt;5. &lt;a href=&#34;https://github.com/warmheartli/ChatBotCourse&#34; target=&#34;_blank&#34;&gt;自己动手做聊天机器人&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;该项目介绍了如何自己动手做聊天机器人。全面地介绍了所需要的技术：自然语言识别、分词、语料库、机器学习等，包含所需的 Java 和 Python 代码。&lt;/p&gt;

&lt;h3 id=&#34;6-free-programming-books-zh-cn-https-github-com-justjavac-free-programming-books-zh-cn&#34;&gt;6. &lt;a href=&#34;https://github.com/justjavac/free-programming-books-zh_CN&#34; target=&#34;_blank&#34;&gt;free-programming-books-zh_CN&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;免费的计算机编程类中文书籍。&lt;/p&gt;

&lt;h3 id=&#34;7-golang-区块链教程-https-github-com-liuchengxu-blockchain-tutorial&#34;&gt;7. &lt;a href=&#34;https://github.com/liuchengxu/blockchain-tutorial&#34; target=&#34;_blank&#34;&gt;Golang 区块链教程&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;区块链不仅仅是计算机科学，还涉及了政治经济制度，社会分工协作等等很多方面，本教程的关注点不仅在于深度，更在于其广度，更多是站在研究的角度，而非仅仅是一个程序员的视角。&lt;/p&gt;

&lt;h3 id=&#34;8-prometheus-操作指南-云原生监控之道-https-github-com-yunlzheng-prometheus-book&#34;&gt;8. &lt;a href=&#34;https://github.com/yunlzheng/prometheus-book&#34; target=&#34;_blank&#34;&gt;Prometheus 操作指南：云原生监控之道&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Prometheus是一个开源的完整监控解决方案，其对传统监控系统的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。本教程应该是国内第一个全面剖析 Prometheus 的教程，从原理到实战。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;资源&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-telegramgroup-https-github-com-itgoyo-telegramgroup&#34;&gt;1. &lt;a href=&#34;https://github.com/itgoyo/TelegramGroup&#34; target=&#34;_blank&#34;&gt;TelegramGroup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Telegram 群合集，收集了非常全面好玩的 telegram 群。&lt;/p&gt;

&lt;h3 id=&#34;2-飞流直播-http-chaochaolive-icntv-xyz-channel-movie&#34;&gt;2. &lt;a href=&#34;http://chaochaolive.icntv.xyz/channel/movie&#34; target=&#34;_blank&#34;&gt;飞流直播&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;海外中文网络电视直播，直接通过浏览器播放。&lt;/p&gt;

&lt;h3 id=&#34;3-factory-images-for-nexus-and-pixel-devices-https-developers-google-com-android-images&#34;&gt;3. &lt;a href=&#34;https://developers.google.com/android/images&#34; target=&#34;_blank&#34;&gt;Factory Images for Nexus and Pixel Devices&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;安卓原生镜像下载地址，包括 Nexus 和 Pixel 系列。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-欢迎关注-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;欢迎关注&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;该系列每周六发布，同步更新在我的&lt;a href=&#34;https://www.yangcs.net/&#34; target=&#34;_blank&#34;&gt;个人博客&lt;/a&gt;和微信公众号上。&lt;/p&gt;

&lt;p&gt;微信搜索 &lt;strong&gt;“云原生实验室”&lt;/strong&gt; 或者扫描二维码即可关注。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Envoy 熔断器的原理和使用</title>
      <link>https://www.yangcs.net/posts/circuit-breaking/</link>
      <pubDate>Fri, 13 Jul 2018 09:22:49 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/circuit-breaking/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在微服务领域，各个服务之间经常会相互调用。如果某个服务繁忙或者无法响应请求，将有可能引发集群的大规模级联故障，从而造成整个系统不可用，通常把这种现象称为 &lt;span id=&#34;inline-purple&#34;&gt;服务雪崩效应&lt;/span&gt;。为了应对这种情况，可以使用熔断器（circuit breaking）。&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;inline-purple&#34;&gt;熔断器&lt;/span&gt; 是分布式系统的关键组件，默认情况下处于关闭状态，这时请求被允许通过熔断器。它调用失败次数积累，如果当前健康状况低于设定阈值则启动熔断机制，这时请求被禁止通过。这样做可以实现更优雅的故障处理，并在问题被放大之前做出及时的响应。你可以选择在基础架构层面实现熔断机制，但熔断器本身会很容易受到故障的影响。为了更好地实现熔断机制，可以在 Envoy 的网络层面配置熔断器，这样做的好处是 &lt;code&gt;Envoy&lt;/code&gt; 在网络级别强制实现断路，而不必为每个应用程序单独配置或编程。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-熔断器配置-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 熔断器配置&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Envoy 支持各种类型的完全分布式（非协调的）熔断，设置熔断时，需要考虑系统的具体情况，可以通过向 Envoy 的 &lt;code&gt;clusters&lt;/code&gt; 配置项中添加 &lt;code&gt;circuit_breakers&lt;/code&gt; 来为 Envoy 配置熔断器。下面是一个简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;circuit_breakers:
  thresholds:
    - priority: DEFAULT
      max_connections: 1000
      max_requests: 1000
    - priority: HIGH
      max_connections: 2000
      max_requests: 2000
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;thresholds&lt;/span&gt; : 阈值允许我们定义服务响应的流量类型的优先级和限制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;priority&lt;/span&gt; : 优先级是指熔断器如何处理定义为 &lt;code&gt;DEFAULT&lt;/code&gt; 或 &lt;code&gt;HIGH&lt;/code&gt; 的路由。示例中的设置表示将任何不应该在长连接队列中等待的请求设置为 HIGH（例如，用户在购物网站上提交购买请求或保存当前状态的 POST 请求）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;max_connections&lt;/span&gt; : Envoy 将为上游集群中的所有主机建立的最大连接数，默认值是 &lt;code&gt;1024&lt;/code&gt;。实际上，这仅适用于 HTTP/1.1集群，因为 HTTP/2 使用到每个主机的单个连接。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;max_requests&lt;/span&gt; : 在任何给定时间内，集群中所有主机可以处理的最大请求数，默认值也是 1024。实际上，这适用于仅 HTTP/2 集群，因为 HTTP/1.1 集群由最大连接断路器控制。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-id-h2-2-基本的熔断策略-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 基本的熔断策略&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;由于 &lt;code&gt;HTTP/1.1&lt;/code&gt; 协议和 &lt;code&gt;HTTP/2&lt;/code&gt; 协议具有不同的连接行为（HTTP/1.1 : 同一个连接只能处理一个请求；HTTP/2 : 同一个连接能并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级），使用不同协议的集群将各自使用不同的配置项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/1.1 协议&lt;/strong&gt; : 使用 max_connections。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP/2 协议&lt;/strong&gt; ： 使用 max_requests。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个配置项都可以很好地实现熔断机制，主要取决于两个指标：服务的请求/连接数量和请求延时。例如，具有 1000个请求/second 和平均延迟 2 秒的 HTTP/1 服务通常会在任何给定时间内打开 &lt;code&gt;2000&lt;/code&gt; 个连接。由于当存在大量非正常连接时熔断器会启动熔断机制，因此建议将参数 max_connections 的值最少设置为 &lt;code&gt;10 x 2000&lt;/code&gt;，这样当最后 10 秒内的大多数请求未能返回正确的响应时就会打开熔断器。当然，具体的熔断器配置还得取决于系统的负载以及相关服务的具体配置。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-3-高级熔断策略-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 高级熔断策略&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;上面讨论了一些基本的熔断策略，下面将介绍更高级的熔断策略，这些高级熔断策略可以为你的网络基础架构增加更多的弹性。&lt;/p&gt;

&lt;h3 id=&#34;基于延迟设置熔断&#34;&gt;基于延迟设置熔断&lt;/h3&gt;

&lt;p&gt;如上所述，熔断器最常见的用例之一就是预防服务响应过慢但未完全瘫痪时引发的故障。虽然 Envoy 没有直接提供熔断器的延迟配置项，但可以通过自动重试配置项来模拟延迟。自动重试配置项通过 &lt;code&gt;max_retries&lt;/code&gt; 字段定义，表示在任何给定时间内，集群中所有主机可以执行的最大重试次数。&lt;/p&gt;

&lt;h3 id=&#34;基于长连接重试队列设置熔断&#34;&gt;基于长连接重试队列设置熔断&lt;/h3&gt;

&lt;p&gt;由于重试有可能将请求流量增加到两倍以上甚至更多，因此通过 &lt;code&gt;max_retries&lt;/code&gt; 参数可以防止服务因为过多的重试而过载。建议将此参数的值设置为服务通常在 10 秒窗口中处理的请求总数的一小部分，最好不要将重试次数设置为与服务在 10 秒窗口中处理的请求总数差不多。&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>通过控制平面提供路由</title>
      <link>https://www.yangcs.net/posts/routing-with-a-control-plane/</link>
      <pubDate>Fri, 06 Jul 2018 06:16:02 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/routing-with-a-control-plane/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;当微服务集群规模非常庞大时，控制平面包含了大量的 Envoy 配置项和基础设施状态，这时最好将数据平面与控制平面分离。控制平面最主要的功能包括自动重试和&lt;a href=&#34;https://www.yangcs.net/posts/integrating-service-discovery-with-envoy/&#34; target=&#34;_blank&#34;&gt;集成服务发现&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;单独创建控制平面的最大优势之一是可以为路由配置提供统一的来源。传统架构的路由定义分散存储在 Web 服务器的配置文件、负载均衡器配置文件和特定应用程序的配置中（如 &lt;code&gt;routes.rb&lt;/code&gt;），使用单独的控制平面可以集中所有的路由配置，使它们更易于更改和管理，同时也为应用的迁移和发布提供了更高的灵活性。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-通过-rds-提供路由-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 通过 RDS 提供路由&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Envoy 的动态配置功能允许通过路由发现服务（RDS）的 &lt;code&gt;API&lt;/code&gt; 来动态获取路由配置。控制平面通过 RDS 提供路由配置，将 &lt;strong&gt;域名+路径&lt;/strong&gt; 映射到 Envoy 中的某个集群（cluster），而实际的流量控制由 Envoy 实例来完成。&lt;/p&gt;

&lt;p&gt;这里是一个使用 RDS 来动态获取路由的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version_info: &amp;quot;0&amp;quot;
resources:
- &amp;quot;@type&amp;quot;: type.googleapis.com/envoy.api.v2.RouteConfiguration
  name: local_route
  virtual_hosts:
  - name: local_service
    domains: [&amp;quot;*&amp;quot;]
    routes:
    - match: { prefix: &amp;quot;/&amp;quot; }
      route: { cluster: some_service }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开源项目 &lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34;&gt;go-control-plane&lt;/a&gt;，&lt;a href=&#34;https://istio.io/docs/concepts/traffic-management/pilot.html&#34; target=&#34;_blank&#34;&gt;Istio Pilot&lt;/a&gt; 和 商业项目 &lt;a href=&#34;http://turbinelabs.io/product&#34; target=&#34;_blank&#34;&gt;Houston&lt;/a&gt; 都提供了 RDS 的 API，Envoy 官方文档也定义了一个&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview.html#v2-grpc-streaming-endpoints&#34; target=&#34;_blank&#34;&gt;完整的 RDS 规范&lt;/a&gt;。RDS 规范只是一种流量传输机制，如何对路由进行管理还是要取决于你。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-2-路由定义的最佳实践-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 路由定义的最佳实践&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;当你的系统中有数千个 Envoy 实例时，应该选择控制平面来作为所有路由的统一来源。客户端请求可以直接来自用户、内部服务或者来自不同的云区域，因此最好使用 Envoy 来处理这些不同的网络拓扑（例如，作为客户流量的前端代理以及内部流量的服务网格），虽然流量来自不同的方向，但它们的行为都是相似的。&lt;/p&gt;

&lt;p&gt;为了扩展单个系统的路由定义，通常需要遵循以下三个关键原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将路由视为数据，而不是配置&lt;/li&gt;
&lt;li&gt;将控制权分配给具有 &lt;code&gt;ACL&lt;/code&gt; 权限的团队&lt;/li&gt;
&lt;li&gt;使用审计日志和回滚操作来管理路由的更改&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;将路由视为数据&#34;&gt;将路由视为数据&lt;/h3&gt;

&lt;p&gt;将路由视为一组相互关联的服务的数据可以防止发生冲突，同时确保了其语义的正确性。虽然像 &lt;code&gt;Istio&lt;/code&gt; 这样的工具可以很容易地编写基于 &lt;code&gt;YAML&lt;/code&gt; 配置文件的路由，但是在数千行 YAML 文件中管理数百条路由很难保证每个定义都是有效的路由。或许你也想过使用版本控制来管理这些配置文件，但如果合并分支时发生致命错误将会导致灾难性的后果（如路由丢失或通过 API 重写）。&lt;/p&gt;

&lt;p&gt;实际上，从静态配置文件转移到动态配置文件是在大规模集群中使用 Envoy 的第一步。为了能够将 Envoy 投入生产，建议至少使用像 &lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34;&gt;go-control-plane&lt;/a&gt; 这样实现了 &lt;code&gt;xDS&lt;/code&gt; 的控制平面统一提供路由配置。通过将路由的来源转移到 &lt;code&gt;RDS API&lt;/code&gt; 背后，可以实现路由的并发更新，同时也可以防止对路由进行无意义的更新。&lt;/p&gt;

&lt;h3 id=&#34;将控制权分配给具有-acl-权限的团队&#34;&gt;将控制权分配给具有 &lt;code&gt;ACL&lt;/code&gt; 权限的团队&lt;/h3&gt;

&lt;p&gt;通过对流量进行管控可以解锁更强大的工作流程（如蓝绿发布和增量迁移），同时也能让服务团队确保各个服务之间的路由是安全可用的。你可以根据需要来隐藏管控区域之外的路由以防止误点击或者发生意外事故，你也可以完全禁止某些成员修改路由。&lt;/p&gt;

&lt;h3 id=&#34;管理路由的更改&#34;&gt;管理路由的更改&lt;/h3&gt;

&lt;p&gt;了解路由何时被更改以及被谁更改是极其重要的，许多团队会发现，在他们分配好了定义路由的任务之后，实际路由的数量将会超出他们的预期，因此为了保险起见，最好对路由的更改进行记录。例如，&lt;code&gt;master&lt;/code&gt; 分支中的自动蓝绿发布应该打上最后一个合并分支的人的标签。&lt;/p&gt;

&lt;p&gt;为了更好地管理路由，团队内部必须要知道如何在两个时间点之间更改路由以及如何在必要时将其回滚，同时最好将这些操作收集到监控系统中。当你需要进一步优化时，这些操作记录是很有价值的（例如 git 历史记录在编写新代码时很有帮助）。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
  </channel>
</rss>
