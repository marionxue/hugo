<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ryan Yang</title>
    <link>https://www.yangcs.net/</link>
    <description>Recent content on Ryan Yang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 23 Jan 2018 08:26:58 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux全局智能分流方案</title>
      <link>https://www.yangcs.net/posts/linux-circumvent/</link>
      <pubDate>Tue, 23 Jan 2018 08:26:58 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/linux-circumvent/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本来我是决定不再写这样的文章了的。但是呢，最近连续配置了两次 &lt;code&gt;ArchLinux&lt;/code&gt;，在配置这种东西的时候连续撞到了同样的坑，加上这段时间经常有人问我关于 &lt;code&gt;Linux&lt;/code&gt; 下的 &lt;code&gt;shadowsocks&lt;/code&gt; 的问题，所以我想了想还是写一篇记录一下吧，也免得自己以后再忘记了。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这里有两种方案，都可以实现全局智能分流。第一种方案的思路是使用 &lt;code&gt;ipset&lt;/code&gt; 载入 &lt;code&gt;chnroute&lt;/code&gt; 的 &lt;code&gt;IP&lt;/code&gt; 列表并使用 &lt;code&gt;iptables&lt;/code&gt; 实现带自动分流国内外流量的全局代理。为什么不用 &lt;code&gt;PAC&lt;/code&gt; 呢？因为 &lt;code&gt;PAC&lt;/code&gt; 这种东西只对浏览器有用。难道你在浏览器之外就不需要科学上网了吗？反正我是不信的……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;font color=Blue&gt;本教程所用系统为 &lt;code&gt;Archlinux&lt;/code&gt;，其他发型版类似，请自行参考相关资料。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-margin-bottom-2em-margin-right-5px-padding-8px-15px-letter-spacing-2px-background-image-linear-gradient-to-right-bottom-rgb-0-188-212-rgb-63-81-181-background-color-rgb-63-81-181-color-rgb-255-255-255-border-left-10px-solid-rgb-51-51-51-border-radius-5px-text-shadow-rgb-102-102-102-1px-1px-1px-box-shadow-rgb-102-102-102-1px-1px-2px-1-通过-iptables-实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;margin-bottom:2em; margin-right: 5px; padding: 8px 15px; letter-spacing: 2px; background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181)); background-color: rgb(63, 81, 181); color: rgb(255, 255, 255); border-left: 10px solid rgb(51, 51, 51); border-radius:5px; text-shadow: rgb(102, 102, 102) 1px 1px 1px; box-shadow: rgb(102, 102, 102) 1px 1px 2px;&#34;&gt;1. 通过 iptables 实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-1-安装相关软件&#34;&gt;1.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;shadowsocks-libev&lt;/li&gt;
&lt;li&gt;ipset&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S shadowsocks-libev ipset
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-配置shadowsocks-libev-略过&#34;&gt;1.2 配置shadowsocks-libev（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;1-3-获取中国ip段&#34;&gt;1.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-4-创建启动和关闭脚本&#34;&gt;1.4 创建启动和关闭脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /home/yang/bin/shadowsocks/ss-up.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

SOCKS_SERVER=$SERVER_IP # SOCKS 服务器的 IP 地址
# Setup the ipset
ipset -N chnroute hash:net maxelem 65536

for ip in $(cat &#39;/home/yang/bin/路由表/cn_rules.conf&#39;); do
  ipset add chnroute $ip
done

# 在nat表中新增一个链，名叫：SHADOWSOCKS
iptables -t nat -N SHADOWSOCKS

# Allow connection to the server
iptables -t nat -A SHADOWSOCKS -d $SOCKS_SERVER -j RETURN

# Allow connection to reserved networks
iptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURN
iptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN

# Allow connection to chinese IPs
iptables -t nat -A SHADOWSOCKS -p tcp -m set --match-set chnroute dst -j RETURN
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A SHADOWSOCKS -p icmp -m set --match-set chnroute dst -j RETURN

# Redirect to Shadowsocks
# 把1081改成你的shadowsocks本地端口
iptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-port 1081
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A SHADOWSOCKS -p icmp -j REDIRECT --to-port 1081

# 将SHADOWSOCKS链中所有的规则追加到OUTPUT链中
iptables -t nat -A OUTPUT -p tcp -j SHADOWSOCKS
# 如果你想对 icmp 协议也实现智能分流，可以加上下面这一条
# iptables -t nat -A OUTPUT -p icmp -j SHADOWSOCKS

# 内网流量流经 shadowsocks 规则链
iptables -t nat -A PREROUTING -s 192.168/16 -j SHADOWSOCKS
# 内网流量源NAT
iptables -t nat -A POSTROUTING -s 192.168/16 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这是在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前执行的脚本，用来设置 &lt;code&gt;iptables&lt;/code&gt; 规则，对全局应用代理并将 &lt;code&gt;chnroute&lt;/code&gt; 导入 &lt;code&gt;ipset&lt;/code&gt; 来实现自动分流。注意要把服务器 &lt;code&gt;IP&lt;/code&gt; 和本地端口相关的代码全部替换成你自己的。
&amp;emsp;&amp;emsp;这里就有一个坑了，就是在把 &lt;code&gt;chnroute.txt&lt;/code&gt; 加入 &lt;code&gt;ipset&lt;/code&gt; 的时候。因为 &lt;code&gt;chnroute.txt&lt;/code&gt; 是一个 &lt;code&gt;IP&lt;/code&gt; 段列表，而中国持有的 &lt;code&gt;IP&lt;/code&gt; 数量上还是比较大的，所以如果使用 &lt;code&gt;hash:ip&lt;/code&gt; 来导入的话会使内存溢出。我在第二次重新配置的时候就撞进了这个大坑……
&amp;emsp;&amp;emsp;但是你也不能尝试把整个列表导入 &lt;code&gt;iptables&lt;/code&gt;。虽然导入 &lt;code&gt;iptables&lt;/code&gt; 不会导致内存溢出，但是 &lt;code&gt;iptables&lt;/code&gt; 是线性查表，即使你全部导入进去，也会因为低下的性能而抓狂。
&lt;br \&gt;
然后再创建 &lt;code&gt;/home/yang/bin/shadowsocks/ss-down.sh&lt;/code&gt;, 这是用来清除上述规则的脚本，比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# iptables -t nat -D OUTPUT -p icmp -j SHADOWSOCKS
iptables -t nat -D OUTPUT -p tcp -j SHADOWSOCKS
iptables -t nat -F SHADOWSOCKS
iptables -t nat -X SHADOWSOCKS
ipset destroy chnroute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x ss-up.sh
$ chmod +x ss-down.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-5-配置ss-redir服务&#34;&gt;1.5 配置ss-redir服务&lt;/h3&gt;

&lt;p&gt;首先，默认的 &lt;code&gt;ss-local&lt;/code&gt; 并不能用来作为 &lt;code&gt;iptables&lt;/code&gt; 流量转发的目标，因为它是 &lt;code&gt;socks5&lt;/code&gt; 代理而非透明代理。我们至少要把 &lt;code&gt;systemd&lt;/code&gt; 执行的程序改成 &lt;code&gt;ss-redir&lt;/code&gt;。其次，上述两个脚本还不能自动执行，必须让 &lt;code&gt;systemd&lt;/code&gt; 分别在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前和关闭之后将脚本执行，这样才能自动配置好 &lt;code&gt;iptables&lt;/code&gt; 规则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/lib/systemd/system/shadowsocks-libev@.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]
Description=Shadowsocks-Libev Client Service
After=network.target

[Service]
User=root
CapabilityBoundingSet=~CAP_SYS_ADMIN
ExecStart=
ExecStartPre=/home/yang/bin/shadowsocks/ss-up.sh
ExecStart=/usr/bin/ss-redir -u -c /etc/%i.json
ExecStopPost=/home/yang/bin/shadowsocks/ss-down.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-6-配置智能-dns-服务&#34;&gt;1.6 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;完成了以上工作之后是不是就可以实现全局科学上网了呢？答案是否定的，我们还有最后一项工作需要完成，那就是解决 &lt;code&gt;DNS&lt;/code&gt; 污染问题。如果你不知道什么是 &lt;code&gt;DNS&lt;/code&gt; 污染，我可以简单地给你普及一下：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 污染是一种让一般用户由于得到虚假目标主机 &lt;code&gt;IP&lt;/code&gt; 而不能与其通信的方法，是一种 &lt;code&gt;DNS&lt;/code&gt; 缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的 &lt;code&gt;DNS&lt;/code&gt; 查询没有任何认证机制，而且 &lt;code&gt;DNS&lt;/code&gt; 查询通常基于的 &lt;code&gt;UDP&lt;/code&gt; 是无连接不可靠的协议，因此 &lt;code&gt;DNS&lt;/code&gt; 的查询非常容易被篡改，通过对 &lt;code&gt;UDP&lt;/code&gt; 端口 53 上的 &lt;code&gt;DNS&lt;/code&gt; 查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 污染症状：目前一些被禁止访问的网站很多就是通过 &lt;code&gt;DNS&lt;/code&gt; 污染来实现的，例如 &lt;code&gt;YouTube&lt;/code&gt;、&lt;code&gt;Facebook&lt;/code&gt; 等网站。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应对dns污染的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;DNS&lt;/code&gt; 污染，可以说，个人用户很难单单靠设置解决，通常可以使用 &lt;code&gt;VPN&lt;/code&gt; 或者域名远程解析的方法解决，但这大多需要购买付费的 &lt;code&gt;VPN&lt;/code&gt; 或 &lt;code&gt;SSH&lt;/code&gt; 等&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;Hosts&lt;/code&gt; 的方法，手动设置域名正确的 &lt;code&gt;IP&lt;/code&gt; 地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dns&lt;/code&gt; 加密解析：&lt;a href=&#34;https://dnscrypt.org/&#34; target=&#34;_blank&#34;&gt;DNSCrypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;忽略 &lt;code&gt;DNS&lt;/code&gt; 投毒污染小工具：&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy&#34; target=&#34;_blank&#34;&gt;Pcap_DNSProxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们选择用 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 来解决这个问题，以前用的是 &lt;code&gt;Pdnsd + Dnsmasq&lt;/code&gt; 组合， 后来发现 &lt;code&gt;TCP&lt;/code&gt; 请求效率太低加上家里网络与那些国外的 &lt;code&gt;DNS&lt;/code&gt; 丢包实在是严重， 所以打算用 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 代替 &lt;code&gt;Pdnsd&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;Pcap_DNSProxy&lt;/code&gt; 的详细介绍，可以参考:
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy&#34; target=&#34;_blank&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy&lt;/a&gt;
安装过程可以参考：
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe_Linux.zh-Hans.txt&#34; target=&#34;_blank&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe_Linux.zh-Hans.txt&lt;/a&gt;
更详细的使用说明可以参考：
&lt;a href=&#34;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe.zh-Hans.txt&#34; target=&#34;_blank&#34;&gt;https://github.com/chengr28/Pcap_DNSProxy/blob/master/Documents/ReadMe.zh-Hans.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要重点强调一些需要注意的配置项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DNS&lt;/code&gt; - 境外域名解析参数区域（这是最关键的一项配置）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[DNS]
# 这里一定要填 IPv4 + TCP！！！表示只使用 TCP 协议向境外远程 DNS 服务器发出请求
Outgoing Protocol = IPv4 + TCP
# 建议当系统使用全局代理功能时启用，程序将除境内服务器外的所有请求直接交给系统而不作任何过滤等处理，系统会将请求自动发往远程服务器进行解析
Direct Request = IPv4
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Local DNS&lt;/code&gt; - 境内域名解析参数区域&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Local DNS]
# 发送请求到境内 DNS 服务器时所使用的协议
Local Protocol = IPv4 + UDP
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Addresses&lt;/code&gt; - 普通模式地址区域&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Addresses]
...
...
# IPv4 主要境外 DNS 服务器地址
IPv4 Main DNS Address = 8.8.4.4:53
# IPv4 备用境外 DNS 服务器地址
IPv4 Alternate DNS Address = 8.8.8.8:53|208.67.220.220:443|208.67.222.222:5353
# IPv4 主要境内 DNS 服务器地址，用于境内域名解析，推荐使用 onedns
IPv4 Local Main DNS Address = 112.124.47.27:53
# IPv4 备用境内 DNS 服务器地址，用于境内域名解析
IPv4 Local Alternate DNS Address = 114.215.126.16:53
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-7-配置系统-dns-服务器设置&#34;&gt;1.7 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可参见 &lt;a href=&#34;https://developers.google.com/speed/public-dns/docs/using&#34; target=&#34;_blank&#34;&gt;https://developers.google.com/speed/public-dns/docs/using&lt;/a&gt; 中 &lt;code&gt;Changing your DNS servers settings&lt;/code&gt; 中 &lt;code&gt;Linux&lt;/code&gt; 一节&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;图形界面以 &lt;code&gt;GNOME 3&lt;/code&gt; 为例：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开所有程序列表，并 -&amp;gt; 设置 – 硬件分类 – 网络&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果要对当前的网络配置进行编辑 -&amp;gt; 单击齿轮按钮&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选中 &lt;code&gt;IPv4&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 栏目中，将自动拨向关闭&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在服务器中填入 &lt;code&gt;127.0.0.1&lt;/code&gt; （或103.214.195.99:7300）并应用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选中 &lt;code&gt;IPv6&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 栏目中，将自动拨向关闭&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在服务器中填入 ::1 并应用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请务必确保只填入这两个地址，填入其它地址可能会导致系统选择其它 DNS 服务器绕过程序的代理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启网络连接&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改系统文件修改 DNS 服务器设置：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自动获取地址(DHCP)时：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以 &lt;code&gt;root&lt;/code&gt; 权限进入 &lt;code&gt;/etc/dhcp&lt;/code&gt; 或 &lt;code&gt;/etc/dhcp3&lt;/code&gt; 目录（视乎 dhclient.conf 文件位置）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改 &lt;code&gt;dhclient.conf&lt;/code&gt; 文件，修改或添加 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 一项即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 一项被 # 注释则需要把注释去掉以使配置生效，不需要添加新的条目&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;dhclient.conf&lt;/code&gt; 文件可能存在多个 &lt;code&gt;prepend domain-name-servers&lt;/code&gt; 项，是各个网络接口的配置项目，直接修改总的配置项目即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;service network(/networking) restart&lt;/code&gt; 或 &lt;code&gt;ifdown/ifup&lt;/code&gt; 或 &lt;code&gt;ifconfig stop/start&lt;/code&gt; 重启网络服务/网络端口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非自动获取地址(DHCP)时：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以 &lt;code&gt;root&lt;/code&gt; 权限进入 &lt;code&gt;/etc&lt;/code&gt; 目录&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接修改 &lt;code&gt;resolv.conf&lt;/code&gt; 文件里的 &lt;code&gt;nameserver&lt;/code&gt; 即可&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果重启后配置被覆盖，则需要修改或新建 &lt;code&gt;/etc/resolvconf/resolv.conf.d&lt;/code&gt; 文件，内容和 &lt;code&gt;resolv.conf&lt;/code&gt; 一样&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;service network(/networking) restart&lt;/code&gt; 或 &lt;code&gt;ifdown/ifup&lt;/code&gt; 或 &lt;code&gt;ifconfig stop/start&lt;/code&gt; 重启网络服务/网络端口&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-8-打开流量转发&#34;&gt;1.8 打开流量转发&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /etc/sysctl.d/30-ipforward.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;net.ipv4.ip_forward=1

net.ipv6.conf.all.forwarding = 1

net.ipv4.tcp_congestion_control=westwood

net.ipv4.tcp_syn_retries = 5

net.ipv4.tcp_synack_retries = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑完成后，执行以下命令使变动立即生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -p
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;p-markdown-1-style-margin-bottom-2em-margin-right-5px-padding-8px-15px-letter-spacing-2px-background-image-linear-gradient-to-right-bottom-rgb-0-188-212-rgb-63-81-181-background-color-rgb-63-81-181-color-rgb-255-255-255-border-left-10px-solid-rgb-51-51-51-border-radius-5px-text-shadow-rgb-102-102-102-1px-1px-1px-box-shadow-rgb-102-102-102-1px-1px-2px-2-通过-nftables-实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;margin-bottom:2em; margin-right: 5px; padding: 8px 15px; letter-spacing: 2px; background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181)); background-color: rgb(63, 81, 181); color: rgb(255, 255, 255); border-left: 10px solid rgb(51, 51, 51); border-radius:5px; text-shadow: rgb(102, 102, 102) 1px 1px 1px; box-shadow: rgb(102, 102, 102) 1px 1px 2px;&#34;&gt;2. 通过 nftables 实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-1-安装相关软件&#34;&gt;2.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;shadowsocks-libev&lt;/li&gt;
&lt;li&gt;nftables&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S shadowsocks-libev nftables
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-配置shadowsocks-libev-略过&#34;&gt;2.2 配置shadowsocks-libev（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;2-3-获取中国ip段&#34;&gt;2.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
cat cn_rules.conf|sed &#39;:label;N;s/\n/, /;b label&#39;|sed &#39;s/$/&amp;amp; }/g&#39;|sed &#39;s/^/{ &amp;amp;/g&#39; &amp;gt; /home/yang/bin/路由表/cn_rules1.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-创建启动和关闭脚本&#34;&gt;2.4 创建启动和关闭脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /home/yang/bin/shadowsocks/nftables-up.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#! /bin/bash

nft_pre=&amp;quot;/usr/sbin/nft add rule nat prerouting&amp;quot;
nft_out=&amp;quot;/usr/sbin/nft add rule nat output&amp;quot;
chnroute=$(cat &#39;/home/yang/bin/路由表/cn_rules1.conf&#39;)

/usr/bin/nft -f /etc/nftables.conf

${nft_pre} tcp dport 8385 return
${nft_pre} ip daddr 139.162.87.98 return
${nft_pre} ip daddr { 0.0.0.0/8, 10.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, 224.0.0.0/4, 240.0.0.0/4, 172.16.39.0/24} return
${nft_pre} ip daddr $chnroute return
${nft_pre} tcp sport { 32768-61000} redirect to 1081
#${nft_pre} ip protocol icmp redirect to 1081
# 内网流量源NAT
nft add rule nat postrouting ip saddr 192.168.0.0/12 masquerade

${nft_out} tcp dport 8385 return
${nft_out} ip daddr 139.162.87.98 return
${nft_out} ip daddr { 0.0.0.0/8, 10.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, 224.0.0.0/4, 240.0.0.0/4, 172.16.39.0/24} return
${nft_out} ip daddr $chnroute return
# /proc/sys/net/ipv4/ip_local_port_range，本地发起的连接的端口范围
${nft_out} tcp sport { 32768-61000} redirect to 1081
${nft_out} ip protocol icmp redirect to 1081
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;emsp;&amp;emsp;这是在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前执行的脚本，用来设置 &lt;code&gt;nftables&lt;/code&gt; 规则。
然后再创建 &lt;code&gt;/home/yang/bin/shadowsocks/nftables-down.sh&lt;/code&gt;, 这是用来清除上述规则的脚本，比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

sudo nft flush table nat
#sudo nft flush table filter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x nftables-up.sh
$ chmod +x nftables-down.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-配置ss-redir服务&#34;&gt;2.5 配置ss-redir服务&lt;/h3&gt;

&lt;p&gt;首先，默认的 &lt;code&gt;ss-local&lt;/code&gt; 并不能用来作为 &lt;code&gt;nftables&lt;/code&gt; 流量转发的目标，因为它是 &lt;code&gt;socks5&lt;/code&gt; 代理而非透明代理。我们至少要把 &lt;code&gt;systemd&lt;/code&gt; 执行的程序改成 &lt;code&gt;ss-redir&lt;/code&gt;。其次，上述两个脚本还不能自动执行，必须让 &lt;code&gt;systemd&lt;/code&gt; 分别在启动 &lt;code&gt;shadowsocks&lt;/code&gt; 之前和关闭之后将脚本执行，这样才能自动配置好 &lt;code&gt;nftables&lt;/code&gt; 规则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/lib/systemd/system/shadowsocks-libev@.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]
Description=Shadowsocks-Libev Client Service
After=network.target

[Service]
User=root
CapabilityBoundingSet=~CAP_SYS_ADMIN
ExecStart=
ExecStartPre=/home/yang/bin/shadowsocks/nftables-up.sh
ExecStart=/usr/bin/ss-redir -u -c /etc/%i.json
ExecStopPost=/home/yang/bin/shadowsocks/nftables-down.sh

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start nftables
$ systemctl start shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable nftables
$ systemctl enable shadowsocks-libev@shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-6-配置智能-dns-服务&#34;&gt;2.6 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;2-7-配置系统-dns-服务器设置&#34;&gt;2.7 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;2-8-打开流量转发&#34;&gt;2.8 打开流量转发&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h2 id=&#34;p-markdown-1-style-margin-bottom-2em-margin-right-5px-padding-8px-15px-letter-spacing-2px-background-image-linear-gradient-to-right-bottom-rgb-0-188-212-rgb-63-81-181-background-color-rgb-63-81-181-color-rgb-255-255-255-border-left-10px-solid-rgb-51-51-51-border-radius-5px-text-shadow-rgb-102-102-102-1px-1px-1px-box-shadow-rgb-102-102-102-1px-1px-2px-3-通过策略路由实现智能分流-p&#34;&gt;&lt;p markdown=&#34;1&#34; style=&#34;margin-bottom:2em; margin-right: 5px; padding: 8px 15px; letter-spacing: 2px; background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181)); background-color: rgb(63, 81, 181); color: rgb(255, 255, 255); border-left: 10px solid rgb(51, 51, 51); border-radius:5px; text-shadow: rgb(102, 102, 102) 1px 1px 1px; box-shadow: rgb(102, 102, 102) 1px 1px 2px;&#34;&gt;3. 通过策略路由实现智能分流&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;3-1-安装相关软件&#34;&gt;3.1 安装相关软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;badvpn&lt;/li&gt;
&lt;li&gt;shadowsocks&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S badvpn shadowsocks
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-配置shadowsocks-略过&#34;&gt;3.2 配置shadowsocks（略过）&lt;/h3&gt;

&lt;p&gt;假设shadowsocks配置文件为/etc/shadowsocks.json&lt;/p&gt;

&lt;h3 id=&#34;3-3-获取中国ip段&#34;&gt;3.3 获取中国IP段&lt;/h3&gt;

&lt;p&gt;将以下命令写入脚本保存执行（假设保存在/home/yang/bin/路由表/目录下）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/sh
wget -c http://ftp.apnic.net/stats/apnic/delegated-apnic-latest
cat delegated-apnic-latest | awk -F &#39;|&#39; &#39;/CN/&amp;amp;&amp;amp;/ipv4/ {print $4 &amp;quot;/&amp;quot; 32-log($5)/log(2)}&#39; | cat &amp;gt; /home/yang/bin/路由表/cn_rules.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-4-配置智能-dns-服务&#34;&gt;3.4 配置智能 DNS 服务&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;3-5-配置系统-dns-服务器设置&#34;&gt;3.5 配置系统 DNS 服务器设置&lt;/h3&gt;

&lt;p&gt;同上&lt;/p&gt;

&lt;h3 id=&#34;3-6-写路由表启动和终止脚本&#34;&gt;3.6 写路由表启动和终止脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /usr/local/bin/socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
SOCKS_SERVER=$SERVER_IP # SOCKS 服务器的 IP 地址
SOCKS_PORT=1081 # 本地SOCKS 服务器的端口
GATEWAY_IP=$(ip route|grep &amp;quot;default&amp;quot;|awk &#39;{print $3}&#39;) # 家用网关（路由器）的 IP 地址，你也可以手动指定
TUN_NETWORK_DEV=tun0 # 选一个不冲突的 tun 设备号
TUN_NETWORK_PREFIX=10.0.0 # 选一个不冲突的内网 IP 段的前缀


start_fwd() {
ip tuntap del dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
# 添加虚拟网卡
ip tuntap add dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
# 给虚拟网卡绑定IP地址
ip addr add &amp;quot;$TUN_NETWORK_PREFIX.1/24&amp;quot; dev &amp;quot;$TUN_NETWORK_DEV&amp;quot;
# 启动虚拟网卡
ip link set &amp;quot;$TUN_NETWORK_DEV&amp;quot; up
ip route del default via &amp;quot;$GATEWAY_IP&amp;quot;
ip route add &amp;quot;$SOCKS_SERVER&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
# 特殊ip段走家用网关（路由器）的 IP 地址（如局域网联机）
# ip route add &amp;quot;172.16.39.0/24&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
# 国内网段走家用网关（路由器）的 IP 地址
for i in $(cat /home/yang/bin/路由表/cn_rules.conf)
do
ip route add &amp;quot;$i&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
done
# 将默认网关设为虚拟网卡的IP地址
ip route add 0.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
ip route add 128.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
# 将socks5转为vpn
badvpn-tun2socks --tundev &amp;quot;$TUN_NETWORK_DEV&amp;quot; --netif-ipaddr &amp;quot;$TUN_NETWORK_PREFIX.2&amp;quot; --netif-netmask 255.255.255.0 --socks-server-addr &amp;quot;127.0.0.1:$SOCKS_PORT&amp;quot;
TUN2SOCKS_PID=&amp;quot;$!&amp;quot;
}


stop_fwd() {
ip route del 128.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
ip route del 0.0.0.0/1 via &amp;quot;$TUN_NETWORK_PREFIX.1&amp;quot;
for i in $(cat /home/yang/bin/路由表/cn_rules.conf)
do
ip route del &amp;quot;$i&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
done
ip route del &amp;quot;172.16.39.0/24&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
ip route del &amp;quot;$SOCKS_SERVER&amp;quot; via &amp;quot;$GATEWAY_IP&amp;quot;
ip route add default via &amp;quot;$GATEWAY_IP&amp;quot;
ip link set &amp;quot;$TUN_NETWORK_DEV&amp;quot; down
ip addr del &amp;quot;$TUN_NETWORK_PREFIX.1/24&amp;quot; dev &amp;quot;$TUN_NETWORK_DEV&amp;quot;
ip tuntap del dev &amp;quot;$TUN_NETWORK_DEV&amp;quot; mode tun
}



start_fwd
trap stop_fwd INT TERM
wait &amp;quot;$TUN2SOCKS_PID&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim /etc/systemd/system/socksfwd.service
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[Unit]

Description=Transparent SOCKS5 forwarding

After=network-online.target

[Service]

Type=simple

ExecStart=/usr/local/bin/socksfwd

LimitNOFILE=1048576


[Install]

WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl start socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开机自启&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl enable socksfwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-7-打开流量转发&#34;&gt;3.7 打开流量转发&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat /etc/sysctl.d/30-ipforward.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;net.ipv4.ip_forward=1

net.ipv6.conf.all.forwarding = 1

net.ipv4.tcp_congestion_control=westwood

net.ipv4.tcp_syn_retries = 5

net.ipv4.tcp_synack_retries = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑完成后，执行以下命令使变动立即生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sysctl -p
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Kubernetes 资源管理概述</title>
      <link>https://www.yangcs.net/posts/kubernetes-resource-management/</link>
      <pubDate>Fri, 03 Aug 2018 17:34:19 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/kubernetes-resource-management/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p id=&#34;div-border-left-red&#34;&gt;本文转载自 &lt;a href=&#34;http://cizixs.com/2018/06/25/kubernetes-resource-management&#34; target=&#34;_blank&#34;&gt;Cizixs 的博客&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-什么是资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 什么是资源？&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;在 kubernetes 中，有两个基础但是非常重要的概念：node 和 pod。node 翻译成节点，是对集群资源的抽象；pod 是对容器的封装，是应用运行的实体。node 提供资源，而 pod 使用资源，这里的资源分为计算（cpu、memory、gpu）、存储（disk、ssd）、网络（network bandwidth、ip、ports）。这些资源提供了应用运行的基础，正确理解这些资源以及集群调度如何使用这些资源，对于大规模的 kubernetes 集群来说至关重要，不仅能保证应用的稳定性，也可以提高资源的利用率。&lt;/p&gt;

&lt;p&gt;在这篇文章，我们主要介绍 CPU 和内存这两个重要的资源，它们虽然都属于计算资源，但也有所差距。CPU 可分配的是使用时间，也就是操作系统管理的时间片，每个进程在一定的时间片里运行自己的任务（另外一种方式是绑核，也就是把 CPU 完全分配给某个 pod 使用，但这种方式不够灵活会造成严重的资源浪费，kubernetes 中并没有提供）；而对于内存，系统提供的是内存大小。&lt;/p&gt;

&lt;p&gt;CPU 的使用时间是可压缩的，换句话说它本身无状态，申请资源很快，也能快速正常回收；而内存大小是不可压缩的，因为它是有状态的（内存里面保存的数据），申请资源很慢（需要计算和分配内存块的空间），并且回收可能失败（被占用的内存一般不可回收）。&lt;/p&gt;

&lt;p&gt;把资源分成 &lt;span id=&#34;inline-blue&#34;&gt;可压缩&lt;/span&gt; 和 &lt;span id=&#34;inline-blue&#34;&gt;不可压缩&lt;/span&gt;，是因为在资源不足的时候，它们的表现很不一样。对于不可压缩资源，如果资源不足，也就无法继续申请资源（内存用完就是用完了），并且会导致 pod 的运行产生无法预测的错误（应用申请内存失败会导致一系列问题）；而对于可压缩资源，比如 CPU 时间片，即使 pod 使用的 CPU 资源很多，CPU 使用也可以按照权重分配给所有 pod 使用，虽然每个人使用的时间片减少，但不会影响程序的逻辑。&lt;/p&gt;

&lt;p&gt;在 kubernetes 集群管理中，有一个非常核心的功能：就是为 pod 选择一个主机运行。调度必须满足一定的条件，其中最基本的是主机上要有足够的资源给 pod 使用。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/800/1*PfGIiTw68JLIUyo0FQY2dA.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;资源除了和调度相关之外，还和很多事情紧密相连，这正是这篇文章要解释的。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-kubernetes-资源的表示-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. kubernetes 资源的表示&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;用户在 pod 中可以配置要使用的资源总量，kubernetes 根据配置的资源数进行调度和运行。目前主要可以配置的资源是 CPU 和 memory，对应的配置字段是 &lt;code&gt;spec.containers[].resource.limits/request.cpu/memory&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;需要注意的是，用户是对每个容器配置 request 值，所有容器的资源请求之和就是 pod 的资源请求总量，而我们一般会说 pod 的资源请求和 limits。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;limits&lt;/code&gt; 和 &lt;code&gt;requests&lt;/code&gt; 的区别我们下面会提到，这里先说说比较容易理解的 cpu 和 memory。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CPU&lt;/code&gt; 一般用核数来标识，一核CPU 相对于物理服务器的一个超线程核，也就是操作系统 &lt;code&gt;/proc/cpuinfo&lt;/code&gt; 中列出来的核数。因为对资源进行了池化和虚拟化，因此 kubernetes 允许配置非整数个的核数，比如 &lt;code&gt;0.5&lt;/code&gt; 是合法的，它标识应用可以使用半个 CPU 核的计算量。CPU 的请求有两种方式，一种是刚提到的 &lt;code&gt;0.5&lt;/code&gt;，&lt;code&gt;1&lt;/code&gt; 这种直接用数字标识 CPU 核心数；另外一种表示是 &lt;code&gt;500m&lt;/code&gt;，它等价于 &lt;code&gt;0.5&lt;/code&gt;，也就是说 &lt;code&gt;1 Core = 1000m&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;内存比较容易理解，是通过字节大小指定的。如果直接一个数字，后面没有任何单位，表示这么多字节的内存；数字后面还可以跟着单位， 支持的单位有 &lt;code&gt;E&lt;/code&gt;、&lt;code&gt;P&lt;/code&gt;、&lt;code&gt;T&lt;/code&gt;、&lt;code&gt;G&lt;/code&gt;、&lt;code&gt;M&lt;/code&gt;、&lt;code&gt;K&lt;/code&gt;，前者分别是后者的 &lt;code&gt;1000&lt;/code&gt; 倍大小的关系，此外还支持 &lt;code&gt;Ei&lt;/code&gt;、&lt;code&gt;Pi&lt;/code&gt;、&lt;code&gt;Ti&lt;/code&gt;、&lt;code&gt;Gi&lt;/code&gt;、&lt;code&gt;Mi&lt;/code&gt;、&lt;code&gt;Ki&lt;/code&gt;，其对应的倍数关系是 &lt;code&gt;2^10 = 1024&lt;/code&gt;。比如要使用 100M 内存的话，直接写成 &lt;code&gt;100Mi&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-节点可用资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 节点可用资源&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;理想情况下，我们希望节点上所有的资源都可以分配给 pod 使用，但实际上节点上除了运行 pods 之外，还会运行其他的很多进程：系统相关的进程（比如 sshd、udev等），以及 kubernetes 集群的组件（kubelet、docker等）。我们在分配资源的时候，需要给这些进程预留一些资源，剩下的才能给 pod 使用。预留的资源可以通过下面的参数控制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi]&lt;/code&gt;：控制预留给 kubernetes 集群组件的 CPU、memory 和存储资源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--system-reserved=[cpu=100mi][,][memory=100Mi][,][ephemeral-storage=1Gi]&lt;/code&gt;：预留给系统的 CPU、memory 和存储资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两块预留之后的资源才是 pod 真正能使用的，不过考虑到 eviction 机制（下面的章节会提到），kubelet 会保证节点上的资源使用率不会真正到 100%，因此 pod 的实际可使用资源会稍微再少一点。主机上的资源逻辑分配图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://i.loli.net/2018/06/25/5b3106f947190.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;需要注意的是，allocatable 不是指当前机器上可以分配的资源，而是指能分配给 pod 使用的资源总量，一旦 kubelet 启动这个值是不会变化的。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;allocatable 的值可以在 node 对象的 status 字段中读取，比如下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;status:
  allocatable:
    cpu: &amp;quot;2&amp;quot;
    ephemeral-storage: &amp;quot;35730597829&amp;quot;
    hugepages-2Mi: &amp;quot;0&amp;quot;
    memory: 3779348Ki
    pods: &amp;quot;110&amp;quot;
  capacity:
    cpu: &amp;quot;2&amp;quot;
    ephemeral-storage: 38770180Ki
    hugepages-2Mi: &amp;quot;0&amp;quot;
    memory: 3881748Ki
    pods: &amp;quot;110&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-kubernetes-资源对象-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. kubernetes 资源对象&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;在这部分，我们来介绍 kubernetes 中提供的让我们管理 pod 资源的原生对象。&lt;/p&gt;

&lt;h4 id=&#34;请求-requests-和上限-limits&#34;&gt;请求（requests）和上限（limits）&lt;/h4&gt;

&lt;p&gt;前面说过用户在创建 pod 的时候，可以指定每个容器的 Requests 和 Limits 两个字段，下面是一个实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;resources:
  requests:
    memory: &amp;quot;64Mi&amp;quot;
    cpu: &amp;quot;250m&amp;quot;
  limits:
    memory: &amp;quot;128Mi&amp;quot;
    cpu: &amp;quot;500m&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Requests&lt;/code&gt; 是容器请求要使用的资源，kubernetes 会保证 pod 能使用到这么多的资源。请求的资源是调度的依据，只有当节点上的可用资源大于 pod 请求的各种资源时，调度器才会把 pod 调度到该节点上（如果 CPU 资源足够，内存资源不足，调度器也不会选择该节点）。&lt;/p&gt;

&lt;p&gt;需要注意的是，调度器只关心节点上可分配的资源，以及节点上所有 pods 请求的资源，而&lt;strong&gt;不关心&lt;/strong&gt;节点资源的实际使用情况，换句话说，如果节点上的 pods 申请的资源已经把节点上的资源用满，即使它们的使用率非常低，比如说 CPU 和内存使用率都低于 10%，调度器也不会继续调度 pod 上去。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Limits&lt;/code&gt; 是 pod 能使用的资源上限，是实际配置到内核 cgroups 里面的配置数据。对于内存来说，会直接转换成 &lt;code&gt;docker run&lt;/code&gt; 命令行的 &lt;code&gt;--memory&lt;/code&gt; 大小，最终会配置到 cgroups 对应任务的 &lt;code&gt;/sys/fs/cgroup/memory/……/memory.limit_in_bytes&lt;/code&gt; 文件中。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;如果 limit 没有配置，则表明没有资源的上限，只要节点上有对应的资源，pod 就可以使用。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;使用 requests 和 limits 概念，我们能分配更多的 pod，提升整体的资源使用率。但是这个体系有个非常重要的问题需要考虑，那就是&lt;strong&gt;怎么去准确地评估 pod 的资源 requests？&lt;/strong&gt;如果评估地过低，会导致应用不稳定；如果过高，则会导致使用率降低。这个问题需要开发者和系统管理员共同讨论和定义。&lt;/p&gt;

&lt;h4 id=&#34;limit-range-默认资源配置&#34;&gt;limit range（默认资源配置)&lt;/h4&gt;

&lt;p&gt;为每个 pod 都手动配置这些参数是挺麻烦的事情，kubernetes 提供了 &lt;code&gt;LimitRange&lt;/code&gt; 资源，可以让我们配置某个 namespace 默认的 request 和 limit 值，比如下面的实例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: &amp;quot;v1&amp;quot;
kind: &amp;quot;LimitRange&amp;quot;
metadata:
  name: you-shall-have-limits
spec:
  limits:
    - type: &amp;quot;Container&amp;quot;
      max:
        cpu: &amp;quot;2&amp;quot;
        memory: &amp;quot;1Gi&amp;quot;
      min:
        cpu: &amp;quot;100m&amp;quot;
        memory: &amp;quot;4Mi&amp;quot;
      default:
        cpu: &amp;quot;500m&amp;quot;
        memory: &amp;quot;200Mi&amp;quot;
      defaultRequest:
        cpu: &amp;quot;200m&amp;quot;
        memory: &amp;quot;100Mi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果对应 namespace 创建的 pod 没有写资源的 requests 和 limits 字段，那么它会自动拥有下面的配置信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内存请求是 100Mi，上限是 200Mi&lt;/li&gt;
&lt;li&gt;CPU 请求是 200m，上限是 500m&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，如果 pod 自己配置了对应的参数，kubernetes 会使用 pod 中的配置。使用 LimitRange 能够让 namespace 中的 pod 资源规范化，便于统一的资源管理。&lt;/p&gt;

&lt;h4 id=&#34;资源配额-resource-quota&#34;&gt;资源配额（resource quota）&lt;/h4&gt;

&lt;p&gt;前面讲到的资源管理和调度可以认为 kubernetes 把这个集群的资源整合起来，组成一个资源池，每个应用（pod）会自动从整个池中分配资源来使用。默认情况下只要集群还有可用的资源，应用就能使用，并没有限制。kubernetes 本身考虑到了多用户和多租户的场景，提出了 namespace 的概念来对集群做一个简单的隔离。&lt;/p&gt;

&lt;p&gt;基于 namespace，kubernetes 还能够对资源进行隔离和限制，这就是 resource quota 的概念，翻译成资源配额，它限制了某个 namespace 可以使用的资源总额度。这里的资源包括 cpu、memory 的总量，也包括 kubernetes 自身对象（比如 pod、services 等）的数量。通过 resource quota，kubernetes 可以防止某个 namespace 下的用户不加限制地使用超过期望的资源，比如说不对资源进行评估就大量申请 16核 CPU 32G内存的 pod。&lt;/p&gt;

&lt;p&gt;下面是一个资源配额的实例，它限制了 namespace 只能使用 20核 CPU 和 1G 内存，并且能创建 10 个 pod、20个 rc、5个 service，可能适用于某个测试场景。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota
spec:
  hard:
    cpu: &amp;quot;20&amp;quot;
    memory: 1Gi
    pods: &amp;quot;10&amp;quot;
    replicationcontrollers: &amp;quot;20&amp;quot;
    resourcequotas: &amp;quot;1&amp;quot;
    services: &amp;quot;5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;resource quota 能够配置的选项还很多，比如 GPU、存储、configmaps、persistentvolumeclaims 等等，更多信息可以参考官方的文档。&lt;/p&gt;

&lt;p&gt;Resource quota 要解决的问题和使用都相对独立和简单，但是它也有一个限制：那就是它不能根据集群资源动态伸缩。一旦配置之后，resource quota 就不会改变，即使集群增加了节点，整体资源增多也没有用。kubernetes 现在没有解决这个问题，但是用户可以通过编写一个 controller 的方式来自己实现。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-应用优先级-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 应用优先级&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;qos-服务质量&#34;&gt;QoS（服务质量）&lt;/h4&gt;

&lt;p&gt;Requests 和 limits 的配置除了表明资源情况和限制资源使用之外，还有一个隐藏的作用：它决定了 pod 的 QoS 等级。&lt;/p&gt;

&lt;p&gt;上一节我们提到了一个细节：如果 pod 没有配置 limits ，那么它可以使用节点上任意多的可用资源。这类 pod 能灵活使用资源，但这也导致它不稳定且危险，对于这类 pod 我们一定要在它占用过多资源导致节点资源紧张时处理掉。优先处理这类 pod，而不是资源使用处于自己请求范围内的 pod 是非常合理的想法，而这就是 pod QoS 的含义：根据 pod 的资源请求把 pod 分成不同的重要性等级。&lt;/p&gt;

&lt;p&gt;kubernetes 把 pod 分成了三个 QoS 等级：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Guaranteed&lt;/span&gt; ：优先级最高，可以考虑数据库应用或者一些重要的业务应用。除非 pods 使用超过了它们的 limits，或者节点的内存压力很大而且没有 QoS 更低的 pod，否则不会被杀死&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Burstable&lt;/span&gt; ：这种类型的 pod 可以多于自己请求的资源（上限有 limit 指定，如果 limit 没有配置，则可以使用主机的任意可用资源），但是重要性认为比较低，可以是一般性的应用或者批处理任务&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Best Effort&lt;/span&gt; ：优先级最低，集群不知道 pod 的资源请求情况，调度不考虑资源，可以运行到任意节点上（从资源角度来说），可以是一些临时性的不重要应用。pod 可以使用节点上任何可用资源，但在资源不足时也会被优先杀死&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pod 的 requests 和 limits 是如何对应到这三个 QoS 等级上的，可以用下面一张表格概括：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://i.loli.net/2018/06/25/5b307f4bc7d42.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;看到这里，你也许看出来一个问题了：&lt;strong&gt;如果不配置 requests 和 limits，pod 的 QoS 竟然是最低的&lt;/strong&gt;。没错，所以推荐大家理解 QoS 的概念，并且按照需求&lt;strong&gt;一定要给 pod 配置 requests 和 limits 参数&lt;/strong&gt;，不仅可以让调度更准确，也能让系统更加稳定。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;按照现在的方法根据 pod 请求的资源进行配置不够灵活和直观，更理想的情况是用户可以直接配置 pod 的 QoS，而不用关心具体的资源申请和上限值。但 kubernetes 目前还没有这方面的打算。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Pod 的 QoS 还决定了容器的 OOM（out-of-memory）值，它们对应的关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/06/25/5b307a5b3557c.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，QoS 越高的 pod oom 值越低，也就越不容易被系统杀死。对于 Bustable pod，它的值是根据 request 和节点内存总量共同决定的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;oomScoreAdjust := 1000 - (1000*memoryRequest)/memoryCapacity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;memoryRequest&lt;/code&gt; 是 pod 申请的资源，&lt;code&gt;memoryCapacity&lt;/code&gt; 是节点的内存总量。可以看到，申请的内存越多，oom 值越低，也就越不容易被杀死。&lt;/p&gt;

&lt;p&gt;QoS 的作用会在后面介绍 eviction 的时候详细讲解。&lt;/p&gt;

&lt;h4 id=&#34;pod-优先级-priority&#34;&gt;Pod 优先级（priority）&lt;/h4&gt;

&lt;p&gt;除了 QoS，kubernetes 还允许我们自定义 pod 的优先级，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: scheduling.k8s.io/v1alpha1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: &amp;quot;This priority class should be used for XYZ service pods only.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优先级的使用也比较简单，只需要在 &lt;code&gt;pod.spec.PriorityClassName&lt;/code&gt; 指定要使用的优先级名字，即可以设置当前 pod 的优先级为对应的值。&lt;/p&gt;

&lt;p&gt;Pod 的优先级在调度的时候会使用到。首先，待调度的 pod 都在同一个队列中，启用了 pod priority 之后，调度器会根据优先级的大小，把优先级高的 pod 放在前面，提前调度。&lt;/p&gt;

&lt;p&gt;另外，如果在调度的时候，发现某个 pod 因为资源不足无法找到合适的节点，调度器会尝试 preempt 的逻辑。 简单来说，调度器会试图找到这样一个节点：找到它上面优先级低于当前要调度 pod 的所有 pod，如果杀死它们，能腾足够的资源，调度器会执行删除操作，把 pod 调度到节点上。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-6-驱逐-eviction-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;6. 驱逐（Eviction）&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;至此，我们讲述的都是理想情况下 kubernetes 的工作状况，我们假设资源完全够用，而且应用也都是在使用规定范围内的资源。&lt;/p&gt;

&lt;p&gt;但现实不会如此简单，在管理集群的时候我们常常会遇到资源不足的情况，在这种情况下我们要&lt;strong&gt;保证整个集群可用&lt;/strong&gt;，并且尽可能&lt;strong&gt;减少应用的损失&lt;/strong&gt;。保证集群可用比较容易理解，首先要保证系统层面的核心进程正常，其次要保证 kubernetes 本身组件进程不出问题；但是如果量化应用的损失呢？首先能想到的是如果要杀死 pod，要尽量减少总数。另外一个就和 pod 的优先级相关了，那就是尽量杀死不那么重要的应用，让重要的应用不受影响。&lt;/p&gt;

&lt;p&gt;Pod 的驱逐是在 kubelet 中实现的，因为 kubelet 能动态地感知到节点上资源使用率实时的变化情况。其核心的逻辑是：kubelet 实时监控节点上各种资源的使用情况，一旦发现某个不可压缩资源出现要耗尽的情况，就会主动终止节点上的 pod，让节点能够正常运行。被终止的 pod 所有容器会停止，状态会被设置为 failed。&lt;/p&gt;

&lt;h4 id=&#34;驱逐触发条件&#34;&gt;驱逐触发条件&lt;/h4&gt;

&lt;p&gt;那么哪些资源不足会导致 kubelet 执行驱逐程序呢？目前主要有三种情况：实际内存不足、节点文件系统的可用空间（文件系统剩余大小和 inode 数量）不足、以及镜像文件系统的可用空间（包括文件系统剩余大小和 inode 数量）不足。&lt;/p&gt;

&lt;p&gt;下面这图是具体的触发条件：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/06/24/5b2f1a966a703.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有了数据的来源，另外一个问题是触发的时机，也就是到什么程度需要触发驱逐程序？kubernetes 运行用户自己配置，并且支持两种模式：按照百分比和按照绝对数量。比如对于一个 32G 内存的节点当可用内存少于 10% 时启动驱逐程序，可以配置 &lt;code&gt;memory.available&amp;lt;10%&lt;/code&gt; 或者 &lt;code&gt;memory.available&amp;lt;3.2Gi&lt;/code&gt;。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;默认情况下，kubelet 的驱逐规则是 &lt;code&gt;memory.available&lt;100Mi&lt;/code&gt;，对于生产环境这个配置是不可接受的，所以一定要根据实际情况进行修改。&lt;/p&gt;
&lt;/div&gt;

&lt;h4 id=&#34;软驱逐-soft-eviction-和硬驱逐-hard-eviction&#34;&gt;软驱逐（soft eviction）和硬驱逐（hard eviction）&lt;/h4&gt;

&lt;p&gt;因为驱逐 pod 是具有毁坏性的行为，因此必须要谨慎。有时候内存使用率增高只是暂时性的，有可能 20s 内就能恢复，这时候启动驱逐程序意义不大，而且可能会导致应用的不稳定，我们要考虑到这种情况应该如何处理；另外需要注意的是，如果内存使用率过高，比如高于 95%（或者 90%，取决于主机内存大小和应用对稳定性的要求），那么我们不应该再多做评估和考虑，而是赶紧启动驱逐程序，因为这种情况再花费时间去判断可能会导致内存继续增长，系统完全崩溃。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，kubernetes 引入了 soft eviction 和 hard eviction 的概念。&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;软驱逐&lt;/span&gt; 可以在资源紧缺情况并没有哪些严重的时候触发，比如内存使用率为 85%，软驱逐还需要配置一个时间指定软驱逐条件持续多久才触发，也就是说 kubelet 在发现资源使用率达到设定的阈值之后，并不会立即触发驱逐程序，而是继续观察一段时间，如果资源使用率高于阈值的情况持续一定时间，才开始驱逐。并且驱逐 pod 的时候，会遵循 grace period ，等待 pod 处理完清理逻辑。和软驱逐相关的启动参数是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--eviction-soft&lt;/code&gt;：软驱逐触发条件，比如 &lt;code&gt;memory.available&amp;lt;1Gi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--eviction-sfot-grace-period&lt;/code&gt;：触发条件持续多久才开始驱逐，比如 memory.available=2m30s&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--eviction-max-pod-grace-period&lt;/code&gt;：kill pod 时等待 grace period 的时间让 pod 做一些清理工作，如果到时间还没有结束就做 kill&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面两个参数必须同时配置，软驱逐才能正常工作；后一个参数会和 pod 本身配置的 grace period 比较，选择较小的一个生效。&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;硬驱逐&lt;/span&gt; 更加直接干脆，kubelet 发现节点达到配置的硬驱逐阈值后，立即开始驱逐程序，并且不会遵循 grace period，也就是说立即强制杀死 pod。对应的配置参数只有一个 &lt;code&gt;--evictio-hard&lt;/code&gt;，可以选择上面表格中的任意条件搭配。&lt;/p&gt;

&lt;p&gt;设置这两种驱逐程序是为了平衡节点稳定性和对 pod 的影响，软驱逐照顾到了 pod 的优雅退出，减少驱逐对 pod 的影响；而硬驱逐则照顾到节点的稳定性，防止资源的快速消耗导致节点不可用。&lt;/p&gt;

&lt;p&gt;软驱逐和硬驱逐可以单独配置，不过还是推荐两者都进行配置，一起使用。&lt;/p&gt;

&lt;h4 id=&#34;驱逐哪些-pods&#34;&gt;驱逐哪些 pods？&lt;/h4&gt;

&lt;p&gt;上面我们已经整体介绍了 kubelet 驱逐 pod 的逻辑和过程，那这里就牵涉到一个具体的问题：&lt;strong&gt;要驱逐哪些 pod？&lt;/strong&gt;驱逐的重要原则是尽量减少对应用程序的影响。&lt;/p&gt;

&lt;p&gt;如果是存储资源不足，kubelet 会根据情况清理状态为 Dead 的 pod 和它的所有容器，以及清理所有没有使用的镜像。如果上述清理并没有让节点回归正常，kubelet 就开始清理 pod。&lt;/p&gt;

&lt;p&gt;一个节点上会运行多个 pod，驱逐所有的 pods 显然是不必要的，因此要做出一个抉择：在节点上运行的所有 pod 中选择一部分来驱逐。虽然这些 pod 乍看起来没有区别，但是它们的地位是不一样的，正如乔治·奥威尔在《动物庄园》的那句话：&lt;/p&gt;

&lt;p id=&#34;div-border-left-purple&#34;&gt;所有动物生而平等，但有些动物比其他动物更平等。&lt;/p&gt;

&lt;p&gt;Pod 也是不平等的，有些 pod 要比其他 pod 更重要。只管来说，系统组件的 pod 要比普通的 pod 更重要，另外运行数据库的 pod 自然要比运行一个无状态应用的 pod 更重要。kubernetes 又是怎么决定 pod 的优先级的呢？这个问题的答案就藏在我们之前已经介绍过的内容里：pod requests 和 limits、优先级（priority），以及 pod 实际的资源使用。&lt;/p&gt;

&lt;p&gt;简单来说，kubelet 会根据以下内容对 pod 进行排序：pod 是否使用了超过请求的紧张资源、pod 的优先级、然后是使用的紧缺资源和请求的紧张资源之间的比例。具体来说，kubelet 会按照如下的顺序驱逐 pod：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用的紧张资源超过请求数量的 &lt;code&gt;BestEffort&lt;/code&gt; 和 &lt;code&gt;Burstable pod&lt;/code&gt;，这些 pod 内部又会按照优先级和使用比例进行排序&lt;/li&gt;
&lt;li&gt;紧张资源使用量低于 requests 的 &lt;code&gt;Burstable&lt;/code&gt; 和 &lt;code&gt;Guaranteed&lt;/code&gt; 的 pod 后面才会驱逐，只有当系统组件（kubelet、docker、journald 等）内存不够，并且没有上面 QoS 比较低的 pod 时才会做。执行的时候还会根据 priority 排序，优先选择优先级低的 pod&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;防止波动&#34;&gt;防止波动&lt;/h4&gt;

&lt;p&gt;这里的波动有两种情况，我们先说说第一种。驱逐条件出发后，如果 kubelet 驱逐一部分 pod，让资源使用率低于阈值就停止，那么很可能过一段时间资源使用率又会达到阈值，从而再次出发驱逐，如此循环往复……为了处理这种问题，我们可以使用 &lt;code&gt;--eviction-minimum-reclaim&lt;/code&gt; 解决，这个参数配置每次驱逐至少清理出来多少资源才会停止。&lt;/p&gt;

&lt;p&gt;另外一个波动情况是这样的：Pod 被驱逐之后并不会从此消失不见，常见的情况是 kubernetes 会自动生成一个新的 pod 来取代，并经过调度选择一个节点继续运行。如果不做额外处理，有理由相信 pod 选择原来节点的可能性比较大（因为调度逻辑没变，而它上次调度选择的就是该节点），之所以说可能而不是绝对会再次选择该节点，是因为集群 pod 的运行和分布和上次调度时极有可能发生了变化。&lt;/p&gt;

&lt;p&gt;无论如何，如果被驱逐的 pod 再次调度到原来的节点，很可能会再次触发驱逐程序，然后 pod 再次被调度到当前节点，循环往复…… 这种事情当然是我们不愿意看到的，虽然看似复杂，但这个问题解决起来非常简单：驱逐发生后，kubelet 更新节点状态，调度器感知到这一情况，暂时不往该节点调度 pod 即可。&lt;code&gt;--eviction-pressure-transition-period&lt;/code&gt; 参数可以指定 kubelet 多久才上报节点的状态，因为默认的上报状态周期比较短，频繁更改节点状态会导致驱逐波动。&lt;/p&gt;

&lt;p&gt;做一个总结，下面是一个使用了上面多种参数的驱逐配置实例（你应该能看懂它们是什么意思了）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;–eviction-soft=memory.available&amp;lt;80%,nodefs.available&amp;lt;2Gi \
–eviction-soft-grace-period=memory.available=1m30s,nodefs.available=1m30s \
–eviction-max-pod-grace-period=120 \
–eviction-hard=memory.available&amp;lt;500Mi,nodefs.available&amp;lt;1Gi \
–eviction-pressure-transition-period=30s \
--eviction-minimum-reclaim=&amp;quot;memory.available=0Mi,nodefs.available=500Mi,imagefs.available=2Gi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-7-碎片整理和重调度-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;7. 碎片整理和重调度&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Kubernetes 的调度器在为 pod 选择运行节点的时候，只会考虑到调度那个时间点集群的状态，经过一系列的算法选择一个&lt;strong&gt;当时最合适&lt;/strong&gt;的节点。但是集群的状态是不断变化的，用户创建的 pod 也是动态的，随着时间变化，原来调度到某个节点上的 pod 现在看来可能有更好的节点可以选择。比如考虑到下面这些情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;调度 pod 的条件已经不再满足，比如节点的 taints 和 labels 发生了变化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;新节点加入了集群。如果默认配置了把 pod 打散，那么应该有一些 pod 最好运行在新节点上&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点的使用率不均匀。调度后，有些节点的分配率和使用率比较高，另外一些比较低&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;节点上有资源碎片。有些节点调度之后还剩余部分资源，但是又低于任何 pod 的请求资源；或者 memory 资源已经用完，但是 CPU 还有挺多没有使用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;想要解决上述的这些问题，都需要把 pod 重新进行调度（把 pod 从当前节点移动到另外一个节点）。但是默认情况下，一旦 pod 被调度到节点上，除非给杀死否则不会移动到另外一个节点的。&lt;/p&gt;

&lt;p&gt;为此 kubernetes 社区孵化了一个称为 &lt;a href=&#34;https://github.com/kubernetes-incubator/descheduler&#34; target=&#34;_blank&#34;&gt;descheduler&lt;/a&gt; 的项目，专门用来做重调度。重调度的逻辑很简单：找到上面几种情况中已经不是最优的 pod，把它们驱逐掉（eviction）。&lt;/p&gt;

&lt;p&gt;目前，descheduler 不会决定驱逐的 pod 应该调度到哪台机器，而是&lt;strong&gt;假定默认的调度器会做出正确的调度抉择&lt;/strong&gt;。也就是说，之所以 pod 目前不合适，不是因为调度器的算法有问题，而是因为集群的情况发生了变化。如果让调度器重新选择，调度器现在会把 pod 放到合适的节点上。这种做法让 descheduler 逻辑比较简单，而且避免了调度逻辑出现在两个组件中。&lt;/p&gt;

&lt;p&gt;Descheduler 执行的逻辑是可以配置的，目前有几种场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RemoveDuplicates&lt;/code&gt;：RS、deployment 中的 pod 不能同时出现在一台机器上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LowNodeUtilization&lt;/code&gt;：找到资源使用率比较低的 node，然后驱逐其他资源使用率比较高节点上的 pod，期望调度器能够重新调度让资源更均衡&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RemovePodsViolatingInterPodAntiAffinity&lt;/code&gt;：找到已经违反 Pod Anti Affinity 规则的 pods 进行驱逐，可能是因为反亲和是后面加上去的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RemovePodsViolatingNodeAffinity&lt;/code&gt;：找到违反 Node Affinity 规则的 pods 进行驱逐，可能是因为 node 后面修改了 label&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，为了保证应用的稳定性，descheduler 并不会随意地驱逐 pod，还是会尊重 pod 运行的规则，包括 pod 的优先级（不会驱逐 Critical pod，并且按照优先级顺序进行驱逐）和 PDB（如果违反了 PDB，则不会进行驱逐），并且不会驱逐没有 deployment、rs、jobs 的 pod 不会驱逐，daemonset pod 不会驱逐，有 local storage 的 pod 也不会驱逐。&lt;/p&gt;

&lt;p&gt;Descheduler 不是一个常驻的任务，每次执行完之后会退出，因此推荐使用 CronJob 来运行。&lt;/p&gt;

&lt;p&gt;总的来说，descheduler 是对原生调度器的补充，用来解决原生调度器的调度决策随着时间会变得失效，或者不够优化的缺陷。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-8-资源动态调整-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;8. 资源动态调整&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;动态调整的思路：应用的实际流量会不断变化，因此使用率也是不断变化的，为了应对应用流量的变化，我们应用能够自动调整应用的资源。比如在线商品应用在促销的时候访问量会增加，我们应该自动增加 pod 运算能力来应对；当促销结束后，有需要自动降低 pod 的运算能力防止浪费。&lt;/p&gt;

&lt;p&gt;运算能力的增减有两种方式：改变单个 pod 的资源，已经增减 pod 的数量。这两种方式对应了 kubernetes 的 HPA 和 VPA。&lt;/p&gt;

&lt;h4 id=&#34;horizontal-pod-autoscaling-横向-pod-自动扩展&#34;&gt;Horizontal Pod AutoScaling（横向 Pod 自动扩展）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://478h5m1yrfsa3bbe262u7muv-wpengine.netdna-ssl.com/wp-content/uploads/2018/02/autoscaler_kubernetes.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;横向 pod 自动扩展的思路是这样的：kubernetes 会运行一个 controller，周期性地监听 pod 的资源使用情况，当高于设定的阈值时，会自动增加 pod 的数量；当低于某个阈值时，会自动减少 pod 的数量。自然，这里的阈值以及 pod 的上限和下限的数量都是需要用户配置的。&lt;/p&gt;

&lt;p&gt;上面这句话隐藏了一个重要的信息：HPA 只能和 RC、deployment、RS 这些可以动态修改 replicas 的对象一起使用，而无法用于单个 pod、daemonset（因为它控制的 pod 数量不能随便修改）等对象。&lt;/p&gt;

&lt;p&gt;目前官方的监控数据来源是 metrics server 项目，可以配置的资源只有 CPU，但是用户可以使用自定义的监控数据（比如 prometheus），其他资源（比如 memory）的 HPA 支持也已经在路上了。&lt;/p&gt;

&lt;h4 id=&#34;vertical-pod-autoscaling&#34;&gt;Vertical Pod AutoScaling&lt;/h4&gt;

&lt;p&gt;和 HPA 的思路相似，只不过 VPA 调整的是单个 pod 的 request 值（包括 CPU 和 memory）。VPA 包括三个组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Recommander&lt;/code&gt;：消费 metrics server 或者其他监控组件的数据，然后计算 pod 的资源推荐值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Updater&lt;/code&gt;：找到被 vpa 接管的 pod 中和计算出来的推荐值差距过大的，对其做 update 操作（目前是 evict，新建的 pod 在下面 admission controller 中会使用推荐的资源值作为 request）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Admission Controller&lt;/code&gt;：新建的 pod 会经过该 Admission Controller，如果 pod 是被 vpa 接管的，会使用 recommander 计算出来的推荐值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，这三个组件的功能是互相补充的，共同实现了动态修改 pod 请求资源的功能。相对于 HPA，目前 VPA 还处于 alpha，并且还没有合并到官方的 kubernetes release 中，后续的接口和功能很可能会发生变化。&lt;/p&gt;

&lt;h4 id=&#34;cluster-auto-scaler&#34;&gt;Cluster Auto Scaler&lt;/h4&gt;

&lt;p&gt;随着业务的发展，应用会逐渐增多，每个应用使用的资源也会增加，总会出现集群资源不足的情况。为了动态地应对这一状况，我们还需要 CLuster Auto Scaler，能够根据整个集群的资源使用情况来增减节点。&lt;/p&gt;

&lt;p&gt;对于公有云来说，Cluster Auto Scaler 就是监控这个集群因为资源不足而 pending 的 pod，根据用户配置的阈值调用公有云的接口来申请创建机器或者销毁机器。对于私有云，则需要对接内部的管理平台。&lt;/p&gt;

&lt;p&gt;目前 HPA 和 VPA 不兼容，只能选择一个使用，否则两者会相互干扰。而且 VPA 的调整需要重启 pod，这是因为 pod 资源的修改是比较大的变化，需要重新走一下 apiserver、调度的流程，保证整个系统没有问题。目前社区也有计划在做原地升级，也就是说不通过杀死 pod 再调度新 pod 的方式，而是直接修改原有 pod 来更新。&lt;/p&gt;

&lt;p&gt;理论上 HPA 和 VPA 是可以共同工作的，HPA 负责瓶颈资源，VPA 负责其他资源。比如对于 CPU 密集型的应用，使用 HPA 监听 CPU 使用率来调整 pods 个数，然后用 VPA 监听其他资源（memory、IO）来动态扩展这些资源的 request 大小即可。当然这只是理想情况。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-9-总结-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;9. 总结&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;从前面介绍的各种 kubernetes 调度和资源管理方案可以看出来，提高应用的资源使用率、保证应用的正常运行、维护调度和集群的公平性是件非常复杂的事情，kubernetes 并没有完美的方法，而是对各种可能的问题不断提出一些针对性的方案。&lt;/p&gt;

&lt;p&gt;集群的资源使用并不是静态的，而是随着时间不断变化的，目前 kubernetes 的调度决策都是基于调度时集群的一个静态资源切片进行的，动态地资源调整是通过 kubelet 的驱逐程序进行的，HPA 和 VPA 等方案也不断提出，相信后面会不断完善这方面的功能，让 kubernetes 更加智能。&lt;/p&gt;

&lt;p&gt;资源管理和调度、应用优先级、监控、镜像中心等很多东西相关，是个非常复杂的领域。在具体的实施和操作的过程中，常常要考虑到企业内部的具体情况和需求，做出针对性的调整，并且需要开发者、系统管理员、SRE、监控团队等不同小组一起合作。但是这种付出从整体来看是值得的，提升资源的利用率能有效地节约企业的成本，也能让应用更好地发挥出作用。&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Vistio—使用 Netflix 的 Vizceral 可视化 Istio service mesh</title>
      <link>https://www.yangcs.net/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/</link>
      <pubDate>Fri, 03 Aug 2018 15:29:37 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p id=&#34;div-border-left-red&#34;&gt;本文转载自 &lt;a href=&#34;https://jimmysong.io/posts/vistio-visualize-your-istio-mesh-using-netflixs-vizceral/&#34; target=&#34;_blank&#34;&gt;Jimmy Song 的博客&lt;/a&gt;，并且有很多改动。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/vizceral&#34; target=&#34;_blank&#34;&gt;Vizceral&lt;/a&gt; 是 &lt;code&gt;Netflix&lt;/code&gt; 发布的一个开源项目，用于近乎实时地监控应用程序和集群之间的网络流量。&lt;a href=&#34;https://github.com/nmnellis/vistio&#34; target=&#34;_blank&#34;&gt;Vistio&lt;/a&gt; 是使用 Vizceral 对 Istio 和网格监控的改进。它利用 &lt;code&gt;Istio Mixer&lt;/code&gt; 生成的指标，然后将其输入 Prometheus。Vistio 查询 &lt;code&gt;Prometheus&lt;/code&gt; 并将数据存储在本地以允许重播流量。关于 Vizceral 可以参考这篇文章：&lt;a href=&#34;https://medium.com/netflix-techblog/vizceral-open-source-acc0c32113fe&#34; target=&#34;_blank&#34;&gt;Vizceral Open Source&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/YJqKg8M5xnNlqYtNr5Jsmw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vizceral 有两个可视化级别，全局可视化和集群级别可视化。在全局范围内（如上所示），您可以通过 Istio Ingress Gateway 等入口点将从 Internet 到 Istio 服务网格网络的网络流量可视化，或者您可以在 Istio 服务网格网络中显示总网络流量。&lt;/p&gt;

&lt;p&gt;在集群级别（如下所示），您可以可视化内部网格的流量。通过设置警告和错误级别警报，当应用程序出现问题时可以被快速检测出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-mesh1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-在-istio-服务网格中安装-vistio-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 在 Istio 服务网格中安装 Vistio&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;依赖&#34;&gt;依赖&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Prometheus&lt;/li&gt;
&lt;li&gt;Istio 1.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;假设&#34;&gt;假设&lt;/h4&gt;

&lt;p&gt;以下 Demo 使得这些假设更容易部署。如果您的环境设置不同，则可能需要将代码下载到本地并编辑一些文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Prometheus 部署在 &lt;code&gt;istio-system&lt;/code&gt; namespace 下，可以通过 &lt;code&gt;http://prometheus.istio-system:9090&lt;/code&gt; 地址访问&lt;/li&gt;
&lt;li&gt;Istio mixer 启用了 &lt;code&gt;istio_request_count metric&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Kubernetes 集群包含有 &lt;code&gt;standard StorageClass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;为了便于部署已安装了 Helm（可选）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;由于测试环境大多数都没有外部网络存储，无法创建 StorageClass，待会儿我们可以将这部分的配置修改为 &lt;code&gt;hostPath&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;前言&#34;&gt;前言&lt;/h4&gt;

&lt;p&gt;如果您还尚未部署服务网格，可以按照此 &lt;a href=&#34;https://istio.io/docs/guides/bookinfo/&#34; target=&#34;_blank&#34;&gt;Istio Bookinfo Demo&lt;/a&gt; 中的说明部署 Istio 及其示例应用程序。您需要能够在应用程序之间生成流量。要测试指标是否从 Mixer 正确发送到 Prometheus，您可以打开 Prometheus 查询 &lt;code&gt;istio_request_bytes_count&lt;/code&gt;，应该会看到多个条目。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-prometheus.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-部署-vistio-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 部署 Vistio&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;您可以选择通过 &lt;code&gt;kubectl&lt;/code&gt; 或者 &lt;code&gt;Helm&lt;/code&gt; 来部署 Vistio，下面会主要介绍 Helm 部署方式。有些变量可能需要根据您自己的环境来修改。&lt;/p&gt;

&lt;p&gt;如果你想通过 Helm 部署 Vistio，你将需要在 GitHub 上下载项目来获取 Helm 模板。此外，如果上述假设之一不符合您的需求（例如 prometheus url 不同），则应手动编辑文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/nmnellis/vistio.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&#34;使用-helm-部署&#34;&gt;使用 Helm 部署&lt;/h4&gt;

&lt;p&gt;由于我们使用的是 Istio 1.0 版本，而 Vistio 已经有相当一段时间没有更新了，很多配置项已经不适用了，需要改动很多地方。&lt;/p&gt;

&lt;p&gt;切换到 Vistio 项目的根目录，修改 &lt;code&gt;values-with-ingress.yaml&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim helm/vistio/values-with-ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;vistioConfig:
  graphName: Vistio
  globalLevel:
    maxVolume: 2000000
    clusterConnections:
      # Total requests per second coming into the ingress controller from internet
      # 将 istio_request_count 修改为 istio_request_bytes_count
      # 将 destination_service=&amp;quot;istio-ingressgateway.istio-system.svc.cluster.local&amp;quot; 修改为 source_workload=&amp;quot;istio-ingressgateway&amp;quot;
      - query: sum(rate(istio_request_bytes_count{source_workload=&amp;quot;istio-ingressgateway&amp;quot;}[1m])) by (response_code)
        prometheusURL: http://prometheus.istio-system:9090
        ...
  clusterLevel:
    # Cluster name must match &#39;target&#39; name in global
    - cluster: istio-mesh
      maxVolume: 3000
      serviceConnections:
      # 将 istio_request_count 修改为 istio_request_bytes_count
      # 将 source_service 修改为 source_app
        - query: sum(rate(istio_request_bytes_count[1m])) by (source_app,destination_service,response_code)
          prometheusURL: http://prometheus.istio-system:9090
          source:
            # 将 source_service 修改为 source_app
            label: source_app
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 &lt;code&gt;values.yaml&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim helm/vistio/values.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;...
######################################
## Vistio-web
######################################
web:
  env:
    # Vistio-web 需要调用 Vistio-api 的 url，而且这个 url 必须是通过浏览器可以访问的，所以可以使用 ingress，后面将会创建
    updateURL: &amp;quot;http://vistio-api.istio.io/graph&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 &lt;code&gt;statefulset.yaml&lt;/code&gt; 配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim helm/vistio/templates/statefulset.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: vistio-api
  ...
spec:
  replicas: {{ .Values.api.replicaCount }}
  serviceName: vistio
  template:
    metadata:
    ...
    spec:
      volumes:
        - name: config
          configMap:
            name: vistio-api-config
        # 添加 volume vistio-db
        - name: vistio-db
          hostPath:
            path: /data/vistio
  # 将 volumeClaimTemplates 配置项注释或删除
  #volumeClaimTemplates:
  #- metadata:
  #    annotations:
  #      volume.beta.kubernetes.io/storage-class: {{ .Values.api.storage.class }}
  #    name: vistio-db
  #  spec:
  #    accessModes:
  #    - ReadWriteOnce
  #    resources:
  #      requests:
  #        storage: {{ .Values.api.storage.size }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;同时你需要在运行 vistio-api 的节点上提前创建 &lt;code&gt;/data/vistio&lt;/code&gt; 目录。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;运行 &lt;code&gt;helm install&lt;/code&gt; 部署 Vistio。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm install helm/vistio -f helm/vistio/values-with-ingress.yaml --name vistio --namespace default
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pod

vistio-api-0                      1/1       Running   0          2m
vistio-web-5c44b7f76d-hmjdc       1/1       Running   0          2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-验证和暴露-vistio-web-api-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 验证和暴露 Vistio Web/API&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;暴露-vistio-web-api&#34;&gt;暴露 Vistio Web/API&lt;/h4&gt;

&lt;p&gt;为 Service vistio-api 和 vistio-web 创建 &lt;code&gt;Ingress&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat ingress.yaml

---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: vistio-web
  namespace: default
spec:
  rules:
  - host: vistio-web.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: vistio-web
          servicePort: 8080
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: vistio-api
  namespace: default
spec:
  rules:
  - host: vistio-api.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: vistio-api
          servicePort: 9091
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl create -f ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你的本地电脑上添加两条 hosts：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$Ingree_host vistio-web.istio.io
$Ingree_host vistio-api.istio.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 &lt;code&gt;$Ingree_host&lt;/code&gt; 替换为 Ingress Controller 运行节点的 IP。&lt;/p&gt;

&lt;h4 id=&#34;验证-visito-api&#34;&gt;验证 visito-api&lt;/h4&gt;

&lt;p&gt;vistio-web 调用 vistio-api 来渲染服务网格。访问 &lt;code&gt;http://vistio-api.istio.io/graph&lt;/code&gt; 您应该会看到类似下列的输出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/LkvzHsN0VzZSOD_wy7sCgQ.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;访问-vistio&#34;&gt;访问 Vistio&lt;/h4&gt;

&lt;p&gt;如果一切都已经启动并准备就绪，您就可以访问 Vistio UI，开始探索服务网格网络，访问&lt;code&gt;http://vistio-web.istio.io&lt;/code&gt; 您将会看到类似下图的输出。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-web.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-探索-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 探索&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;在全局范围内，您将看到Istio网格内所有请求的总和，如果你点击 &lt;code&gt;istio-mesh&lt;/code&gt; 气泡，就能查看你的网状网络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/vistio-mesh1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在你的 Istio 网格中，您可以使用许多可视化工具来帮助您查明故障的应用程序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WM6lx-4bms7YBO-EHs_a2g.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用屏幕右上方的过滤器可以快速过滤出错误率较高的应用程序。通过高级配置，当错误率超过特定值时，也可以触发警报。警报将显示给定应用程序的当前错误率趋势。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-问题排查-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 问题排查&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;访问 &lt;code&gt;http://vistio-api.istio.io/graph&lt;/code&gt;，如果你从 vistio-api 中看到以下输出，表示某些功能无法正常工作。正确的输出显示在教程上面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/TcFuNvCvk5C53rO4vXLkw.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;检查 vistio-api 日志中是否有错误——在大多数情况下，vistio-api 将记录与 Prometheus 通信时遇到的任何问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl logs -f $(kubectl get pod -l app=vistio-api -o go-template=&#39;{{range .items}}{{.metadata.name}}{{end}}&#39;) -c vistio-api
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;验证 Prometheus 查询——vistio-api 使用以下查询检索其数据。您应该确保 Prometheus 内部的数据都存在。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Global Level Query
sum(rate(istio_request_bytes_count{source_workload=&amp;quot;istio-ingressgateway&amp;quot;}[1m])) by (response_code)
# Cluster Level Query
sum(rate(istio_request_bytes_count[1m])) by (source_app,destination_service,response_code)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提交 Issue——如果遇到问题无法解决请提交 Issue：&lt;a href=&#34;https://github.com/nmnellis/vistio/issues&#34; target=&#34;_blank&#34;&gt;https://github.com/nmnellis/vistio/issues&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Istio 服务网格中的网关</title>
      <link>https://www.yangcs.net/posts/istio-ingress/</link>
      <pubDate>Thu, 02 Aug 2018 13:29:08 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/istio-ingress/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在一个典型的网格中，通常有一个或多个用于终结外部 TLS 链接，将流量引入网格的负载均衡器（我们称之为 gateway）。 然后流量通过边车网关（sidecar gateway）流经内部服务。 应用程序使用外部服务的情况也很常见（例如访问 Google Maps API），一些情况下，这些外部服务可能被直接调用；但在某些部署中，网格中所有访问外部服务的流量可能被要求强制通过专用的出口网关（Egress gateway）。 下图描绘了网关在网格中的使用情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/blog/2018/v1alpha3-routing/gateways.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;Istio服务网格中的网关&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code&gt;Gateway&lt;/code&gt; 是一个独立于平台的抽象，用于对流入专用中间设备的流量进行建模。下图描述了跨多个配置资源的控制流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/blog/2018/v1alpha3-routing/virtualservices-destrules.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;不同v1alpha3元素之间的关系&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-1-gateway-介绍-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. Gateway 介绍&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#Gateway&#34; target=&#34;_blank&#34;&gt;Gateway&lt;/a&gt; 用于为 HTTP / TCP 流量配置负载均衡器，并不管该负载均衡器将在哪里运行。 网格中可以存在任意数量的 Gateway，并且多个不同的 Gateway 实现可以共存。 实际上，通过在配置中指定一组工作负载（Pod）标签，可以将 Gateway 配置绑定到特定的工作负载，从而允许用户通过编写简单的 Gateway Controller 来重用现成的网络设备。&lt;/p&gt;

&lt;p&gt;对于入口流量管理，您可能会问： 为什么不直接使用 Kubernetes Ingress API ？ 原因是 Ingress API 无法表达 Istio 的路由需求。 Ingress 试图在不同的 HTTP 代理之间取一个公共的交集，因此只能支持最基本的 HTTP 路由，最终导致需要将代理的其他高级功能放入到注解（annotation）中，而注解的方式在多个代理之间是不兼容的，无法移植。&lt;/p&gt;

&lt;p&gt;Istio &lt;code&gt;Gateway&lt;/code&gt; 通过将 L4-L6 配置与 L7 配置分离的方式克服了 &lt;code&gt;Ingress&lt;/code&gt; 的这些缺点。 &lt;code&gt;Gateway&lt;/code&gt; 只用于配置 L4-L6 功能（例如，对外公开的端口，TLS 配置），所有主流的L7代理均以统一的方式实现了这些功能。 然后，通过在 &lt;code&gt;Gateway&lt;/code&gt; 上绑定 &lt;code&gt;VirtualService&lt;/code&gt; 的方式，可以使用标准的 Istio 规则来控制进入 &lt;code&gt;Gateway&lt;/code&gt; 的 HTTP 和 TCP 流量。&lt;/p&gt;

&lt;p&gt;例如，下面这个简单的 &lt;code&gt;Gateway&lt;/code&gt; 配置了一个 Load Balancer，以允许访问 host &lt;code&gt;bookinfo.com&lt;/code&gt; 的 https 外部流量进入网格中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: bookinfo-gateway
spec:
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - bookinfo.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要为进入上面的 Gateway 的流量配置相应的路由，必须为同一个 host 定义一个 &lt;a href=&#34;https://www.yangcs.net/posts/istio-traffic-management/&#34; target=&#34;_blank&#34;&gt;VirtualService&lt;/a&gt;（参考上一篇博文），并使用配置中的 &lt;code&gt;gateways&lt;/code&gt; 字段绑定到前面定义的 &lt;code&gt;Gateway&lt;/code&gt; 上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: bookinfo
spec:
  hosts:
    - bookinfo.com
  gateways:
  - bookinfo-gateway # &amp;lt;---- bind to gateway
    http:
  - match:
    - uri:
        prefix: /reviews
    route:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gateway 可以用于建模边缘代理或纯粹的内部代理，如第一张图所示。 无论在哪个位置，所有网关都可以用相同的方式进行配置和控制。&lt;/p&gt;

&lt;p&gt;下面通过一个示例来演示如何配置 Istio 以使用 Istio  Gateway 在服务网格外部公开服务。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-使用-istio-网关配置-ingress-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 使用 Istio 网关配置 Ingress&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;让我们看看如何为 Gateway 在 HTTP 80 端口上配置流量。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个 Istio Gateway&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  $ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
  apiVersion: networking.istio.io/v1alpha3
  kind: Gateway
  metadata:
    name: httpbin-gateway
  spec:
    selector:
      istio: ingressgateway # use Istio default gateway implementation
    servers:
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
      - &amp;quot;httpbin.example.com&amp;quot;
  EOF    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为通过 Gateway 进入的流量配置路由&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  $ cat &amp;lt;&amp;lt;EOF | istioctl create -f -
  apiVersion: networking.istio.io/v1alpha3
  kind: VirtualService
  metadata:
    name: httpbin
  spec:
    hosts:
    - &amp;quot;httpbin.example.com&amp;quot;
    gateways:
    - httpbin-gateway
    http:
    - match:
      - uri:
          prefix: /status
      - uri:
          prefix: /delay
      route:
      - destination:
          port:
            number: 8000
          host: httpbin
  EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们 为服务创建了一个 &lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService&#34; target=&#34;_blank&#34;&gt;VirtualService&lt;/a&gt; 配置 &lt;code&gt;httpbin&lt;/code&gt; ，其中包含两条路由规则，允许路径 &lt;code&gt;/status&lt;/code&gt; 和 路径的流量 &lt;code&gt;/delay&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该&lt;a href=&#34;https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService-gateways&#34; target=&#34;_blank&#34;&gt;网关&lt;/a&gt;列表指定，只有通过我们的要求 &lt;code&gt;httpbin-gateway&lt;/code&gt; 是允许的。所有其他外部请求将被拒绝，并返回 404 响应。&lt;/p&gt;

&lt;p&gt;请注意，在此配置中，来自网格中其他服务的内部请求不受这些规则约束，而是简单地默认为循环路由。要将这些（或其他规则）应用于内部调用，我们可以&lt;strong&gt;将特殊值 &lt;code&gt;mesh&lt;/code&gt; 添加到 &lt;code&gt;gateways&lt;/code&gt; 的列表中&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 curl 访问 httpbin 服务。&lt;/p&gt;

&lt;p&gt;首先获取 Ingress Gateway 的 IP 和 端口，参考上一篇文章：&lt;a href=&#34;https://www.yangcs.net/posts/istio-traffic-management/&#34; target=&#34;_blank&#34;&gt;Istio 流量管理&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -HHost:httpbin.example.com http://$INGRESS_HOST:$INGRESS_PORT/status/200
    
HTTP/1.1 200 OK
server: envoy
date: Thu, 02 Aug 2018 04:18:41 GMT
content-type: text/html; charset=utf-8
access-control-allow-origin: *
access-control-allow-credentials: true
content-length: 0
x-envoy-upstream-service-time: 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，我们使用该 &lt;code&gt;-H&lt;/code&gt; 标志将 Host &lt;code&gt;HTTP Header&lt;/code&gt; 设置为 “httpbin.example.com”。这是必需的，因为我们的 ingress &lt;code&gt;Gateway&lt;/code&gt; 被配置为处理 “httpbin.example.com”，但在我们的测试环境中，我们没有该主机的 DNS 绑定，并且只是将我们的请求发送到 ingress IP。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;访问任何未明确公开的其他 URL。您应该看到一个 HTTP 404 错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -HHost:httpbin.example.com http://$INGRESS_HOST:$INGRESS_PORT/headers
    
HTTP/1.1 404 Not Found
date: Thu, 02 Aug 2018 04:21:39 GMT
server: envoy
transfer-encoding: chunked
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-使用浏览器访问-ingress-服务-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 使用浏览器访问 Ingress 服务&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;如果你想在浏览器中输入 httpbin 服务的 URL 来访问是行不通的，因为我们没有办法像使用 curl 一样告诉浏览器假装访问 &lt;code&gt;httpbin.example.com&lt;/code&gt;，只能通过向 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件中添加 hosts 来解决这个问题。&lt;/p&gt;

&lt;p&gt;但是麻烦又来了，目前这种状况下即使你添加了 hosts，也仍然无法访问，因为 Istio Gateway 使用的是 NodePort 模式，暴露出来的不是 80 端口和 443 端口，而我们要想通过域名来访问服务，必须要求 Gateway 暴露出来的端口是 80 和 443。&lt;/p&gt;

&lt;p&gt;所以我们只能曲线救国了，通过修改 Ingress Gateway 的 &lt;code&gt;Deployment&lt;/code&gt;，将 80 端口和 443 端口配置为 &lt;code&gt;hostPort&lt;/code&gt; 模式，然后再通过 Node 亲和性将 &lt;code&gt;Gateway&lt;/code&gt; 调度到某个固定的主机上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n istio-system edit deployment istio-ingressgateway
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: istio-ingressgateway
  namespace: istio-system
  ...
spec:
  ...
  template:
    ...
    spec:
      affinity:
        nodeAffinity:
          ...
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/hostname
                operator: In
                values:
                - 192.168.123.248   # 比如你想调度到这台主机上
      containers:
        - name: ISTIO_META_POD_NAME
        ...
        - containerPort: 80
          hostPort: 80
          protocol: TCP
        - containerPort: 443
          hostPort: 443
          protocol: TCP
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改完之后保存退出，等待 Gateway 的 Pod 重新调度，然后在你的浏览器所在的本地电脑上添加一条 hosts：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;192.168.123.248 httpbin.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新配置 &lt;code&gt;VirtualService&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$  cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
 apiVersion: networking.istio.io/v1alpha3
 kind: VirtualService
 metadata:
   name: httpbin
 spec:
   hosts:
   - &amp;quot;httpbin.example.com&amp;quot;
     gateways:
   - httpbin-gateway
     http:
   - match:
     - uri:
         prefix: /status
     - uri:
         prefix: /delay
     - uri:
         prefix: /headers
     route:
     - destination:
         port:
           number: 8000
         host: httpbin
 EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就可以在浏览器中输入 URL：&lt;code&gt;http://httpbin.example.com/headers&lt;/code&gt; 来访问服务啦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/Jietu20180802-130152.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-清理-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 清理&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;删除 Gateway、VirtualService 和 httpbin 服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl delete gateway httpbin-gateway
$ istioctl delete virtualservice httpbin
$ kubectl delete --ignore-not-found=true -f samples/httpbin/httpbin.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-5-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 参考&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/docs/tasks/traffic-management/ingress/&#34; target=&#34;_blank&#34;&gt;控制 Ingress 流量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/docs/concepts/traffic-management/#gateway&#34; target=&#34;_blank&#34;&gt;Gateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Istio 流量管理</title>
      <link>https://www.yangcs.net/posts/istio-traffic-management/</link>
      <pubDate>Wed, 01 Aug 2018 20:59:11 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/istio-traffic-management/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Istio 从 0.8 版本开始出现了一个新的 API 组：&lt;a href=&#34;http://networking.istio.io/v1alpha3&#34; target=&#34;_blank&#34;&gt;networking.istio.io/v1alpha3&lt;/a&gt;，应该会替代现有的 &lt;a href=&#34;http://config.istio.io/v1alpha2&#34; target=&#34;_blank&#34;&gt;config.istio.io/v1alpha2&lt;/a&gt; API。新的 API 不管是结构上还是功能上、以及命名上，都有很大差异。如果不作特殊说明，本文所有的示例将采用新版 API。&lt;/p&gt;

&lt;p&gt;本文将通过简单的示例来演示通过 Istio 实现应用的金丝雀部署。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;正常情况下 istioctl 和 kubectl 都可以用来操作这些对象，但是 kubectl 缺乏验证功能，因此调试阶段使用 &lt;code&gt;istioctl&lt;/code&gt; 会更方便一些。&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;p-id-h2-1-bookinfo-应用介绍-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. Bookinfo 应用介绍&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;以 Bookinfo 应用为示例，它由四个单独的微服务构成，用来演示多种 Istio 特性。这个应用模仿在线书店的一个分类，显示一本书的信息。页面上会显示一本书的描述，书籍的细节（ISBN、页数等），以及关于这本书的一些评论。&lt;/p&gt;

&lt;p&gt;Bookinfo 应用分为四个单独的微服务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;productpage&lt;/code&gt; ：&lt;code&gt;productpage&lt;/code&gt; 微服务会调用 &lt;code&gt;details&lt;/code&gt; 和 &lt;code&gt;reviews&lt;/code&gt; 两个微服务，用来生成页面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;details&lt;/code&gt; ：这个微服务包含了书籍的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reviews&lt;/code&gt; ：这个微服务包含了书籍相关的评论。它还会调用 ratings 微服务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ratings&lt;/code&gt; ：&lt;code&gt;ratings&lt;/code&gt; 微服务中包含了由书籍评价组成的评级信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;reviews&lt;/code&gt; 微服务有 3 个版本：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;v1 版本不会调用 &lt;code&gt;ratings&lt;/code&gt; 服务。&lt;/li&gt;
&lt;li&gt;v2 版本会调用 &lt;code&gt;ratings&lt;/code&gt; 服务，并使用 1 到 5 个黑色星形图标来显示评分信息。&lt;/li&gt;
&lt;li&gt;v3 版本会调用 &lt;code&gt;ratings&lt;/code&gt; 服务，并使用 1 到 5 个红色星形图标来显示评分信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图展示了这个应用的端到端架构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/docs/examples/bookinfo/noistio.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;Istio 注入之前的 Bookinfo 应用&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Bookinfo 是一个异构应用，几个微服务是由不同的语言编写的。这些服务对 Istio 并无依赖，但是构成了一个有代表性的服务网格的例子：它由多个服务、多个语言构成，并且 &lt;code&gt;reviews&lt;/code&gt; 服务具有多个版本。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-2-部署-bookinfo-应用-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 部署 Bookinfo 应用&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;要在 Istio 中运行这一应用，无需对应用自身做出任何改变。我们只要简单的在 Istio 环境中对服务进行配置和运行，具体一点说就是把 Envoy sidecar 注入到每个服务之中。这个过程所需的具体命令和配置方法由运行时环境决定，而部署结果较为一致，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/docs/examples/bookinfo/withistio.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;em&gt;Bookinfo 应用&lt;/em&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;所有的微服务都和 Envoy sidecar 集成在一起，被集成服务所有的出入流量都被 sidecar 所劫持，这样就为外部控制准备了所需的 Hook，然后就可以利用 Istio 控制平面为应用提供服务路由、遥测数据收集以及策略实施等功能。&lt;/p&gt;

&lt;p&gt;接下来可以根据 Istio 的运行环境，按照下面的讲解完成应用的部署。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;进入 Istio 安装目录。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动应用容器：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果集群用的是&lt;a href=&#34;https://istio.io/docs/setup/kubernetes/sidecar-injection/#manual-sidecar-injection&#34; target=&#34;_blank&#34;&gt;手工 Sidecar 注入&lt;/a&gt;，使用如下命令：
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  $ kubectl apply -f &amp;lt;(istioctl kube-inject -f samples/bookinfo/platform/kube/bookinfo.yaml)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://istio.io/docs/reference/commands/istioctl/#istioctl-kube-inject&#34; target=&#34;_blank&#34;&gt;istioctl kube-inject&lt;/a&gt; 命令用于在在部署应用之前修改 &lt;code&gt;bookinfo.yaml&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果集群使用的是&lt;a href=&#34;https://istio.io/docs/setup/kubernetes/sidecar-injection/#automatic-sidecar-injection&#34; target=&#34;_blank&#34;&gt;自动 Sidecar 注入&lt;/a&gt;，只需简单的 &lt;code&gt;kubectl&lt;/code&gt; 就能完成服务的部署。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  $ kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的命令会启动全部的四个服务，其中也包括了 &lt;code&gt;reviews&lt;/code&gt; 服务的三个版本（&lt;code&gt;v1&lt;/code&gt;、&lt;code&gt;v2&lt;/code&gt; 以及 &lt;code&gt;v3&lt;/code&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给应用定义 Ingress gateway：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl apply -f samples/bookinfo/networking/bookinfo-gateway.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确认所有的服务和 Pod 都已经正确的定义和启动：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get services
  
NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                         AGE
details       ClusterIP   10.254.86.98     &amp;lt;none&amp;gt;        9080/TCP                        3h
kubernetes    ClusterIP   10.254.0.1       &amp;lt;none&amp;gt;        443/TCP                         149d
productpage   ClusterIP   10.254.199.214   &amp;lt;none&amp;gt;        9080/TCP                        3h
ratings       ClusterIP   10.254.102.147   &amp;lt;none&amp;gt;        9080/TCP                        3h
reviews       ClusterIP   10.254.249.86    &amp;lt;none&amp;gt;        9080/TCP                        3h
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pods
  
NAME                              READY     STATUS    RESTARTS   AGE
details-v1-6456dbdb9-crqnw        2/2       Running   0          3h
productpage-v1-6f6887645c-52qhn   2/2       Running   0          3h
ratings-v1-648cf76d8f-g65s5       2/2       Running   0          3h
reviews-v1-7dcbc85bb5-j748n       2/2       Running   0          3h
reviews-v2-65fd78f5df-r8n6r       2/2       Running   0          3h
reviews-v3-95c85969c-zmpfx        2/2       Running   0          3h
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确定 Ingress 的 IP 和端口&lt;/p&gt;

&lt;p&gt;执行以下命令以确定 &lt;code&gt;ingressgateway&lt;/code&gt; 是否启用了 NodePort 模式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n istio-system get svc istio-ingressgateway

NAME                   TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                                                                                                     AGE
istio-ingressgateway   NodePort   10.254.160.93   &amp;lt;none&amp;gt;        80:31380/TCP,443:31390/TCP,31400:31400/TCP,15011:25059/TCP,8060:36612/TCP,15030:25049/TCP,15031:36810/TCP   3h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确定 ingress IP：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export INGRESS_HOST=$(kubectl -n istio-system get po -l istio=ingressgateway -o go-template=&#39;{{range .items}}{{.status.hostIP}}{{end}}&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确定端口：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export INGRESS_PORT=$(kubectl -n istio-system get svc istio-ingressgateway -o go-template=&#39;{{range .spec.ports}}{{if eq .name &amp;quot;http&amp;quot;}}{{.nodePort}}{{end}}{{end}}&#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置 &lt;code&gt;GATEWAY_URL&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ export GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面可以用 &lt;code&gt;curl&lt;/code&gt; 命令来确认 Bookinfo 应用的运行情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -o /dev/null -s -w &amp;quot;%{http_code}\n&amp;quot; http://${GATEWAY_URL}/productpage

200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以用浏览器打开网址 &lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;，来浏览应用的 Web 页面。如果刷新几次应用的页面，就会看到页面中会随机展示 &lt;code&gt;reviews&lt;/code&gt; 服务的不同版本的效果（红色、黑色的星形或者没有显示）。&lt;code&gt;reviews&lt;/code&gt; 服务出现这种情况是因为我们还没有使用 Istio 来控制版本的路由。&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-3-金丝雀部署-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 金丝雀部署&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;由于 Bookinfo 示例部署了三个版本的 reviews 微服务，因此我们需要设置默认路由。 否则，如果您当多次访问应用程序，您会注意到有时输出包含星级评分，有时又没有。 这是因为没有为应用明确指定缺省路由时，Istio 会将请求随机路由到该服务的所有可用版本上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://istio.io/docs/concepts/traffic-management/ServiceModel_Versions.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;此任务假定您尚未设置任何路由。 如果您已经为示例应用程序创建了存在冲突的路由规则，则需要在下面的命令中使用 &lt;code&gt;replace&lt;/code&gt; 代替 &lt;code&gt;create&lt;/code&gt;。 请注意：本文档假设还没有设置任何路由规则。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;首先将所有微服务的默认路由设置为 v1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl create -f samples/bookinfo/networking/virtual-service-all-v1.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl create -f samples/bookinfo/networking/destination-rule-all.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过下面的命令来显示已创建的路由规则：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ istioctl get virtualservices -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: details
  ...
spec:
  hosts:
  - details
  http:
  - route:
    - destination:
        host: details
        subset: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: productpage
  ...
spec:
  gateways:
  - bookinfo-gateway
  - mesh
  hosts:
  - productpage
  http:
  - route:
    - destination:
        host: productpage
        subset: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: ratings
  ...
spec:
  hosts:
  - ratings
  http:
  - route:
    - destination:
        host: ratings
        subset: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
  ...
spec:
  hosts:
  - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v1
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于路由规则是通过异步方式分发到代理的，因此在尝试访问应用程序之前，您应该等待几秒钟，以便规则传播到所有 pod 上。&lt;/p&gt;

&lt;p&gt;现在在浏览器中打开 Bookinfo 应用程序的 URL (&lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;)，你应该可以看到 Bookinfo 应用程序的 &lt;code&gt;productpage&lt;/code&gt; 页面。 请注意， &lt;code&gt;productpage&lt;/code&gt; 页面显示的内容中没有评分星级，这是因为 &lt;code&gt;reviews:v1&lt;/code&gt; 服务不会访问 ratings 服务。&lt;/p&gt;

&lt;p&gt;由于新的 API 引入了一些新的配置资源，而且不向后兼容，所以很有必要来解释一下上面两个 yaml 文件提到的两个新概念：&lt;code&gt;VirtualService&lt;/code&gt; 和 &lt;code&gt;DestinationRule&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;virtualservice&#34;&gt;VirtualService&lt;/h4&gt;

&lt;p&gt;过去的路由分配比较简单，使用标签即可。新的版本中，提出了 VirtualService 的概念。&lt;span id=&#34;inline-blue&#34;&gt;VirtualService&lt;/span&gt; 由一组路由规则构成，用于对服务实体（在 K8S 中对应为 Pod）进行寻址。一旦有流量符合其中规则的选择条件，就会发送流量给对应的服务（或者服务的一个版本/子集）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;VirtualService&lt;/code&gt; 描述了一个或多个用户可寻址目标到网格内实际工作负载之间的映射。其中可寻址的目标服务使用 &lt;code&gt;hosts&lt;/code&gt; 字段来指定，而网格内的实际工作负载由每个 &lt;code&gt;route&lt;/code&gt; 配置项中的 &lt;code&gt;destination&lt;/code&gt; 字段指定。在上面的示例中，这两个地址是相同的，但实际上用户可寻址目标可以是任何用于定位服务的、具有可选通配符前缀或 CIDR 前缀的 DNS 名称。&lt;/p&gt;

&lt;p&gt;流量的特征除了请求数据之外，还包括流量的来源，这样就能根据一些上下文来进行灵活的定义了。&lt;/p&gt;

&lt;p&gt;例如，以下规则定义来自打了标签 &lt;code&gt;app=sleep&lt;/code&gt; 的 Pod 对 php-server 的请求，都转向 v1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3

kind: VirtualService

metadata:

  name: sleep-server-route

spec:

  hosts:

  - &amp;quot;php-server&amp;quot;

  http:

  - match:

    - sourceLabels:

        app: sleep

    route:

    - destination:

        name: php-server

        subset: v1

  - route:

    - destination:

        name: php-server

        subset: v2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里的匹配策略是具有从上到下的优先级的，也就是说，最下一条就是缺省路由。所以没有打标签 app=sleep 的 Pod 对 php-server 的请求，都转向 v2。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而本文的 Bookinfo 示例中创建的路由规则表示：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有对 details 的请求，都转向 details 的 v1 版本。&lt;/li&gt;
&lt;li&gt;所有对 productpage 的请求，都转向 productpage 的 v1 版本。&lt;/li&gt;
&lt;li&gt;所有对 ratings 的请求，都转向 ratings 的 v1 版本。&lt;/li&gt;
&lt;li&gt;所有对 reviews 的请求，都转向 reviews 的 v1 版本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以看到，&lt;code&gt;match&lt;/code&gt; 中不再包含 &lt;code&gt;source&lt;/code&gt;，这里使用标签来过滤。写完应用之后，我们再次访问 Bookinfo 应用程序的 URL (&lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;)，会发现并没有生效。这是因为，&lt;strong&gt;在 v3 版本的 API 中，目标规则不再是透明了&lt;/strong&gt;，路由定义必须以目标策略为基础。&lt;/p&gt;

&lt;h4 id=&#34;destinationrule&#34;&gt;DestinationRule&lt;/h4&gt;

&lt;p&gt;因此这里需要定义一个 &lt;span id=&#34;inline-blue&#34;&gt;DestinationRule&lt;/span&gt; 对象，来满足上面的目标需求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: productpage
spec:
  host: productpage
  subsets:
  - name: v1
    labels:
      version: v1
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: reviews
spec:
  host: reviews
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
  - name: v3
    labels:
      version: v3
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: ratings
spec:
  host: ratings
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
  - name: v2-mysql
    labels:
      version: v2-mysql
  - name: v2-mysql-vm
    labels:
      version: v2-mysql-vm
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: details
spec:
  host: details
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DestinationRule 用于配置在将流量转发到服务时应用的策略集。这些策略应由服务提供者撰写，用于描述断路器、负载均衡、TLS 设置等。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DestinationRule 的 &lt;code&gt;host&lt;/code&gt; 可以包含通配符前缀，以允许单个规则应用于多个服务。&lt;/li&gt;
&lt;li&gt;DestinationRule 定义了目的 host 的子集 &lt;code&gt;subsets&lt;/code&gt; （例如：命名版本）。 这些 subset 用于 &lt;code&gt;VirtualService&lt;/code&gt; 的路由规则设置中，可以将流量导向服务的某些特定版本。通过这种方式为版本命名后，可以在不同的虚拟服务中明确地引用这些命名版本的 subset，简化 Istio 代理发出的统计数据，并可以将 subsets 编码到 SNI 头中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在再次访问 Bookinfo 应用程序的 URL (&lt;code&gt;http://$GATEWAY_URL/productpage&lt;/code&gt;)，会发现规则已经生效了。&lt;/p&gt;

&lt;h4 id=&#34;示例一-将-10-请求发送到-v2-版本而其余-90-发送到-v1-版本-br&#34;&gt;示例一：将 10% 请求发送到 v2 版本而其余 90% 发送到 v1 版本&lt;br /&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
    - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v1
      weight: 90
    - destination:
        host: reviews
        subset: v2
      weight: 10
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在的规则就是刷新 productpage 页面，90% 的概率看到黑色星标的评论，10%的概率看不到星标。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;因为使用Envoy sidecar的实现，你需要刷新页面很多次才能看到接近规则配置的概率分布。&lt;/p&gt;

&lt;h4 id=&#34;示例二-将-jason-用户的请求全部发到-v2-版本&#34;&gt;示例二：将 jason 用户的请求全部发到 v2 版本&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
    - reviews
  http:
  - match:
    - headers:
        end-user:
          exact: jason
    route:
    - destination:
        host: reviews
        subset: v2
  - route:
    - destination:
        host: reviews
        subset: v1
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;jason&lt;/code&gt; 用户登陆 productpage 页面，你可以看到每个刷新页面时，页面上都有一个1到5颗星的评级。如果你使用其他用户登陆的话，将因继续使用 &lt;code&gt;reviews:v1&lt;/code&gt; 而看不到星标评分。&lt;/p&gt;

&lt;h4 id=&#34;示例三-全部切换到-v3-版本&#34;&gt;示例三：全部切换到 v3 版本&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cat &amp;lt;&amp;lt;EOF | istioctl replace -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
  - reviews
  http:
  - route:
    - destination:
        host: reviews
        subset: v3
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在不论你使用什么用户登陆 productpage 页面，你都可以看到带红色星标评分的评论了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&#34;p-id-h2-4-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 参考&lt;/p&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.fleeto.us/post/istio-route-alpha1v3/&#34; target=&#34;_blank&#34;&gt;摸索：Istio 路由规则 Alpha v3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://istio.io/zh/docs/tasks/traffic-management/request-routing/&#34; target=&#34;_blank&#34;&gt;配置请求路由&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Istio 1.0 部署</title>
      <link>https://www.yangcs.net/posts/istio-1.0-deploy/</link>
      <pubDate>Wed, 01 Aug 2018 15:33:46 +0800</pubDate>
      
      <guid>https://www.yangcs.net/posts/istio-1.0-deploy/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;北京时间 2018 年 8 月 1 日（建军节）凌晨 0 点，Istio 宣布推出 1.0 正式版本，并表示已可用于生产环境。这距离最初的 0.1 版本发布已过去一年多的时间。这个项目的组件相对比较复杂，原有的一些选项是靠 ConfigMap 以及 istioctl 分别调整的，现在通过重新设计的 &lt;code&gt;Helm Chart&lt;/code&gt;，安装选项用 &lt;code&gt;values.yml&lt;/code&gt; 或者 helm 命令行的方式来进行集中管理了。&lt;/p&gt;

&lt;p&gt;在安装 Istio 之前要确保 Kubernetes 集群（仅支持 &lt;code&gt;v1.9&lt;/code&gt; 及以后版本）已部署并配置好本地的 kubectl 客户端。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-下载-istio-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 下载 Istio&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget https://github.com/istio/istio/releases/download/1.0.0/istio-1.0.0-linux.tar.gz
$ tar zxf istio-1.0.0-linux.tar.gz
$ cp istio-1.0.0/bin/istioctl /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-2-使用-helm-部署-istio-服务-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 使用 Helm 部署 Istio 服务&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;克隆 Istio 仓库：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/istio/istio.git
$ cd istio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装包内的 Helm 目录中包含了 Istio 的 Chart，官方提供了两种方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用 Helm 生成 &lt;code&gt;istio.yaml&lt;/code&gt;，然后自行安装。&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;Tiller&lt;/code&gt; 直接安装。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很明显，两种方法并没有什么本质区别，这里我们采用第一种方法来部署。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm template install/kubernetes/helm/istio --name istio --namespace istio-system --set sidecarInjectorWebhook.enabled=true --set ingress.service.type=NodePort --set gateways.istio-ingressgateway.type=NodePort --set gateways.istio-egressgateway.type=NodePort --set tracing.enabled=true --set servicegraph.enabled=true --set prometheus.enabled=true --set tracing.jaeger.enabled=true --set grafana.enabled=true &amp;gt; istio.yaml

$ kubectl create namespace istio-system
$ kubectl create -f istio.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里说的是使用 &lt;code&gt;install/kubernetes/helm/istio&lt;/code&gt; 目录中的 Chart 进行渲染，生成的内容保存到 &lt;code&gt;./istio.yaml&lt;/code&gt; 文件之中。将 &lt;code&gt;sidecarInjectorWebhook.enabled&lt;/code&gt; 设置为 true，从而使自动注入属性生效。&lt;/p&gt;

&lt;p&gt;部署完成后，可以检查 &lt;code&gt;isotio-system&lt;/code&gt; namespace 中的服务是否正常运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl -n istio-system get pods -o go-template=&#39;{{range .items}}{{.metadata.name}}{{&amp;quot;\n&amp;quot;}}{{end}}&#39;

istio-citadel-f5779fbbb-brbxd
istio-cleanup-secrets-jjqg5
istio-egressgateway-6c5cc7dd86-l2c82
istio-galley-6bf8f6f4b7-twvzl
istio-ingressgateway-fbfdfc5c7-fg9xh
istio-pilot-85df58955d-g5bfh
istio-policy-74c48c8ccb-wd6h6
istio-sidecar-injector-cf5999cf8-h9smx
istio-statsd-prom-bridge-55965ff9c8-2hmzf
istio-telemetry-cb49594cc-gfd84
istio-tracing-77f9f94b98-9xvzs
prometheus-7456f56c96-xcdh4
servicegraph-5b8d7b4d5-lzhth
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;过去的 istio-ca 现已更名 &lt;code&gt;istio-citadel&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istio-cleanup-secrets&lt;/code&gt; 是一个 job，用于清理过去的 Istio 遗留下来的 CA 部署（包括 sa、deploy 以及 svc 三个对象）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;egressgateway&lt;/code&gt;、&lt;code&gt;ingress&lt;/code&gt; 以及 &lt;code&gt;ingressgateway&lt;/code&gt;，可以看出边缘部分的变动很大，以后会另行发文。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;p-id-h2-3-prometheus-grafana-servicegraph-和-jaeger-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. Prometheus、Grafana、Servicegraph 和 Jaeger&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;等所有 Pod 启动后，可以通过 NodePort、Ingress 或者 kubectl proxy 来访问这些服务。比如可以通过 &lt;code&gt;Ingress&lt;/code&gt; 来访问服务。&lt;/p&gt;

&lt;p&gt;首先为 Prometheus、Grafana、Servicegraph 和 Jaeger 服务创建 Ingress：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;$ cat ingress.yaml

---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: prometheus
  namespace: istio-system
spec:
  rules:
  - host: prometheus.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: prometheus
          servicePort: 9090
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: grafana
  namespace: istio-system
spec:
  rules:
  - host: grafana.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: grafana
          servicePort: 3000
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: servicegraph
  namespace: istio-system
spec:
  rules:
  - host: servicegraph.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: servicegraph
          servicePort: 8088
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: tracing
  namespace: istio-system
spec:
  rules:
  - host: tracing.istio.io
    http:
      paths:
      - path: /
        backend:
          serviceName: tracing
          servicePort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl create -f ingress.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你的本地电脑上添加四条 &lt;code&gt;hosts&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$Ingree_host prometheus.istio.io
$Ingree_host grafana.istio.io
$Ingree_host servicegraph.istio.io
$Ingree_host tracing.istio.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 &lt;code&gt;$Ingree_host&lt;/code&gt; 替换为 Ingress Controller 运行节点的 IP。&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;http://grafana.istio.io&lt;/code&gt; 访问 Grafana 服务：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-mesh.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-service.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;http://servicegraph.istio.io&lt;/code&gt; 访问 ServiceGraph 服务，展示服务之间调用关系图。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/force/forcegraph.html&lt;/code&gt; : As explored above, this is an interactive &lt;a href=&#34;https://d3js.org/&#34; target=&#34;_blank&#34;&gt;D3.js&lt;/a&gt; visualization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-servicegraph.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/dotviz&lt;/code&gt; : is a static &lt;a href=&#34;https://www.graphviz.org/&#34; target=&#34;_blank&#34;&gt;Graphviz&lt;/a&gt; visualization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/servicegraph-dotviz1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/dotgraph&lt;/code&gt; : provides a [DOT](&lt;a href=&#34;https://www.wikiwand.com/en/DOT_(graph_description_language&#34; target=&#34;_blank&#34;&gt;https://www.wikiwand.com/en/DOT_(graph_description_language&lt;/a&gt;) serialization.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/d3graph&lt;/code&gt; : provides a JSON serialization for D3 visualization.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://servicegraph.istio.io/graph&lt;/code&gt; : provides a generic JSON serialization.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过 &lt;code&gt;http://tracing.istio.io/&lt;/code&gt; 访问 Jaeger 跟踪页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/zipkin-jaeger.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过 &lt;code&gt;http://prometheus.istio.io/&lt;/code&gt; 访问 Prometheus 页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/istio-prometheus.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;如果你已经部署了 &lt;code&gt;Prometheus-operator&lt;/code&gt;，可以不必部署 Grafana，直接将 &lt;code&gt;addons/grafana/dashboards&lt;/code&gt; 目录下的 Dashboard 模板复制出来放到 Prometheus-operator 的 Grafana 上，然后添加 istio-system 命名空间中的 Prometheus 数据源就可以监控 Istio 了。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-4-mesh-expansion-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. Mesh Expansion&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Istio 还支持管理非 Kubernetes 管理的应用。此时，需要在应用所在的 VM 或者物理中部署 Istio，具体步骤请参考 &lt;a href=&#34;https://istio.io/docs/setup/kubernetes/mesh-expansion/&#34; target=&#34;_blank&#34;&gt;Mesh Expansion&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;部署好后，就可以向 Istio 注册应用，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# istioctl register servicename machine-ip portname:port
$ istioctl -n onprem register mysql 1.2.3.4 3306
$ istioctl -n onprem register svc1 1.2.3.4 http:7000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-5-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 参考&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.fleeto.us/post/istio-0.8.0-helm/&#34; target=&#34;_blank&#34;&gt;Istio 0.8 的 Helm Chart 解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>干货与湿货分享第3期</title>
      <link>https://www.yangcs.net/posts/weekly-3/</link>
      <pubDate>Sun, 29 Jul 2018 09:38:28 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/weekly-3/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;这是《干货与湿货分享》系列的第三期，主要记录过去一周我所见到的听到的值得分享的东西。（由于本周六事情比较多，所以推迟到了周日发布）&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-新闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;新闻&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-单身税时代即将来临-https-wallstreetcn-com-articles-3343352&#34;&gt;1. &lt;a href=&#34;https://wallstreetcn.com/articles/3343352&#34; target=&#34;_blank&#34;&gt;单身税时代即将来临&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://wpimg.wallstcn.com/088c1b19-0bf8-4f39-ab78-60ca5330bebb&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&#34;http://i.ce.cn/newwap/yw/gd/201806/29/W020180629472333441689.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;单身税的历史可以追溯到 2015 年韩国的新政，低生育率逼得韩国产生了这一政策。现在我国也要变相实行这一政策，很多单身狗就受不了了，各种吐槽。&lt;/p&gt;

&lt;p&gt;很可惜，国家不包分配对象，男的都说找对象难，女的相对于男的来说，对象也很难找。这时候我觉得只有 Python 能够通过数据分析帮你找对象了。。。。&lt;/p&gt;

&lt;h3 id=&#34;2-中国撤回-facebook-在华成立子公司的许可-https-cn-reuters-com-article-china-facebookapproval-pulls-0725-idcnkbs1kg029&#34;&gt;2. &lt;a href=&#34;https://cn.reuters.com/article/china-facebookapproval-pulls-0725-idCNKBS1KG029&#34; target=&#34;_blank&#34;&gt;中国撤回 Facebook 在华成立子公司的许可&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://static.leiphone.com/uploads/new/article/740_740/201807/5b574f2450c6f.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;前几日，一家名为“脸书科技（杭州）有限公司”的企业已经于 2018 年 7 月 18 日完成注册，注册资本为 3000 万美元，法定代表人为张京梅。值得一提是，这家公司由 Facebook Hong Kong Limited 100% 持股，是一家完全意义上的外资公司，可以确认，这家公司正是 Facebook 的全资子公司。&lt;/p&gt;

&lt;p&gt;但好景不长，几天之后注册信息消失了，许可证也被撤回。知情人士表示，这一态度突变并没有完全终结 Facebook 设立该公司的机会，但可能性也不是特别大，一首凉凉送给扎克伯格。。。&lt;/p&gt;

&lt;h3 id=&#34;3-世纪月全食遇上火星冲-世人抬头看-红月亮-奇景-https-www-bbc-com-zhongwen-simp-science-44990456&#34;&gt;3. &lt;a href=&#34;https://www.bbc.com/zhongwen/simp/science-44990456&#34; target=&#34;_blank&#34;&gt;世纪月全食遇上火星冲：世人抬头看“红月亮”奇景&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/moonlight.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;北京香港台湾时间周六（7月28日）凌晨，地球运行到刚好在太阳与月球之间的位置，阻挡了大部份通常会照射到月球的光线，为各地的天文爱好者上演本世纪最长的月全食。在世纪月全食发生之际，也是15年来最大、最亮的“火星冲”，闪耀红光的火星与“红月亮”相距不到10度。&lt;/p&gt;

&lt;h3 id=&#34;4-苹果申请新专利要在-macbook-上提供无线充电功能-http-www-toodaylab-com-72394&#34;&gt;4. &lt;a href=&#34;http://www.toodaylab.com/72394&#34; target=&#34;_blank&#34;&gt;苹果申请新专利要在 MacBook 上提供无线充电功能&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://files.toodaylab.com/2018/07/bpr_charge_20180728225512_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;据 GSMArena 的报道，美国专利商标局日前披露了一项苹果申请中的专利，简单的说就是在笔记本电脑上提供无线充电功能，未来只需要把手机放在电脑上就能给手机充电。这或许是在 Touch Bar 之后，苹果在电脑硬件上又给出了一个新的可能性？&lt;/p&gt;

&lt;h3 id=&#34;5-苹果为日本水灾受灾户提供免费产品维修服务-https-cn-engadget-com-2018-07-27-apple-will-repair-devices-damaged-by-flooding-in-japan-for-free&#34;&gt;5. &lt;a href=&#34;https://cn.engadget.com/2018/07/27/apple-will-repair-devices-damaged-by-flooding-in-japan-for-free/&#34; target=&#34;_blank&#34;&gt;苹果为日本水灾受灾户提供免费产品维修服务&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://s.aolcdn.com/hss/storage/midas/67604f767cab4a28a9ae9b1eda12401c/206557896/flood-ed.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;流年不利的日本，今年天灾似乎一个接着一个，稍早发生在本州中部与西部的大水灾更是已经造成了 225 人死亡、800 万人撤离，成为日本自 1982 年来最惨重的一次水灾。为了表示对受灾区复兴的支持，苹果宣布了因水灾受损的 iPhone、Mac、iPad、iPod、Apple Watch 和 Apple Display 等产品（配件、Beats 系列不在列）都可以免费获得维修服务，只要先拨打支持电话 0120-27753-5 申请，再寄送给苹果即可。如果修得好的话，苹果会在维修完成后，再将产品寄回，服务期间一直到九月底为止。&lt;/p&gt;

&lt;h3 id=&#34;6-亚马逊面部识别系统闹乌龙-28名美国会议员被误认成罪犯-http-news-ifeng-com-a-20180728-59468283-0-shtml&#34;&gt;6. &lt;a href=&#34;http://news.ifeng.com/a/20180728/59468283_0.shtml&#34; target=&#34;_blank&#34;&gt;亚马逊面部识别系统闹乌龙，28名美国会议员被误认成罪犯&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://p0.ifengimg.com/pmop/2018/0728/9475AB140B7F2C4677A85B6CD790291551F2903E_size275_w600_h413.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;商业巨头亚马逊 2016 年推出图像识别 AI 系统 “Rekognition”，还积极向美国警方推销以帮助其办案。不过近日，“Rekognition” 却闹了一个大乌龙：28名美国国会议员被它识别成了罪犯。&lt;/p&gt;

&lt;p&gt;这一错误也让发起这项测试、反对警方使用 “Rekognition” 的美国公民自由联盟（ACLU）抓到把柄，他们表示，测试结果引起了民众对警方使用该系统的严重担忧。&lt;/p&gt;

&lt;h3 id=&#34;7-广义相对论首次在超大黑洞附近获验证-http-www-stdaily-com-index-kejixinwen-2018-07-29-content-694417-shtml&#34;&gt;7. &lt;a href=&#34;http://www.stdaily.com/index/kejixinwen/2018-07/29/content_694417.shtml&#34; target=&#34;_blank&#34;&gt;广义相对论首次在超大黑洞附近获验证&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;又一次，爱因斯坦被证明是正确的。一个国际天文学家团队两天前宣布，他们利用大型地面望远镜对银河系中心进行观测，第一次证实超大黑洞附近的引力场效应与广义相对论百余年前的预测“完美符合”。&lt;/p&gt;

&lt;p&gt;根据爱因斯坦的广义相对论，光线在强引力场作用下会出现拉伸现象，波长变长，向红波方向偏移，这被称为引力红移效应。黑洞具有超强引力，甚至连光都无法从中逃逸，被认为是检验广义相对论强引力场理论的“完美实验室”。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-工具-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;工具&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-随身卡包-支持-100-多个商家和品牌会员卡的微信小程序-https-www-appinn-com-suishen-kabao&#34;&gt;1. &lt;a href=&#34;https://www.appinn.com/suishen-kabao/&#34; target=&#34;_blank&#34;&gt;随身卡包 – 支持 100 多个商家和品牌会员卡的微信小程序&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://img3.appinn.com/images/201807/img_20180713_134250.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;随身卡包 是一款非常方便实用的微信小程序，它可以将多达 100 多家商家与品牌的会员卡集合在一起，以后出门再也不用带会员卡了。&lt;/p&gt;

&lt;p&gt;随身卡包 的分享功能也非常易用，只需要在卡片详细页面点击菜单、分享，就能分享给微信好友了，好友拿到了无需注册，只需要点一下“收下”，以后就能继续使用了。&lt;/p&gt;

&lt;p&gt;在微信小程序中直接搜索 &lt;strong&gt;“随身卡包”&lt;/strong&gt; 即可。&lt;/p&gt;

&lt;h3 id=&#34;2-werss-将-微信公众号-转换为-rss-https-werss-app&#34;&gt;2. &lt;a href=&#34;https://werss.app/&#34; target=&#34;_blank&#34;&gt;WeRss – 将「微信公众号」转换为 RSS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;WeRss 是一款能够将「微信公众号」转换为 RSS 地址的服务，免费用户支持最多订阅 8 个公众号，并且支持将多个公众号聚合成一个 RSS，需要微信扫码登录。&lt;/p&gt;

&lt;p&gt;微信公众号这种差不多替代了 RSS 的玩法，让很多 RSS 用户很头痛啊，之前有不少方法可以转换为 RSS 订阅地址，结果死掉的差不多了。&lt;/p&gt;

&lt;p&gt;WeRss 是一个新的选择。有个注意事项是每个人都必须使用自己的微信扫码登录，获取 RSS 地址来订阅。&lt;/p&gt;

&lt;h3 id=&#34;3-问题疫苗查询-微信小程序-https-m-sohu-com-a-243389844-114774-pvid-000115-3w-a&#34;&gt;3. &lt;a href=&#34;https://m.sohu.com/a/243389844_114774/?pvid=000115_3w_a&#34; target=&#34;_blank&#34;&gt;“问题疫苗查询” 微信小程序&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;继阿里、百度都上线疫苗查询工具后，日前腾讯官方也宣布推出了问题疫苗查询微信小程序“腾通讯安心计划”，供用户查询和了解疫苗安全。&lt;/p&gt;

&lt;p&gt;用户进入“腾通讯安心计划”小程序后，点击“疫苗查询入口”手动输入接种证上的疫苗批次号，即可查询该批疫苗是否被监管部门列入“无效疫苗”。&lt;/p&gt;

&lt;h3 id=&#34;4-疫苗批号反查生产企业-http-ym-pppet-net&#34;&gt;4. &lt;a href=&#34;http://ym.pppet.net/&#34; target=&#34;_blank&#34;&gt;疫苗批号反查生产企业&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;伪劣疫苗牵动每一位中国人的心，面对假劣疫苗，同事连夜做了个通过疫苗批号反查生产企业的工具，希望有一点帮助。&lt;/p&gt;

&lt;h3 id=&#34;5-go-cloud-https-github-com-google-go-cloud&#34;&gt;5. &lt;a href=&#34;https://github.com/google/go-cloud&#34; target=&#34;_blank&#34;&gt;go-cloud&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;还在为兼容不同的云平台 SDK 而烦恼吗？go-cloud 通过封装不同云平台的接口，向用户提供统一的 API。例如：阿里云和腾讯云的存储桶 API 不一样，但是通过 go-cloud 的封装，可以使用统一的 API 调用&lt;/p&gt;

&lt;h3 id=&#34;6-go-mysql-https-github-com-siddontang-go-mysql&#34;&gt;6. &lt;a href=&#34;https://github.com/siddontang/go-mysql&#34; target=&#34;_blank&#34;&gt;go-mysql&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;监听 MySQL binlog 的库，可以用来把主库 MySQL 的变化同步到 Redis、elasticsearch 等。同时提供了一个类似阿里 canal 的工具库，监听并解析 binlog 变化。让管理数据和了解数据状态变得更加轻松&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-教程-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;教程&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-follow-me-install-kubernetes-cluster-https-github-com-opsnull-follow-me-install-kubernetes-cluster&#34;&gt;1. &lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34; target=&#34;_blank&#34;&gt;follow-me-install-kubernetes-cluster&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/follow-me-install-kubernetes-cluster-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;部署 kubernetes 集群教程。该教程介绍使用二进制部署最新 kubernetes 集群的所有步骤，而不是使用 kubeadm 等自动化方式来部署集群。这样有助于理解系统各组件的交互原理，进而能够快速定位、解决实际中遇到的问题。&lt;/p&gt;

&lt;h3 id=&#34;2-go-fundamental-programming-https-github-com-unknwon-go-fundamental-programming&#34;&gt;2. &lt;a href=&#34;https://github.com/Unknwon/go-fundamental-programming&#34; target=&#34;_blank&#34;&gt;go-fundamental-programming&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;《Go 编程基础》是一套针对 Google 出品的 Go 语言的视频语音教程，主要面向新手级别的学习者。&lt;/p&gt;

&lt;h3 id=&#34;3-web-series-https-github-com-wxyyxc1992-web-series&#34;&gt;3. &lt;a href=&#34;https://github.com/wxyyxc1992/Web-Series&#34; target=&#34;_blank&#34;&gt;Web-Series&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;现代 Web 开发导论，内容大纲如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基础篇&lt;/li&gt;
&lt;li&gt;进阶篇&lt;/li&gt;
&lt;li&gt;架构优化篇&lt;/li&gt;
&lt;li&gt;React 篇&lt;/li&gt;
&lt;li&gt;Vue 篇&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-spark-study-https-github-com-shijinkui-spark-study&#34;&gt;4. &lt;a href=&#34;https://github.com/shijinkui/spark_study&#34; target=&#34;_blank&#34;&gt;spark_study&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Spark 源码阅读笔记。&lt;/p&gt;

&lt;h3 id=&#34;5-the-flask-mega-tutorial-zh-https-github-com-luhuisicnu-the-flask-mega-tutorial-zh&#34;&gt;5. &lt;a href=&#34;https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh&#34; target=&#34;_blank&#34;&gt;The-Flask-Mega-Tutorial-zh&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;翻译自 Miguel Grinberg 的 blog &lt;a href=&#34;https://blog.miguelgrinberg.com&#34; target=&#34;_blank&#34;&gt;https://blog.miguelgrinberg.com&lt;/a&gt; 的2017年新版 The Flask Mega-Tutorial 教程。&lt;/p&gt;

&lt;h3 id=&#34;6-progit2-https-git-scm-com-book-zh-v2&#34;&gt;6. &lt;a href=&#34;https://git-scm.com/book/zh/v2&#34; target=&#34;_blank&#34;&gt;progit2&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/progit2-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;《Pro Git 第二版》在线中文阅读&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;资源&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-best-app-https-github-com-hzlzh-best-app&#34;&gt;1. &lt;a href=&#34;https://github.com/hzlzh/Best-App&#34; target=&#34;_blank&#34;&gt;Best-App&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;苹果系统下的优秀软件、硬件、技巧、周边设备的集合。&lt;/p&gt;

&lt;h3 id=&#34;2-interviewmap-https-github-com-interviewmap-interviewmap&#34;&gt;2. &lt;a href=&#34;https://github.com/InterviewMap/InterviewMap&#34; target=&#34;_blank&#34;&gt;InterviewMap&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/InterviewMap-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;这是一份制作精良、系统的面试图谱。内容包括：前端、计算机网络、算法、数据结构等方面。相信认真学习完这份资料，你会找到自己心仪的工作。&lt;/p&gt;

&lt;h3 id=&#34;3-night-reading-go-https-github-com-developer-learning-night-reading-go&#34;&gt;3. &lt;a href=&#34;https://github.com/developer-learning/night-reading-go&#34; target=&#34;_blank&#34;&gt;night-reading-go&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Go 夜读，该项目每周四晚上更新 Go 源码阅读以及线下技术讨论。难得的中文 Golang 源码解析，包含文档和YouTube 视频，干货满满。&lt;/p&gt;

&lt;h3 id=&#34;4-cpp-cheat-sheet-https-github-com-gibsjose-cpp-cheat-sheet&#34;&gt;4. &lt;a href=&#34;https://github.com/gibsjose/cpp-cheat-sheet&#34; target=&#34;_blank&#34;&gt;cpp-cheat-sheet&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;能够帮你通过 Google 和 NASA 面试的 C++ 数据结构和算法的 cheat sheet（英文）。&lt;/p&gt;

&lt;h3 id=&#34;5-vjtools-https-github-com-vipshop-vjtools&#34;&gt;5. &lt;a href=&#34;https://github.com/vipshop/vjtools&#34; target=&#34;_blank&#34;&gt;vjtools&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;唯品会的 Java 技术干货分享&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-奇闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;奇闻&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-晚上睡觉要关wifi吗-http-www-tanmizhi-com-html-4043-html&#34;&gt;1. &lt;a href=&#34;http://www.tanmizhi.com/html/4043.html&#34; target=&#34;_blank&#34;&gt;晚上睡觉要关wifi吗?&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://www.tanmizhi.com/img/allimg/07/18-1PF91F323.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;随着信息化时代的到来，基本上家家户户都有了WiFi，在家上网速度快，并且非常的方便。WiFi 现在几乎是遍布了我们生活的任何一个地方，就算你关掉了 WiFi，但是别人的WiFi也围绕着你。网传WiFi致癌，导致很多人对 WiFi 产生了恐惧的心里。有新闻还报道过，男子因为害怕WiFi的辐射对妻子肚子里的胎儿不利，而请求整栋楼的WiFi都关闭掉。这篇文章就为大家来揭秘一下晚上睡觉到底要不要关wifi。&lt;/p&gt;

&lt;h3 id=&#34;2-越南女兵不穿内衣真相-http-www-tanmizhi-com-html-4040-html&#34;&gt;2. &lt;a href=&#34;http://www.tanmizhi.com/html/4040.html&#34; target=&#34;_blank&#34;&gt;越南女兵不穿内衣真相&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://www.tanmizhi.com/img/allimg/07/18-1PF9154925.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;越南女兵是全球有名的，在越南战争的时候，越南女兵甚至起到了主力军的作用，但是很多越南女兵都是不穿内衣的“真空上阵”。越南女兵在被俘虏的时候，会主动的脱下自己的军装外套，露出迷人的身体出来。如果在敌军比较少的时候，她们会趁机用机枪扫射，不惜与敌人同归于尽。&lt;/p&gt;

&lt;h3 id=&#34;3-什么食物最解辣-https-zhuanlan-zhihu-com-p-40274806&#34;&gt;3. &lt;a href=&#34;https://zhuanlan.zhihu.com/p/40274806&#34; target=&#34;_blank&#34;&gt;什么食物最解辣？&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://pic3.zhimg.com/v2-9b847a64d1f235aee45556c26a997c85_1200x500.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在所有的味感中，辣味是比较特殊的一种口感。&lt;strong&gt;它是辛香料中的一些成分引起的尖利刺痛感和特殊灼烧感的总和&lt;/strong&gt;，不但能刺激舌和口腔的触觉神经引起痛觉，同时也会刺激鼻腔，有时对皮肤也产生灼烧感。&lt;/p&gt;

&lt;p&gt;那么到底怎么解辣呢？真相竟然是牛奶！原因是牛奶中的酪蛋白能将辣椒素包裹起来带走，防止其刺伤我们口腔，能起到很好的解辣效果。&lt;/p&gt;

&lt;h3 id=&#34;4-女程序员该如何求救&#34;&gt;4. 女程序员该如何求救？&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1180.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;设想一个故事场景：如果一个女程序员落难到一个孤岛上，该如何求救？然后就有人用漫画告诉了我们最佳答案。。。我也觉得 php 是世界上最好的语言，不接受反驳！&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-欢迎关注-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;欢迎关注&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;该系列每周六发布，同步更新在我的&lt;a href=&#34;https://www.yangcs.net/&#34; target=&#34;_blank&#34;&gt;个人博客&lt;/a&gt;和微信公众号上。&lt;/p&gt;

&lt;p&gt;微信搜索 “云原生实验室” 或者扫描二维码即可关注。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>干货与湿货分享第2期</title>
      <link>https://www.yangcs.net/posts/weekly-2/</link>
      <pubDate>Sat, 21 Jul 2018 11:01:26 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/weekly-2/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;这是《干货与湿货分享》系列的第二期，主要记录过去一周我所见到的听到的值得分享的东西。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-新闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;新闻&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-谷歌推出首款微信小程序-猜画小歌-https-techcrunch-cn-2018-07-18-google-launches-its-first-wechat-mini-program-as-its-china-experiments-continue&#34;&gt;1. &lt;a href=&#34;https://techcrunch.cn/2018/07/18/google-launches-its-first-wechat-mini-program-as-its-china-experiments-continue/&#34; target=&#34;_blank&#34;&gt;谷歌推出首款微信小程序“猜画小歌”&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1130.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了让每个人都有机会体验人工智能技术驱动下的人机交互，近日，谷歌推出了旗下首款微信小程序“猜画小歌”，也是一款有趣的社交微信小程序。官方表示，猜画小歌由来自 Google AI 的神经网络驱动，该网络源自全世界最大的、囊括超过 5000 万个手绘素描的数据群。&lt;/p&gt;

&lt;p&gt;当天中午体验了下，简直停不下来，立马发了朋友圈告知好友，然后就看到朋友圈内诞生了各种灵魂画作，选一个比较有代表性的给你们感受下：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/WechatIMG1129.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;建议大家第一时间体验，感觉 Google 这个小程序要孕育出一大堆灵魂画手，秀出自己的灵魂画作吧！&lt;/p&gt;

&lt;h3 id=&#34;2-微信批量封号-https-chinadigitaltimes-net-chinese-2018-07-e3-80-90-e7-ab-8b-e6-ad-a4-e5-ad-98-e7-85-a7-e3-80-91-e6-89-b9-e9-87-8f-e5-b0-81-e5-8f-b7-e5-be-ae-e4-bf-a1-e5-b0-81-e5-bb-ba-e6-97-b6-e4-bb-a3-e5-88-b0-e6-9d-a5&#34;&gt;2. &lt;a href=&#34;https://chinadigitaltimes.net/chinese/2018/07/%E3%80%90%E7%AB%8B%E6%AD%A4%E5%AD%98%E7%85%A7%E3%80%91%E6%89%B9%E9%87%8F%E5%B0%81%E5%8F%B7-%E5%BE%AE%E4%BF%A1%E5%B0%81%E5%BB%BA%E6%97%B6%E4%BB%A3%E5%88%B0%E6%9D%A5/&#34; target=&#34;_blank&#34;&gt;微信批量封号&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;近日，中国数字时代发现，微博、推特、豆瓣等平台，集中出现一些声称遭遇微信封号的网友，数量较多，其中多数网友被封号原因推测都与“传播谣言”、“散布有害言论”、“妄议时政”等相关，也有一些网友对于被封号原因表示不解。&lt;/p&gt;

&lt;p&gt;从网友反馈看，微信近期较有可能是重点对微信群内的“有害信息”进行监控，而后对个别账号进行定点清除，甚至对整群进行封禁。&lt;/p&gt;

&lt;p&gt;从内容尺度上看，微信显然在近期大大收紧了管理尺度，这对一些网友来说有些始料未及。例如，有网友称自己发表了对“泼墨门事件”的评论而遭封号；有网友称自己在朋友圈转发了“**门下大雨”导致封号…..&lt;/p&gt;

&lt;p&gt;但在中国，由于微信经常与个人社交相关联，许多人被封号封群后又不得不重新创建，于是有网友调侃“我们进入了一个封建时期”。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/wechat1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/wechat2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/wechat3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-android-免费模式或将终结-https-36kr-com-p-5143943-html&#34;&gt;3. &lt;a href=&#34;https://36kr.com/p/5143943.html&#34; target=&#34;_blank&#34;&gt;Android 免费模式或将终结&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://pic.36krcnd.com/201807/18232502/o6d9dnyk6lsmtvyu.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;7月18日晚间消息，因谷歌 Android 垄断一案，欧盟委员会今日正式宣布，对谷歌处以 43.4 亿欧元(约合 50.4 亿美元)的罚款。&lt;/p&gt;

&lt;p&gt;对此，谷歌 CEO 桑达尔·皮查伊（Sundar Pichai）发表文章，警告称由于欧盟的决定，Android 可能无法保持免费。&lt;/p&gt;

&lt;p&gt;欧盟对谷歌发出 50 亿美元的罚单后，谷歌 CEO 桑德·皮查在谷歌官网发文抗议。&lt;/p&gt;

&lt;p&gt;他认为，欧盟委员会针对 Android 及其商业模式的罚单定忽略了 Android 手机与 iOS 手机竞争的事实。也忽略了 Android 为成千上万的手机制造商和移动网络运营商提供了多少选择，正是这些手机制造商和移动运营商在生产并销售 Android 设备。此外，世界各地有数百万的企业依靠开发 Android 应用为生；数十亿的消费者使用着廉价的安卓手机。&lt;/p&gt;

&lt;h3 id=&#34;4-google印度工程师被活活打死-https-www-cnbeta-com-articles-tech-748631-htm&#34;&gt;4. &lt;a href=&#34;https://www.cnbeta.com/articles/tech/748631.htm&#34; target=&#34;_blank&#34;&gt;Google印度工程师被活活打死&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/efa942f659a7e12.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;据外媒报道，近日，印度一位32岁的 Google 软件工程师 Mohammad Azam 遭遇不幸，被人活活打死，而原因竟然是村民听信谣言，以为这位工程师是个人贩子。报道称，Azam 和他们的两位友人去外地见另外一位朋友，回程途中休息的时候碰到一群小学生经过，出于好心拿出巧克力分给孩子们。&lt;/p&gt;

&lt;p&gt;这本来是一个友善的举动，却引起了周围村民的误会，因为社交媒体上在热传有儿童绑架犯逃窜的消息。&lt;/p&gt;

&lt;p&gt;村民们觉得 Azam 一行人很可疑，但没有去查证就认定他们是绑架犯，还在 WhatsApp 等社交渠道上发出了他们的照片，并声称他们就是绑架犯，别让他们跑了。&lt;/p&gt;

&lt;p&gt;很快，越来越多的村民闻讯赶来，拦住了 Azam 一行人的汽车，用棍棒、石头发起攻击。Azam怎么解释都没人听，就连警察赶来也无济于事。&lt;/p&gt;

&lt;p&gt;最后，车子被砸得稀烂，Azam 被打死，另外两人也受了重伤。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/6e5e9c0eea7bc5c.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-整个社区联合起来强奸一个孩子-https-cn-nytimes-com-world-20180719-rape-chennai-india-utm-source-tw-nytimeschinese-utm-medium-social-utm-campaign-cur&#34;&gt;5. &lt;a href=&#34;https://cn.nytimes.com/world/20180719/rape-chennai-india/?utm_source=tw-nytimeschinese&amp;amp;utm_medium=social&amp;amp;utm_campaign=cur&#34; target=&#34;_blank&#34;&gt;整个社区联合起来强奸一个孩子&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/merlin.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;新德里——警方表示，数月来，一群男子一直在轮奸一名11岁的女孩。&lt;/p&gt;

&lt;p&gt;警方表示，这名女孩与父母住在金奈一个封闭式社区，这些男子给她喝下掺有药物的软饮。警方还说，他们拍下了强奸这名女孩的场面，挥舞着刀子威胁她，如果告诉家人的话就公开这些视频。&lt;/p&gt;

&lt;p&gt;这些男子并非这个封闭式社区的闯入者，而是向居民打招呼、操作电梯、为公寓送饮水机的社区雇员。&lt;/p&gt;

&lt;h3 id=&#34;6-马化腾朋友圈辟谣-https-getpocket-com-redirect-url-https-3a-2f-2fm-mydrivers-com-2fnewsview-2f585157-html-3fref-3dandroid-app-253a-2f-2fcom-google-android-googlequicksearchbox-2fhttps-2fwww-google-com-formcheck-e3cf5ad1969099a5c614a0e851dfa82b&#34;&gt;6. &lt;a href=&#34;https://getpocket.com/redirect?url=https%3A%2F%2Fm.mydrivers.com%2Fnewsview%2F585157.html%3Fref%3Dandroid-app%253A%2F%2Fcom.google.android.googlequicksearchbox%2Fhttps%2Fwww.google.com&amp;amp;formCheck=e3cf5ad1969099a5c614a0e851dfa82b&#34; target=&#34;_blank&#34;&gt;马化腾朋友圈辟谣&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/726c1d06f96.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;近日，一则“王思聪表白马化腾女儿”的传闻在网上传播，&lt;strong&gt;对此马化腾本人在朋友圈辟谣回应，称“这两天集中爆发的针对我家人的谣言越来越卑劣”，表示“一定会追查到底”。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外认证为腾讯公关总监的腾讯张军微博也发布了该朋友圈截图，表示该朋友圈为“Pony的辟谣”，侧面证实了马化腾本人回应的真实性。&lt;/p&gt;

&lt;p&gt;不过也许是考虑到抑制谣言传播，目前张军已经删除了自己的辟谣微博，代之转发了一条新浪科技的辟谣报道。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/d20b8f8b16.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-工具-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;工具&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-hexoeditor-https-github-com-zhuzhuyule-hexoeditor&#34;&gt;1. &lt;a href=&#34;https://github.com/zhuzhuyule/HexoEditor&#34; target=&#34;_blank&#34;&gt;HexoEditor&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这是一款为 Hexo 做了优化的非常清新的 Markdown 编辑器，使用 Electron 做框架，修改自 &lt;a href=&#34;https://github.com/Moeditor/Moeditor&#34; target=&#34;_blank&#34;&gt;Moeditor&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://raw.githubusercontent.com/zhuzhuyule/HexoEditor/master/screenshots/gif-tag.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-router7-https-github-com-rtr7-router7&#34;&gt;2. &lt;a href=&#34;https://github.com/rtr7/router7&#34; target=&#34;_blank&#34;&gt;router7&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一款用 Go 语言编写的软路由操作系统。该项目目前还只是个 demo，更多功能请继续关注。&lt;/p&gt;

&lt;h3 id=&#34;3-infinity-新标签页-https-cn-infinitynewtab-com&#34;&gt;3. &lt;a href=&#34;https://cn.infinitynewtab.com/&#34; target=&#34;_blank&#34;&gt;Infinity 新标签页&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/infinity.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Infinity，基于过去对新标签页的认识，重新定义了新标签页，一个追求极简美学和一站式服务体验。新一代的标签页，一个更好用，更强大的新标签页。&lt;/p&gt;

&lt;h3 id=&#34;4-camtd-chrome-多线程下载管理器插件-https-github-com-jae-jae-camtd&#34;&gt;4. &lt;a href=&#34;https://github.com/jae-jae/Camtd&#34; target=&#34;_blank&#34;&gt;Camtd - Chrome 多线程下载管理器插件&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/6874.jpeg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;如果你跟我一样不满 Chrome 默认的下载管理器，或许 Camtd 这款多线程下载管理器插件正适合你，它基于 Aria2 和 AriaNg，可满速下载百度网盘文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;演示：满速下载百度网盘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/1bcf69d6.gif&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-yomail-http-www-nextechat-com&#34;&gt;5. &lt;a href=&#34;http://www.nextechat.com/&#34; target=&#34;_blank&#34;&gt;Yomail&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://img3.appinn.com/images/201611/yomail_app12x.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;邮件作为一项古老的计算机技术，相应的邮件客户端也是层出不穷。有 Mailbox 这类带有创新的交互方式的，也有 Inbox、Spark 这类智能整理收件箱的，Airmail 这类把邮件和其他软件串联的设计更是让你重新审视邮件的意义。&lt;/p&gt;

&lt;p&gt;不过这些试图「重新发明邮件」的客户端，并没有特别针对国内环境做设计。如果你不太热衷于尝试这些国外的邮件客户端，又不满足于国内邮件服务商的官方网页或客户端，想在工作中更好处理邮件，可以试试 YoMail。&lt;/p&gt;

&lt;h3 id=&#34;6-irreader-一个-rss-阅读器-http-irreader-netqon-com&#34;&gt;6. &lt;a href=&#34;http://irreader.netqon.com/&#34; target=&#34;_blank&#34;&gt;Irreader 一个 RSS 阅读器&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://irreader.netqon.com/libs/c/1.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;irreader 是一个 RSS 阅读器，除了 RSS 之外，也可以订阅网页和 podcast，有一个内置的源市场，内建 Podcast 播放。&lt;/p&gt;

&lt;p&gt;最后再来一张 marketing 长图：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://irreader.netqon.com/libs/mkt_0.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;7-人人影视-tv-版-http-app-yyets-com&#34;&gt;7. &lt;a href=&#34;http://app.yyets.com/&#34; target=&#34;_blank&#34;&gt;人人影视 TV 版&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://img3.appinn.com/images/201807/banner01.jpg!o&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;据小道消息，人人影视 TV 版的测试版已经可以安装使用，支持边下边播，以及下载到本地。&lt;/p&gt;

&lt;p&gt;目前的人人影视已经拥有各大平台客户端：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;网页版&lt;/li&gt;
&lt;li&gt;iPhone、iPad&lt;/li&gt;
&lt;li&gt;Android&lt;/li&gt;
&lt;li&gt;Android TV&lt;/li&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;li&gt;macOS&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-id-h2-教程-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;教程&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-linux-内存管理-https-segmentfault-com-a-1190000008125006&#34;&gt;1. &lt;a href=&#34;https://segmentfault.com/a/1190000008125006&#34; target=&#34;_blank&#34;&gt;Linux 内存管理&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在linux下，使用 top，vmstat,free 等命令查看系统或者进程的内存使用情况时，经常看到 buff/cache memeory，swap，avail Mem 等，他们都代表什么意思呢？这篇文章将来聊一聊 Linux 下的内存管理并解答这个问题。&lt;/p&gt;

&lt;h3 id=&#34;2-etcd-架构与实现解析-http-jolestar-com-etcd-architecture&#34;&gt;2. &lt;a href=&#34;http://jolestar.com/etcd-architecture/&#34; target=&#34;_blank&#34;&gt;Etcd 架构与实现解析&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。网上关于 Etcd 的使用介绍的文章不少，但分析具体架构实现的文章不多，同时 Etcd v3的文档也非常稀缺。本文通过分析 Etcd 的架构与实现，了解其优缺点以及瓶颈点，一方面可以学习分布式系统的架构，另外一方面也可以保证在业务中正确使用 Etcd，知其然同时知其所以然，避免误用。&lt;/p&gt;

&lt;h3 id=&#34;3-learning-sicp-https-github-com-deathking-learning-sicp&#34;&gt;3. &lt;a href=&#34;https://github.com/DeathKing/Learning-SICP&#34; target=&#34;_blank&#34;&gt;Learning-SICP&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://camo.githubusercontent.com/0328cc5987e0ade0ba05d452171c90cbe4f61c43/687474703a2f2f67726f7570732e637361696c2e6d69742e6564752f6d61632f636c61737365732f362e3030312f6162656c736f6e2d737573736d616e2d6c656374757265732f77697a6172642e6a7067&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;《计算机程序的构造和解释》系列公开课，视频是两位作者（Harold Abelson、Gerald Jay Sussman）在1986年7月给 Hewlett-Packard 公司员工培训时的录像。这门课程只提供了英文字幕，本项目旨在将这些英文字幕翻译为中文，方便广大的 &lt;code&gt;Scheme/Lisp&lt;/code&gt; 学习者。&lt;/p&gt;

&lt;h3 id=&#34;4-tcpdump-示例教程-https-hackertarget-com-tcpdump-examples&#34;&gt;4. &lt;a href=&#34;https://hackertarget.com/tcpdump-examples/&#34; target=&#34;_blank&#34;&gt;Tcpdump 示例教程&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;tcpdump 是一个运行在命令行下的嗅探工具。它允许用户拦截和显示发送或收到过网络连接到该计算机的 TCP/IP 和其他数据包。一般情况下，非 HTTP 协议的网络分析，在服务器端用 tcpdump 比较多，在客户端用 wireshark 比较多，两个抓包软件的语法是一样的。&lt;/p&gt;

&lt;h3 id=&#34;5-envoy-官方文档中文版-http-www-servicemesher-com-envoy&#34;&gt;5. &lt;a href=&#34;http://www.servicemesher.com/envoy/&#34; target=&#34;_blank&#34;&gt;Envoy 官方文档中文版&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/envoyproxy11.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Envoy ——为云原生应用而设计、开源的边缘和服务代理、Istio Service Mesh 默认的数据平面，最新官方文档中文版，由 ServiceMesher社区倾情奉献。&lt;/p&gt;

&lt;h3 id=&#34;6-编写和优化go代码-https-github-com-dgryski-go-perfbook-blob-master-performance-zh-md&#34;&gt;6. &lt;a href=&#34;https://github.com/dgryski/go-perfbook/blob/master/performance-zh.md&#34; target=&#34;_blank&#34;&gt;编写和优化Go代码&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;本文档概述了编写高性能Go代码的最佳实践。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;资源&lt;/p&gt;&lt;/h2&gt;

&lt;h3 id=&#34;1-vistio-https-github-com-nmnellis-vistio&#34;&gt;1. &lt;a href=&#34;https://github.com/nmnellis/vistio&#34; target=&#34;_blank&#34;&gt;Vistio&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://github.com/nmnellis/vistio/raw/master/documentation/sample.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/vizceral&#34; target=&#34;_blank&#34;&gt;Vizceral&lt;/a&gt; 是 Netflix 发布的一个开源项目，用于近乎实时地监控应用程序和集群之间的网络流量。Vistio 是使用 Vizceral 对 Istio 和网格监控的改进。它利用 Istio Mixer 生成的指标，然后将其输入 Prometheus。Vistio 查询 Prometheus 并将数据存储在本地以允许重播流量。&lt;/p&gt;

&lt;h3 id=&#34;2-一个在线运行代码的网站-https-yxi-io&#34;&gt;2. &lt;a href=&#34;https://yxi.io/&#34; target=&#34;_blank&#34;&gt;一个在线运行代码的网站&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;这是一个可以在线运行短代码的网站，前端用 Vuejs 做的，后端用 Docker 提供不同语言的运行环境。目前支持的语言 Bash, C, C++, Go, Haskell, Java, Perl, PHP, Python, Ruby, Rust.&lt;/p&gt;

&lt;h3 id=&#34;3-sofamesh-https-zhuanlan-zhihu-com-p-39931845&#34;&gt;3. &lt;a href=&#34;https://zhuanlan.zhihu.com/p/39931845&#34; target=&#34;_blank&#34;&gt;SOFAMesh&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;蚂蚁金服自主研发的分布式中间件（Scalable Open Financial Architecture，简称 SOFA ）推出的第三轮的开源产品：&lt;code&gt;SOFAMesh&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;SOFAMesh 是基于 Istio 改进和扩展而来的 Service Mesh 大规模落地实践方案。在继承 Istio 强大功能和丰富特性的基础上，为满足大规模部署下的性能要求以及应对落地实践中的实际情况，有如下改进：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;采用 Golang 编写的 MOSN 取代 Envoy&lt;/li&gt;
&lt;li&gt;合并Mixer到数据平面以解决性能瓶颈&lt;/li&gt;
&lt;li&gt;增强 Pilot 以实现更灵活的服务发现机制&lt;/li&gt;
&lt;li&gt;增加对 SOFA RPC、Dubbo 的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-rio-https-github-com-ibuildthecloud-rio&#34;&gt;4. &lt;a href=&#34;https://github.com/ibuildthecloud/rio&#34; target=&#34;_blank&#34;&gt;rio&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;我也不知道这玩意儿到底是个什么东西，据项目 README 介绍，这是个和 Docker 一样有趣的东西，而且是一种新奇的技术，像 service mesh 一样。&lt;/p&gt;

&lt;h3 id=&#34;5-nabla-containers-https-nabla-containers-github-io&#34;&gt;5. &lt;a href=&#34;https://nabla-containers.github.io/&#34; target=&#34;_blank&#34;&gt;Nabla containers&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一种新型容器，专门为主机上的强隔离而设计。&lt;/p&gt;

&lt;h3 id=&#34;6-golb-https-github-com-onestraw-golb&#34;&gt;6. &lt;a href=&#34;https://github.com/onestraw/golb&#34; target=&#34;_blank&#34;&gt;golb&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/golb.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Go 语言编写的新型负载均衡器。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-欢迎关注-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;欢迎关注&lt;/p&gt;&lt;/h2&gt;

&lt;p&gt;该系列每周六发布，同步更新在我的&lt;a href=&#34;https://www.yangcs.net/&#34; target=&#34;_blank&#34;&gt;个人博客&lt;/a&gt;和微信公众号上。&lt;/p&gt;

&lt;p&gt;微信搜索 “云原生实验室” 或者扫描二维码即可关注。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>干货与湿货分享第1期</title>
      <link>https://www.yangcs.net/posts/weekly-1/</link>
      <pubDate>Sat, 14 Jul 2018 05:31:48 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/weekly-1/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;人类社会未来几十年肯定会发生天翻地覆的变化，自从我坚信这一点之后，我就把所有的精力都投在了技术领域。所有的变化从根本上来说都是技术的变革引起的，只有掌握了技术，才有可能应对这些变化。&lt;/p&gt;

&lt;p&gt;我相信未来绝大多数的机会都是技术带来的，虽然其他行业依然可以赚钱，但我仍然觉得最有前景的是技术人员，因为当人工智能爆发以后，必将引发第四次工业革命，未来一定是人工智能在帮你看病和打官司。&lt;/p&gt;

&lt;p&gt;由于技术变化日新月异，新观点新工具层出不穷，让人有点目不暇接。我的私人收藏夹里已经屯了好几吨的货，这个时候我想知识如果不分享，就会变得没有意义。所以决定写成文章分享出来，也许会收获一些志同道合的朋友，将来可以一起做一些有用的事情。&lt;/p&gt;

&lt;p&gt;这是《干货分享》系列的第一期，主要记录过去一周我所见到的听到的值得分享的东西，这里只涉及技术，不涉及其他领域。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-新闻-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;新闻&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-paypal-向已故女子发账号违规通知-http-jandan-net-2018-07-14-paypal-terms-html&#34;&gt;1. &lt;a href=&#34;http://jandan.net/2018/07/14/paypal-terms.html&#34; target=&#34;_blank&#34;&gt;PayPal 向已故女子发账号违规通知&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://img.jandan.net/news/2018/07/dbf68dc1b4f586fa112e7d130d790eb8.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;PayPal 最近遭遇了一起让无数网友感到愤怒的公关危机，事件起因是该公司竟然向一位已故女士发去了一封信件，解释她的死亡违反了帐户持有人相关的政策。她的丈夫还没从失去爱妻的悲痛中缓过来，又遇到了这么一件丧心病狂的事情。周二的时候，Howard Durdle 怒而将该文件发到 Twitter 和 Facebook 等社群上。&lt;/p&gt;

&lt;h3 id=&#34;2-google-chrome-浏览器将带来新面孔-https-imcn-me-html-y2018-33653-html&#34;&gt;2. &lt;a href=&#34;https://imcn.me/html/y2018/33653.html&#34; target=&#34;_blank&#34;&gt;Google Chrome 浏览器将带来新面孔&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://imcn.me/wp-content/uploads/2018/07/chrome-new-look-macos.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;无论是经历了技术更迭还是审美升级，谷歌 Chrome 浏览器的用户界面依然巍然不动，多年来都保存同一个样式。但是改变很快就会来了，这两日谷歌透露，预计将于 9 月 2 号（Chrome 的生日）将 Material Design 作为正式版 Chrome 的默认用户界面，视觉重新设计基于更圆、更柔和，更具触感的 Material Design 2（在Android P 中完全展示并且与 Chrome OS 桌面零散地结合）。&lt;/p&gt;

&lt;h3 id=&#34;3-htc-首款区块链手机-exodus-正式开放登记-https-cn-engadget-com-2018-07-10-htc-exodus-registration&#34;&gt;3. &lt;a href=&#34;https://cn.engadget.com/2018/07/10/htc-exodus-registration/&#34; target=&#34;_blank&#34;&gt;HTC 首款区块链手机 Exodus 正式开放登记&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://o.aolcdn.com/images/dims?thumbnail=600%2C400&amp;amp;quality=80&amp;amp;image_uri=https%3A%2F%2Fs.aolcdn.com%2Fhss%2Fstorage%2Fmidas%2Fc00a959b6f5784ba6ef5451cf350cc93%2F206517826%2Fdims.jpg&amp;amp;client=cbc79c14efcebee57402&amp;amp;signature=dd0892fd01c1d886694e61e2704ce82836f94b24&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;阵子在 U12+ 的发布会之前，HTC 突然再透露了他们正准备另一台全新的手机产品 Exodus，这是一台趁着近年科技界对区块链技术的追求而生的区块链手机。今天 HTC 再释出更多有关这台 Exodus 的信息，而且也在今天正式开放登记计划，让有兴趣的朋友预约登记，抢先在今年的第三季体验这台 Exodus 手机。&lt;/p&gt;

&lt;h3 id=&#34;4-日本第二次私人火箭发射失败-https-cn-engadget-com-2018-07-01-japan-interstellar-private-rocket-crash&#34;&gt;4. &lt;a href=&#34;https://cn.engadget.com/2018/07/01/japan-interstellar-private-rocket-crash/&#34; target=&#34;_blank&#34;&gt;日本第二次私人火箭发射失败&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://s.aolcdn.com/hss/storage/midas/ca779bdc8b01018cd047f96dc1e46bf1/206496734/this-combo-of-video-grabs-provided-by-interstellars-technologies-the-picture-id987515668.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;由颇具争议的企业家堀江贵文于 2005 年创立的 Interstellar Technologies 公司，和 SpaceX、Blue Origins、Rocket Labs 等有不少相似之处，都希望在新一代的私人太空领域中占据立足之地。然而和这三者不同的是，虽然 Interstellar Technologies 发射的是一枚相对简单得多的火箭（仅长 10m、直径 50cm），发射高度也只是勉强构到 100km 线，并不能进入轨道，但到目前为止还没有成功的记录。&lt;/p&gt;

&lt;p&gt;第一次试射发生在 2017 年，当时的 Momo 火箭在发射 66 秒后因为失去与地面的联系而自毁，只达到了 20km 的高度，而这次更是在发射后没几秒便又垂直落下，以一团火球告终。除了从视频中可以很明显看出发射后没三秒引擎就突然「没力」之外，Interstellar Technologies 没有给更进一步的原因或说明。&lt;/p&gt;

&lt;h3 id=&#34;5-苹果前华人工程师窃密被捕-http-www-sohu-com-a-240500768-610300&#34;&gt;5. &lt;a href=&#34;http://www.sohu.com/a/240500768_610300&#34; target=&#34;_blank&#34;&gt;苹果前华人工程师窃密被捕&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://cdn-fs.d1ev.com/d/file/custom/30018/file/201807/1531280057974180.jpg!w720&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;7月7日，一名曾在苹果自动驾驶汽车项目工作的工程师在加州圣何塞机场准备登机飞往中国时，被美国联邦调查局（FBI）的执法人员逮捕。据知情人士称，这位名为 Xiaolang Zhang（张晓浪）的工程师跳槽入职国内创业公司小鹏汽车。&lt;/p&gt;

&lt;p&gt;根据提交给加州北区法院的文件，美国联邦调查局于本周指控苹果前员工 Xiaolang Zhang 窃取商业机密。而法院文件显示，目前共有5000名员工在为苹果的自动驾驶汽车项目工作。&lt;/p&gt;

&lt;h3 id=&#34;6-特斯拉计划在上海建全资工厂-https-www-ifanr-com-1063536&#34;&gt;6. &lt;a href=&#34;https://www.ifanr.com/1063536&#34; target=&#34;_blank&#34;&gt;特斯拉计划在上海建全资工厂&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://images.ifanr.cn/wp-content/uploads/2018/07/WechatIMG4071531228156_.pic_hd.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;在特斯拉宣布将在上海临港地区独资建厂的两天后，CEO 埃隆·马斯克低调访华。此行分别敲定了上海建厂和北京建立科技创新中心事宜，随后他就匆匆离开。&lt;/p&gt;

&lt;p&gt;本项目直接涵盖了电动车最重要的研发、制造、销售三大环节，计划兴建的有特斯拉（上海）有限公司和特斯拉（上海）电动汽车研发创新中心以及代号 Gigafactory 3 的特斯拉超级工厂。&lt;/p&gt;

&lt;p&gt;虽然马老板行踪保密至极，没透露一丝风声，不过，还是有人记录下了马老板在华的奇妙经历。&lt;/p&gt;

&lt;p&gt;比如，街头吃煎饼果子：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/s_c98cb49fa3c7472ca75a3b7b8c2cc75f.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-工具-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;工具&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-baidupcs-go-https-github-com-iikira-baidupcs-go&#34;&gt;1. &lt;a href=&#34;https://github.com/iikira/BaiduPCS-Go&#34; target=&#34;_blank&#34;&gt;BaiduPCS-Go&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;关于百度网盘大家都是又爱又恨吧，毕竟要拿来存东西，分享什么的，但是这个下载 限速实在是难以忍受呀。这里给大家介绍一款全平台通用的下载神器：&lt;code&gt;BaiduPCS--go&lt;/code&gt;。使用 Go 语言编写，支持网盘内目录 (文件夹) 下载, 支持多个文件或目录下载, 支持断点续传和高并发高速下载。&lt;/p&gt;

&lt;h3 id=&#34;2-ivideo-https-github-com-phobal-ivideo&#34;&gt;2. &lt;a href=&#34;https://github.com/phobal/ivideo&#34; target=&#34;_blank&#34;&gt;ivideo&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一个可以观看国内主流视频平台所有视频的客户端（Mac、Windows、Linux），包括 VIP 资源。&lt;/p&gt;

&lt;h3 id=&#34;3-dochub-https-github-com-truthhun-dochub&#34;&gt;3. &lt;a href=&#34;https://github.com/TruthHun/DocHub&#34; target=&#34;_blank&#34;&gt;DocHub&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;参考百度文库，使用Beego（Golang）开发的开源文库系统。&lt;/p&gt;

&lt;h3 id=&#34;4-annie-https-github-com-iawia002-annie&#34;&gt;4. &lt;a href=&#34;https://github.com/iawia002/annie&#34; target=&#34;_blank&#34;&gt;annie&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;一个可以下载 YouTube 视频的命令行工具，与 &lt;a href=&#34;https://github.com/soimort/you-get&#34; target=&#34;_blank&#34;&gt;youget&lt;/a&gt; 类似，但使用 Go 语言编写，除了支持 YouTube 之外，还可以下载国内各大视频网站的视频&lt;/p&gt;

&lt;h3 id=&#34;5-painter-https-github-com-kujiale-mobile-painter&#34;&gt;5. &lt;a href=&#34;https://github.com/Kujiale-Mobile/Painter&#34; target=&#34;_blank&#34;&gt;Painter&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;小程序生成图片库，轻松通过 json 方式绘制一张可以发到朋友圈的图片&lt;/p&gt;

&lt;h3 id=&#34;6-taro-https-github-com-nervjs-taro&#34;&gt;6. &lt;a href=&#34;https://github.com/NervJS/taro&#34; target=&#34;_blank&#34;&gt;taro&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序、H5、React Native 等的应用。&lt;/p&gt;

&lt;h3 id=&#34;7-termtosvg-https-github-com-nbedos-termtosvg&#34;&gt;7. &lt;a href=&#34;https://github.com/nbedos/termtosvg&#34; target=&#34;_blank&#34;&gt;termtosvg&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;将终端会话记录为 SVG 动画&lt;/p&gt;

&lt;h3 id=&#34;8-jib-http-github-com-googlecontainertools-jib&#34;&gt;8. &lt;a href=&#34;http://github.com/GoogleContainerTools/jib&#34; target=&#34;_blank&#34;&gt;Jib&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;谷歌开源的 Java 应用容器生成工具，不用写 Dockerfile，构造过程中自动生成一个 Docker 容器。&lt;/p&gt;

&lt;h3 id=&#34;9-简悦-simpread-https-github-com-kenshin-simpread&#34;&gt;9. &lt;a href=&#34;https://github.com/Kenshin/simpread&#34; target=&#34;_blank&#34;&gt;简悦 ( SimpRead ) &lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://raw.githubusercontent.com/521xueweihan/HelloGitHub/master/content/27/img/simpread-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;让你瞬间进入沉浸式阅读的扩展，还原阅读的本质，提升你的阅读体验。使用它可以为你剔除页面上无关的干扰信息，让用户专注于阅读主要的内容。通过这个项目，还可以学习如何开发 Chrome 扩展。&lt;/p&gt;

&lt;h3 id=&#34;10-aesma-http-www-aesma-cn&#34;&gt;10. &lt;a href=&#34;http://www.aesma.cn/&#34; target=&#34;_blank&#34;&gt;Aesma&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;说到网盘离线下载，115网盘和百度网盘肯定是第一时间进入你脑海里的网盘，毕竟是大公司，功能还是非常不错的，离线下载速度杠杠的，基本秒下载，然后可以直接在线观看。但唯一的遗憾就是。。。太。。。贵。。。年费会员接近300元的价格，还是让不少喜欢看片的伙伴们在充值和不充值之间犹豫徘徊。&lt;/p&gt;

&lt;p&gt;百度网盘提供免费BT离线下载功能，但在线观看速度会有一定的限制，且很多资源无法离线，版权或其他原因。&lt;/p&gt;

&lt;p&gt;最近出了一个 Aesma 阿斯离线云网盘，官网自称可能是目前最好用的离线下载工具，看来还是有几把刷子。据悉，Aesma 是破解的的 115 的数据流，所以离线下载和在线播放性能还是毋庸置疑的。&lt;/p&gt;

&lt;p&gt;网盘之前可以免费试用，不过现在推广期已过，开始收费了，但费用并不高，经济会员仅仅6元每月，普通会员10元每月，最贵的高级会员也就16元每月，还是比115或者百度网盘便宜了不少。更多详情大家可以自行探索。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-教程-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;教程&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-deeplearningbook读书笔记-https-github-com-exacity-simplified-deeplearning&#34;&gt;1. &lt;a href=&#34;https://github.com/exacity/simplified-deeplearning&#34; target=&#34;_blank&#34;&gt;DeepLearningBook读书笔记&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DeepLearningBook是目前第一本系统和完整的介绍深度学习的书籍，其作者包括深度学习领域的奠基人、处于研究生涯中期的领域中坚、更有近年来涌现的新星，非常适合搭建理论基础。但是直至去年，本书只有英文原版，对于大多数开发者来说，啃一本800页7*9英寸的书籍，难度可想而知。 好消息是，在翻译人员的不懈努力下，DeepLearningBook中文版也已在GitHub上公开，中文翻译版已经由人民邮电出版社出版。&lt;/p&gt;

&lt;h3 id=&#34;2-go语言高级编程-https-github-com-chai2010-advanced-go-programming-book&#34;&gt;2. &lt;a href=&#34;https://github.com/chai2010/advanced-go-programming-book&#34; target=&#34;_blank&#34;&gt;Go语言高级编程&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;《Go语言高级编程》该书针对 Go 语言有一定经验，想更加深入了解 Go 语言各种高级用法的开发人员。&lt;/p&gt;

&lt;h3 id=&#34;3-后端架构师技术图谱-https-github-com-xingshaocheng-architect-awesome&#34;&gt;3. &lt;a href=&#34;https://github.com/xingshaocheng/architect-awesome&#34; target=&#34;_blank&#34;&gt;后端架构师技术图谱&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;后端架构师的技术图谱，非常全面，从数据结构、常用算法到分布式系统设计模式应有尽有。&lt;/p&gt;

&lt;h3 id=&#34;4-深度学习框架-pytorch-入门与实践-https-github-com-chenyuntc-pytorch-book&#34;&gt;4. &lt;a href=&#34;https://github.com/chenyuntc/pytorch-book&#34; target=&#34;_blank&#34;&gt;深度学习框架 PyTorch：入门与实践&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;书籍《深度学习框架 PyTorch：入门与实践》的示例代码，可以作为一个独立的 PyTorch 入门指南和教程。内容结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://raw.githubusercontent.com/521xueweihan/HelloGitHub/master/content/25/img/pytorch-book-show-min.png&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-自己动手做聊天机器人-https-github-com-warmheartli-chatbotcourse&#34;&gt;5. &lt;a href=&#34;https://github.com/warmheartli/ChatBotCourse&#34; target=&#34;_blank&#34;&gt;自己动手做聊天机器人&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;该项目介绍了如何自己动手做聊天机器人。全面地介绍了所需要的技术：自然语言识别、分词、语料库、机器学习等，包含所需的 Java 和 Python 代码。&lt;/p&gt;

&lt;h3 id=&#34;6-free-programming-books-zh-cn-https-github-com-justjavac-free-programming-books-zh-cn&#34;&gt;6. &lt;a href=&#34;https://github.com/justjavac/free-programming-books-zh_CN&#34; target=&#34;_blank&#34;&gt;free-programming-books-zh_CN&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;免费的计算机编程类中文书籍。&lt;/p&gt;

&lt;h3 id=&#34;7-golang-区块链教程-https-github-com-liuchengxu-blockchain-tutorial&#34;&gt;7. &lt;a href=&#34;https://github.com/liuchengxu/blockchain-tutorial&#34; target=&#34;_blank&#34;&gt;Golang 区块链教程&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;区块链不仅仅是计算机科学，还涉及了政治经济制度，社会分工协作等等很多方面，本教程的关注点不仅在于深度，更在于其广度，更多是站在研究的角度，而非仅仅是一个程序员的视角。&lt;/p&gt;

&lt;h3 id=&#34;8-prometheus-操作指南-云原生监控之道-https-github-com-yunlzheng-prometheus-book&#34;&gt;8. &lt;a href=&#34;https://github.com/yunlzheng/prometheus-book&#34; target=&#34;_blank&#34;&gt;Prometheus 操作指南：云原生监控之道&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Prometheus是一个开源的完整监控解决方案，其对传统监控系统的测试和告警模型进行了彻底的颠覆，形成了基于中央化的规则计算、统一分析和告警的新模型。本教程应该是国内第一个全面剖析 Prometheus 的教程，从原理到实战。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-资源-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;资源&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;1-telegramgroup-https-github-com-itgoyo-telegramgroup&#34;&gt;1. &lt;a href=&#34;https://github.com/itgoyo/TelegramGroup&#34; target=&#34;_blank&#34;&gt;TelegramGroup&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Telegram 群合集，收集了非常全面好玩的 telegram 群。&lt;/p&gt;

&lt;h3 id=&#34;2-飞流直播-http-chaochaolive-icntv-xyz-channel-movie&#34;&gt;2. &lt;a href=&#34;http://chaochaolive.icntv.xyz/channel/movie&#34; target=&#34;_blank&#34;&gt;飞流直播&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;海外中文网络电视直播，直接通过浏览器播放。&lt;/p&gt;

&lt;h3 id=&#34;3-factory-images-for-nexus-and-pixel-devices-https-developers-google-com-android-images&#34;&gt;3. &lt;a href=&#34;https://developers.google.com/android/images&#34; target=&#34;_blank&#34;&gt;Factory Images for Nexus and Pixel Devices&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;安卓原生镜像下载地址，包括 Nexus 和 Pixel 系列。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-欢迎关注-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;欢迎关注&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;该系列每周六发布，同步更新在我的&lt;a href=&#34;https://www.yangcs.net/&#34; target=&#34;_blank&#34;&gt;个人博客&lt;/a&gt;和微信公众号上。&lt;/p&gt;

&lt;p&gt;微信搜索 &lt;strong&gt;“云原生实验室”&lt;/strong&gt; 或者扫描二维码即可关注。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>Envoy 熔断器的原理和使用</title>
      <link>https://www.yangcs.net/posts/circuit-breaking/</link>
      <pubDate>Fri, 13 Jul 2018 09:22:49 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/circuit-breaking/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在微服务领域，各个服务之间经常会相互调用。如果某个服务繁忙或者无法响应请求，将有可能引发集群的大规模级联故障，从而造成整个系统不可用，通常把这种现象称为 &lt;span id=&#34;inline-purple&#34;&gt;服务雪崩效应&lt;/span&gt;。为了应对这种情况，可以使用熔断器（circuit breaking）。&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;inline-purple&#34;&gt;熔断器&lt;/span&gt; 是分布式系统的关键组件，默认情况下处于关闭状态，这时请求被允许通过熔断器。它调用失败次数积累，如果当前健康状况低于设定阈值则启动熔断机制，这时请求被禁止通过。这样做可以实现更优雅的故障处理，并在问题被放大之前做出及时的响应。你可以选择在基础架构层面实现熔断机制，但熔断器本身会很容易受到故障的影响。为了更好地实现熔断机制，可以在 Envoy 的网络层面配置熔断器，这样做的好处是 &lt;code&gt;Envoy&lt;/code&gt; 在网络级别强制实现断路，而不必为每个应用程序单独配置或编程。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-熔断器配置-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 熔断器配置&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Envoy 支持各种类型的完全分布式（非协调的）熔断，设置熔断时，需要考虑系统的具体情况，可以通过向 Envoy 的 &lt;code&gt;clusters&lt;/code&gt; 配置项中添加 &lt;code&gt;circuit_breakers&lt;/code&gt; 来为 Envoy 配置熔断器。下面是一个简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;circuit_breakers:
  thresholds:
    - priority: DEFAULT
      max_connections: 1000
      max_requests: 1000
    - priority: HIGH
      max_connections: 2000
      max_requests: 2000
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;thresholds&lt;/span&gt; : 阈值允许我们定义服务响应的流量类型的优先级和限制。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;priority&lt;/span&gt; : 优先级是指熔断器如何处理定义为 &lt;code&gt;DEFAULT&lt;/code&gt; 或 &lt;code&gt;HIGH&lt;/code&gt; 的路由。示例中的设置表示将任何不应该在长连接队列中等待的请求设置为 HIGH（例如，用户在购物网站上提交购买请求或保存当前状态的 POST 请求）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;max_connections&lt;/span&gt; : Envoy 将为上游集群中的所有主机建立的最大连接数，默认值是 &lt;code&gt;1024&lt;/code&gt;。实际上，这仅适用于 HTTP/1.1集群，因为 HTTP/2 使用到每个主机的单个连接。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;max_requests&lt;/span&gt; : 在任何给定时间内，集群中所有主机可以处理的最大请求数，默认值也是 1024。实际上，这适用于仅 HTTP/2 集群，因为 HTTP/1.1 集群由最大连接断路器控制。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-id-h2-2-基本的熔断策略-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 基本的熔断策略&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;由于 &lt;code&gt;HTTP/1.1&lt;/code&gt; 协议和 &lt;code&gt;HTTP/2&lt;/code&gt; 协议具有不同的连接行为（HTTP/1.1 : 同一个连接只能处理一个请求；HTTP/2 : 同一个连接能并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级），使用不同协议的集群将各自使用不同的配置项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/1.1 协议&lt;/strong&gt; : 使用 max_connections。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP/2 协议&lt;/strong&gt; ： 使用 max_requests。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个配置项都可以很好地实现熔断机制，主要取决于两个指标：服务的请求/连接数量和请求延时。例如，具有 1000个请求/second 和平均延迟 2 秒的 HTTP/1 服务通常会在任何给定时间内打开 &lt;code&gt;2000&lt;/code&gt; 个连接。由于当存在大量非正常连接时熔断器会启动熔断机制，因此建议将参数 max_connections 的值最少设置为 &lt;code&gt;10 x 2000&lt;/code&gt;，这样当最后 10 秒内的大多数请求未能返回正确的响应时就会打开熔断器。当然，具体的熔断器配置还得取决于系统的负载以及相关服务的具体配置。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-3-高级熔断策略-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 高级熔断策略&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;上面讨论了一些基本的熔断策略，下面将介绍更高级的熔断策略，这些高级熔断策略可以为你的网络基础架构增加更多的弹性。&lt;/p&gt;

&lt;h3 id=&#34;基于延迟设置熔断&#34;&gt;基于延迟设置熔断&lt;/h3&gt;

&lt;p&gt;如上所述，熔断器最常见的用例之一就是预防服务响应过慢但未完全瘫痪时引发的故障。虽然 Envoy 没有直接提供熔断器的延迟配置项，但可以通过自动重试配置项来模拟延迟。自动重试配置项通过 &lt;code&gt;max_retries&lt;/code&gt; 字段定义，表示在任何给定时间内，集群中所有主机可以执行的最大重试次数。&lt;/p&gt;

&lt;h3 id=&#34;基于长连接重试队列设置熔断&#34;&gt;基于长连接重试队列设置熔断&lt;/h3&gt;

&lt;p&gt;由于重试有可能将请求流量增加到两倍以上甚至更多，因此通过 &lt;code&gt;max_retries&lt;/code&gt; 参数可以防止服务因为过多的重试而过载。建议将此参数的值设置为服务通常在 10 秒窗口中处理的请求总数的一小部分，最好不要将重试次数设置为与服务在 10 秒窗口中处理的请求总数差不多。&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>通过控制平面提供路由</title>
      <link>https://www.yangcs.net/posts/routing-with-a-control-plane/</link>
      <pubDate>Fri, 06 Jul 2018 06:16:02 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/routing-with-a-control-plane/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;当微服务集群规模非常庞大时，控制平面包含了大量的 Envoy 配置项和基础设施状态，这时最好将数据平面与控制平面分离。控制平面最主要的功能包括自动重试和&lt;a href=&#34;https://www.yangcs.net/posts/integrating-service-discovery-with-envoy/&#34; target=&#34;_blank&#34;&gt;集成服务发现&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;单独创建控制平面的最大优势之一是可以为路由配置提供统一的来源。传统架构的路由定义分散存储在 Web 服务器的配置文件、负载均衡器配置文件和特定应用程序的配置中（如 &lt;code&gt;routes.rb&lt;/code&gt;），使用单独的控制平面可以集中所有的路由配置，使它们更易于更改和管理，同时也为应用的迁移和发布提供了更高的灵活性。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-通过-rds-提供路由-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 通过 RDS 提供路由&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Envoy 的动态配置功能允许通过路由发现服务（RDS）的 &lt;code&gt;API&lt;/code&gt; 来动态获取路由配置。控制平面通过 RDS 提供路由配置，将 &lt;strong&gt;域名+路径&lt;/strong&gt; 映射到 Envoy 中的某个集群（cluster），而实际的流量控制由 Envoy 实例来完成。&lt;/p&gt;

&lt;p&gt;这里是一个使用 RDS 来动态获取路由的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version_info: &amp;quot;0&amp;quot;
resources:
- &amp;quot;@type&amp;quot;: type.googleapis.com/envoy.api.v2.RouteConfiguration
  name: local_route
  virtual_hosts:
  - name: local_service
    domains: [&amp;quot;*&amp;quot;]
    routes:
    - match: { prefix: &amp;quot;/&amp;quot; }
      route: { cluster: some_service }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开源项目 &lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34;&gt;go-control-plane&lt;/a&gt;，&lt;a href=&#34;https://istio.io/docs/concepts/traffic-management/pilot.html&#34; target=&#34;_blank&#34;&gt;Istio Pilot&lt;/a&gt; 和 商业项目 &lt;a href=&#34;http://turbinelabs.io/product&#34; target=&#34;_blank&#34;&gt;Houston&lt;/a&gt; 都提供了 RDS 的 API，Envoy 官方文档也定义了一个&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/overview/v2_overview.html#v2-grpc-streaming-endpoints&#34; target=&#34;_blank&#34;&gt;完整的 RDS 规范&lt;/a&gt;。RDS 规范只是一种流量传输机制，如何对路由进行管理还是要取决于你。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-2-路由定义的最佳实践-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 路由定义的最佳实践&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;当你的系统中有数千个 Envoy 实例时，应该选择控制平面来作为所有路由的统一来源。客户端请求可以直接来自用户、内部服务或者来自不同的云区域，因此最好使用 Envoy 来处理这些不同的网络拓扑（例如，作为客户流量的前端代理以及内部流量的服务网格），虽然流量来自不同的方向，但它们的行为都是相似的。&lt;/p&gt;

&lt;p&gt;为了扩展单个系统的路由定义，通常需要遵循以下三个关键原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将路由视为数据，而不是配置&lt;/li&gt;
&lt;li&gt;将控制权分配给具有 &lt;code&gt;ACL&lt;/code&gt; 权限的团队&lt;/li&gt;
&lt;li&gt;使用审计日志和回滚操作来管理路由的更改&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;将路由视为数据&#34;&gt;将路由视为数据&lt;/h3&gt;

&lt;p&gt;将路由视为一组相互关联的服务的数据可以防止发生冲突，同时确保了其语义的正确性。虽然像 &lt;code&gt;Istio&lt;/code&gt; 这样的工具可以很容易地编写基于 &lt;code&gt;YAML&lt;/code&gt; 配置文件的路由，但是在数千行 YAML 文件中管理数百条路由很难保证每个定义都是有效的路由。或许你也想过使用版本控制来管理这些配置文件，但如果合并分支时发生致命错误将会导致灾难性的后果（如路由丢失或通过 API 重写）。&lt;/p&gt;

&lt;p&gt;实际上，从静态配置文件转移到动态配置文件是在大规模集群中使用 Envoy 的第一步。为了能够将 Envoy 投入生产，建议至少使用像 &lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34;&gt;go-control-plane&lt;/a&gt; 这样实现了 &lt;code&gt;xDS&lt;/code&gt; 的控制平面统一提供路由配置。通过将路由的来源转移到 &lt;code&gt;RDS API&lt;/code&gt; 背后，可以实现路由的并发更新，同时也可以防止对路由进行无意义的更新。&lt;/p&gt;

&lt;h3 id=&#34;将控制权分配给具有-acl-权限的团队&#34;&gt;将控制权分配给具有 &lt;code&gt;ACL&lt;/code&gt; 权限的团队&lt;/h3&gt;

&lt;p&gt;通过对流量进行管控可以解锁更强大的工作流程（如蓝绿发布和增量迁移），同时也能让服务团队确保各个服务之间的路由是安全可用的。你可以根据需要来隐藏管控区域之外的路由以防止误点击或者发生意外事故，你也可以完全禁止某些成员修改路由。&lt;/p&gt;

&lt;h3 id=&#34;管理路由的更改&#34;&gt;管理路由的更改&lt;/h3&gt;

&lt;p&gt;了解路由何时被更改以及被谁更改是极其重要的，许多团队会发现，在他们分配好了定义路由的任务之后，实际路由的数量将会超出他们的预期，因此为了保险起见，最好对路由的更改进行记录。例如，&lt;code&gt;master&lt;/code&gt; 分支中的自动蓝绿发布应该打上最后一个合并分支的人的标签。&lt;/p&gt;

&lt;p&gt;为了更好地管理路由，团队内部必须要知道如何在两个时间点之间更改路由以及如何在必要时将其回滚，同时最好将这些操作收集到监控系统中。当你需要进一步优化时，这些操作记录是很有价值的（例如 git 历史记录在编写新代码时很有帮助）。&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>将服务发现与 Envoy 集成</title>
      <link>https://www.yangcs.net/posts/integrating-service-discovery-with-envoy/</link>
      <pubDate>Wed, 04 Jul 2018 10:12:43 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/integrating-service-discovery-with-envoy/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;在微服务中使用 Envoy，需要明确两个核心概念：&lt;strong&gt;数据平面&lt;/strong&gt;和&lt;strong&gt;控制平面&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span id=&#34;inline-blue&#34;&gt;数据平面&lt;/span&gt; 由一组 Envoy 实例组成，用来调解和控制微服务之间的所有网络通信。&lt;/li&gt;
&lt;li&gt;&lt;span id=&#34;inline-blue&#34;&gt;控制平面&lt;/span&gt; 从 Envoy 代理和其他服务收集和验证配置，并在运行时执行访问控制和使用策略。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你可以使用静态类型的配置文件来实现控制平面，但为了能做出更加智能的负载均衡决策，最好的方法是通过 API 接口来实现。通过 API 接口来集中发现服务可以充分利用 Envoy 动态更新配置文件的能力。设置控制平面的第一步就是将 Envoy 连接到服务发现服务（SDS），通常分为三步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;实现一个控制平面&lt;/li&gt;
&lt;li&gt;将控制平面中定义的服务发布到 Envoy 的 &lt;code&gt;clusters&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;将 主机/容器/实例 发布到 Envoy 的 &lt;code&gt;endpoints&lt;/code&gt; 中&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;p-id-h2-1-实现一个控制平面-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 实现一个控制平面&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;控制平面必须要满足 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v2/api&#34; target=&#34;_blank&#34;&gt;Envoy v2 xDS APIs&lt;/a&gt;，同时为了更好地使用服务发现能力，你的控制平面最好能够实现集群发现服务（CDS）和端点发现服务（EDS）。为了避免重复造轮子，你可以选择社区已经实现好的控制平面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Rotor&lt;/span&gt; : &lt;a href=&#34;https://github.com/turbinelabs/rotor&#34; target=&#34;_blank&#34;&gt;Rotor&lt;/a&gt; 是一种快速、轻量级的 xDS 实现，它可以和 &lt;code&gt;Kubernetes&lt;/code&gt;、&lt;code&gt;Consul&lt;/code&gt; 和 &lt;code&gt;AWS&lt;/code&gt; 等服务集成，并且提供了一组默认的路由发现服务（RDS）和监听器发现服务（LDS）。它也是 Turbine Labs 的商业解决方案 &lt;a href=&#34;https://www.turbinelabs.io/&#34; target=&#34;_blank&#34;&gt;Houston&lt;/a&gt; 的组件之一，Houston 在 Rotor 的基础上增加了更多的路由、指标和弹性方面的配置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;go-control-plane&lt;/span&gt; : Envoy 官方仓库提供了一个开源版本的控制平面：&lt;a href=&#34;https://github.com/envoyproxy/go-control-plane&#34; target=&#34;_blank&#34;&gt;go-control-plane&lt;/a&gt;。如果你想弄清楚如何从服务发现服务中获取所有内容，可以好好研究一下这个项目。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;Pilot&lt;/span&gt; :  如果想将 Envoy 和 Kubernetes 集成，你可以选择 &lt;a href=&#34;https://istio.io/&#34; target=&#34;_blank&#34;&gt;Istio&lt;/a&gt; 项目。Istio 中的控制平面是由 &lt;a href=&#34;https://istio.io/docs/concepts/traffic-management/pilot.html&#34; target=&#34;_blank&#34;&gt;Pilot&lt;/a&gt; 组件来实现的，它会将 &lt;code&gt;YAMl&lt;/code&gt; 文件的内容转换为相应的 xDS 响应。如果你不想使用 Istio，也不用担心，因为 Pilot 完全可以脱离 Istio 的其他组件（如 &lt;code&gt;Mixer&lt;/code&gt;）来单独和 Envoy 集成。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;p-id-h2-2-将服务发布到-cds-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 将服务发布到 CDS&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;集群是 Envoy 连接到的一组逻辑上相似的上游主机，通过它可以对流量进行负载均衡。你可以通过调用集群发现服务（CDS）的 API 来动态获取集群管理成员，Envoy 会定期轮询 &lt;code&gt;CDS&lt;/code&gt; 端点以进行集群配置，配置文件形式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version_info: &amp;quot;0&amp;quot;
resources:
- &amp;quot;@type&amp;quot;: type.googleapis.com/envoy.api.v2.Cluster
  name: some_service
  connect_timeout: 1.0s
  lb_policy: ROUND_ROBIN
  type: EDS
  eds_cluster_config:
    eds_config:
      api_config_source:
        api_type: GRPC
        cluster_names: [xds_cluster]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务发现收集的每个服务都会映射到 &lt;code&gt;resources&lt;/code&gt; 下面的一个配置项，除此之外你还需要为负载均衡设置一些额外的配置参数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lb_policy&lt;/code&gt; : 集群的负载均衡类型，有以下几种方式：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;round_robin&lt;/code&gt; : 轮询主机&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weighted_least_request&lt;/code&gt; : 最近获得最少请求的主机&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random&lt;/code&gt; : 随机&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connect_timeout&lt;/code&gt; : 设置连接超时。越小越好，从 1 秒开始慢慢往上增加，直到网络没有明显的抖动为止。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;api_type&lt;/code&gt; : 设置服务的协议。Envoy 通过该协议和服务发现服务进行通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常情况下，你可以对端点（Endpoint）列表进行硬编码，但如果基础架构是动态的，则需要将 &lt;code&gt;type&lt;/code&gt; 设置为 &lt;code&gt;EDS&lt;/code&gt;，这将告诉 Envoy 轮询 &lt;code&gt;EDS API&lt;/code&gt; 以获取可用的 IP/Port 列表。完整示例可以参考 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v1/cluster_manager/cluster.html&#34; target=&#34;_blank&#34;&gt;Envoy 的官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;设置好 CDS 之后，就可以为此集群设置端点发现服务（EDS）了。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-3-将实例发布到-eds-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 将实例发布到 EDS&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Envoy 将端点（&lt;code&gt;Endpoint&lt;/code&gt;）定义为集群中可用的 IP 和端口。为了能够对服务之间的流量进行负载均衡，Envoy 希望 &lt;code&gt;EDS API&lt;/code&gt; 能够提供每个服务的端点列表。Envoy 会定期轮询 EDS 端点，然后生成响应：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version_info: &amp;quot;0&amp;quot;
resources:
- &amp;quot;@type&amp;quot;: type.googleapis.com/envoy.api.v2.ClusterLoadAssignment
  cluster_name: some_service
  endpoints:
  - lb_endpoints:
    - endpoint:
       address:
         socket_address:
           address: 127.0.0.2
           port_value: 1234
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过这种配置方式，Envoy 唯一需要知道的就是该端点属于哪个集群，这比直接定义集群更简单。&lt;/p&gt;

&lt;p&gt;Envoy 将 CDS 和 EDS 视为一份份的报告并保持服务发现的最终一致性。如果到该端点的请求经常失败，就会从负载均衡中删除该端点，直到再次恢复正常访问。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-4-最佳实践-对配置进行分区-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 最佳实践：对配置进行分区&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;当集群中有很多服务时，Envoy 与 CDS 和 EDS 的交互量将会非常庞大，一旦出现问题，从几千个 API 响应中排查问题是很不现实的。标准的做法是以两种方式对配置进行分区：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;根据数据中心/区域划分&lt;/code&gt; : 通常情况下，一个数据中心的服务不需要知道其他数据中心可用的服务端点。要想在不同区域之间建立通信，需要将远程数据中心的前端代理添加到本地的负载均衡器中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;根据服务需求划分&lt;/code&gt; : 通过为不同的服务配置 Envoy 边车代理（服务 envoy 与每个 serivce 实例一起运行），设置白名单来限制不同服务之间的相互通信，可以降低 1000 个级别的微服务之间相互通信的复杂度。同时边车（Sidecars）代理还可以通过阻止对服务的意外调用来加强安全保护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对配置进行分区可以降低对不同服务的运营和管理的难度，但它的代价是使控制平面变得更加复杂，但客户往往是不关心控制平面的，所以牺牲控制平面的复杂度还是很值得的。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-5-下一步-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 下一步&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;一旦控制平面发现了所有可用服务，就可以在这些服务上配置路由了。下一节将会介绍如何配置路由发现服务（RDS）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>为 Envoy 启用证书验证</title>
      <link>https://www.yangcs.net/posts/setting-up-ssl-in-envoy/</link>
      <pubDate>Tue, 03 Jul 2018 06:43:33 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/setting-up-ssl-in-envoy/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;如果你准备将服务暴露在互联网上，最好启用 &lt;code&gt;SSL/TLS&lt;/code&gt; 加密协议。当使用 Envoy 作为前端代理或者服务网格代理时，可以通过 SSL/TLS 协议来加密客户端和代理之间的所有通信流量。&lt;/p&gt;

&lt;p&gt;Envoy 同时支持监听器中的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v1/listeners/listeners.html#config-listener-ssl-context&#34; target=&#34;_blank&#34;&gt;TLS 终止&lt;/a&gt; 和与上游集群建立连接时的 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/api-v1/cluster_manager/cluster_ssl#config-cluster-manager-cluster-ssl&#34; target=&#34;_blank&#34;&gt;TLS 发起&lt;/a&gt;。不管是为现代 web 服务提供标准的边缘代理功能，还是同具有高级 TLS 要求（TLS1.2, SNI, 等等）的外部服务建立连接，Envoy 都提供了充分的支持。&lt;/p&gt;

&lt;p&gt;本文将会演示如何在前端代理中设置 TLS 终止，同时指定访问域名。主要分三个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建 Envoy 需要使用的证书&lt;/li&gt;
&lt;li&gt;为 Envoy 启用证书验证&lt;/li&gt;
&lt;li&gt;配置 Envoy 将 80 端口重定向到 443 端口&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;p-id-h2-1-创建证书-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 创建证书&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;如果要启用 HTTPS，我们就需要从证书授权机构(以下简称 CA) 处获取一个证书。如果你还没有证书，你可以从 &lt;a href=&#34;https://letsencrypt.org/&#34; target=&#34;_blank&#34;&gt;Let’s Encrypt&lt;/a&gt; 获得网站域名的免费的证书，因为 Let’s Encrypt 就是一个 &lt;code&gt;CA&lt;/code&gt;。本文为了测试使用 &lt;code&gt;OpenSSL&lt;/code&gt; 生成私钥文件 &lt;code&gt;example-com.key&lt;/code&gt; 和 自签名证书 &lt;code&gt;example-com.crt&lt;/code&gt;。&lt;/p&gt;

&lt;div id=&#34;note&#34;&gt;
&lt;p id=&#34;note-title&#34;&gt;Note&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;需要注意的是 &lt;code&gt;Common Name&lt;/code&gt; 字段，本文测试使用的是 &lt;code&gt;example.com&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 继续沿用前文使用的示例
$ cd envoy/examples/front-proxy

# 生成2048位的加密私钥
$ openssl genrsa -out example-com.key 2048

#生成证书签名请求(CSR)
$ openssl req -new -key example-com.key -out example-com.csr

You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:CA
Locality Name (eg, city) [Default City]:Shanghai
Organization Name (eg, company) [Default Company Ltd]:Daocloud
Organizational Unit Name (eg, section) []:Envoy Division
Common Name (eg, your name or your server&#39;s hostname) []:example.com
Email Address []:chuansheng.yang@daocloud.io

Please enter the following &#39;extra&#39; attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

# 生成X509自签名证书
$ openssl x509 -req -days 365 -in example-com.csr -signkey example-com.key -out example-com.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-2-为-envoy-启用证书验证-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 为 Envoy 启用证书验证&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;修改 &lt;code&gt;Dockerfile-frontenvoy&lt;/code&gt; 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;ADD ./example-com.crt /etc/example-com.crt
ADD ./example-com.key /etc/example-com.key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改 &lt;code&gt;front-envoy.yaml&lt;/code&gt; 配置文件，在 &lt;code&gt;filters&lt;/code&gt; 列表后面添加 &lt;code&gt;tls_context&lt;/code&gt; 配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;tls_context:
  common_tls_context:
    tls_certificates:
      - certificate_chain:
          filename: &amp;quot;/etc/example-com.crt&amp;quot;
        private_key:
          filename: &amp;quot;/etc/example-com.key&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将监听器的监听端口改为标准的 TLS 端口：443。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 443
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还要指定访问的域名，不再使用之前的通配符匹配：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;domains:
- &amp;quot;example.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Envoy 可以通过在同一个监听器中配置多个监听器过滤器链来支持多个域名的 &lt;code&gt;SNI&lt;/code&gt;（如 example.com 和 www.example.com），你可以在 &lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/faq/sni&#34; target=&#34;_blank&#34;&gt;Envoy 官方文档&lt;/a&gt; 中看到一个示例。&lt;/p&gt;

&lt;p&gt;最后修改 &lt;code&gt;docker-compose.yaml&lt;/code&gt; 文件，将 443 端口暴露出来，同时将 8080 端口替换为 80 端口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;services:
  front-envoy:
  ...
    expose:
      - &amp;quot;80&amp;quot;
      - &amp;quot;443&amp;quot;
    ports:
      - &amp;quot;80:80&amp;quot;
      - &amp;quot;443:443&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启该示例服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose down --remove-orphans
$ docker-compose up --build -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面就可以使用 curl 来进行测试了。这里有两个需要注意的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为了确保 curl 能成功验证证书，必须通过 &lt;code&gt;--cacert&lt;/code&gt; 参数将证书文件传递给 Envoy。&lt;/li&gt;
&lt;li&gt;由于 DNS 无法解析 example.com，所以需要通过参数 &lt;code&gt;--connect-to&lt;/code&gt; 明确指定连接到 localhost，同时在请求的头文件中申明 localhost 的域名为 &lt;code&gt;example.com&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl --cacert example-com.crt --connect-to localhost -H &#39;Host: example.com&#39; https://localhost/service/1

Hello from behind Envoy (service 1)! hostname: 56e8a5bff6bd resolvedhostname: 172.18.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你的 curl 版本不支持 &lt;code&gt;--connect-to&lt;/code&gt; 参数，可以在 &lt;code&gt;/etc/hosts&lt;/code&gt; 中添加一个条目：&lt;code&gt;127.0.0.1    example.com&lt;/code&gt;，然后直接通过域名访问：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl --cacert example-com.crt https://example.com/service/1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-3-将-80-端口重定向到-443-端口-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 将 80 端口重定向到 443 端口&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;为了将所有 80 端口的流量重定向到 443 端口，可以将 443 端口的路由配置复制一份，然后稍作修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 80
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            virtual_hosts:
            - name: backend
              domains:
              - &amp;quot;example.com&amp;quot;
              routes:
              - match:
                  prefix: &amp;quot;/&amp;quot;
                redirect:
                  path_redirect: &amp;quot;/&amp;quot;
                  https_redirect: true
          http_filters:
          - name: envoy.router
            config: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose down --remove-orphans
$ docker-compose up --build -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次通过 &lt;code&gt;HTTP&lt;/code&gt; 协议访问 service1，将会返回 &lt;code&gt;301&lt;/code&gt; 状态码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -I -H &#39;Host: example.com&#39; http://localhost/service/1

HTTP/1.1 301 Moved Permanently
location: https://example.com/
date: Tue, 03 Jul 2018 06:32:13 GMT
server: envoy
content-length: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OK，大功告成！完整的 front-proxy.yaml 配置文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 80
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            virtual_hosts:
            - name: backend
              domains:
              - &amp;quot;example.com&amp;quot;
              routes:
              - match:
                  prefix: &amp;quot;/&amp;quot;
                redirect:
                  path_redirect: &amp;quot;/&amp;quot;
                  https_redirect: true
          http_filters:
          - name: envoy.router
            config: {}
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 443
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: backend
              domains:
              - &amp;quot;example.com&amp;quot;
              routes:
              - match:
                  prefix: &amp;quot;/service/1&amp;quot;
                route:
                  cluster: service1
              - match:
                  prefix: &amp;quot;/service/2&amp;quot;
                route:
                  cluster: service2
          http_filters:
          - name: envoy.router
            config: {}
      tls_context:
        common_tls_context:
          tls_certificates:
            - certificate_chain:
                filename: &amp;quot;/etc/example-com.crt&amp;quot;
              private_key:
                filename: &amp;quot;/etc/example-com.key&amp;quot;
  clusters:
  - name: service1
    connect_timeout: 0.25s
    type: strict_dns
    lb_policy: round_robin
    http2_protocol_options: {}
    hosts:
    - socket_address:
        address: service1
        port_value: 80
  - name: service2
    connect_timeout: 0.25s
    type: strict_dns
    lb_policy: round_robin
    http2_protocol_options: {}
    hosts:
    - socket_address:
        address: service2
        port_value: 80
admin:
  access_log_path: &amp;quot;/dev/null&amp;quot;
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 8001
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://o7z41ciog.bkt.clouddn.com/qrcode_for_wechat_big.jpg&#34; alt=&#34;&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>通过 Envoy 实现增量部署</title>
      <link>https://www.yangcs.net/posts/incremental-deploys/</link>
      <pubDate>Mon, 02 Jul 2018 05:37:37 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/incremental-deploys/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;微服务最常见的工作流程之一就是版本更新。不同于基础架构更新，通过流量管理可以优雅地实现微服务的版本更新。当新发布的版本有缺陷时，这种方法就可以避免版本缺陷对用户造成的不良影响。&lt;/p&gt;

&lt;p&gt;本文将继续沿用前文使用的示例，在原有配置文件的基础上新增了个别服务的新版本来演示流量是如何切换的（包括基于请求头的路由和加权负载均衡）。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-基于请求头的路由-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 基于请求头的路由&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;为了说明基于请求头的路由对微服务产生的影响，首先创建一个新版本的 &lt;code&gt;service1&lt;/code&gt; 。这里仍然使用 Envoy 仓库中的 &lt;a href=&#34;https://github.com/envoyproxy/envoy/tree/master/examples/front-proxy&#34; target=&#34;_blank&#34;&gt;front-proxy&lt;/a&gt; 示例，修改 &lt;a href=&#34;https://github.com/envoyproxy/envoy/blob/master/examples/front-proxy/docker-compose.yml&#34; target=&#34;_blank&#34;&gt;docker-compose.yml&lt;/a&gt; 文件，添加一个名为 &lt;code&gt;service1a&lt;/code&gt; 的新服务。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  service1a:
    build:
      context: .
      dockerfile: Dockerfile-service
    volumes:
      - ./service-envoy.yaml:/etc/service-envoy.yaml
    networks:
      envoymesh:
        aliases:
          - service1a
    environment:
      - SERVICE_NAME=1a
    expose:
      - &amp;quot;80&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了确保 Envoy 可以发现该服务，需要将该服务添加到 &lt;code&gt;clusters&lt;/code&gt; 配置项中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;  - name: service1a
    connect_timeout: 0.25s
    type: strict_dns
    lb_policy: round_robin
    http2_protocol_options: {}
    hosts:
    - socket_address:
        address: service1a
        port_value: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了使新加的服务路由可达，需要在 &lt;code&gt;match&lt;/code&gt; 配置项中添加一个带有 &lt;code&gt;headers&lt;/code&gt; 字段的新路由。因为路由规则列表是按顺序匹配的，所以我们需要将该规则添加到路由规则列表的顶部，这样与新规则匹配的包含该头文件的请求就会被转发到新服务，而不包含该头文件的请求仍然被转发到 service1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;routes:
- match:
    prefix: &amp;quot;/service/1&amp;quot;
    headers:
      - name: &amp;quot;x-canary-version&amp;quot;
        value: &amp;quot;service1a&amp;quot;
  route:
    cluster: service1a
- match:
    prefix: &amp;quot;/service/1&amp;quot;
  route:
    cluster: service1
- match:
    prefix: &amp;quot;/service/2&amp;quot;
  route:
    cluster: service2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重启该示例服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose down --remove-orphans
$ docker-compose up --build -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果客户端发出的请求没有携带头文件，就会收到来自 &lt;code&gt;service1&lt;/code&gt; 的响应：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl localhost:8000/service/1

Hello from behind Envoy (service 1)! hostname: d0adee810fc4 resolvedhostname: 172.18.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果请求携带了头文件 &lt;code&gt;x-canary-version&lt;/code&gt;，Envoy 就会将请求转发到 service 1a。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -H &#39;x-canary-version: service1a&#39; localhost:8000/service/1

Hello from behind Envoy (service 1a)! hostname: 569ee89eebc8 resolvedhostname: 172.18.0.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Envoy 基于头文件的路由功能解锁了&lt;a href=&#34;https://opensource.com/article/17/8/testing-production&#34; target=&#34;_blank&#34;&gt;在生产环境中测试开发代码&lt;/a&gt;的能力。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-2-加权负载均衡-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 加权负载均衡&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;接下来进一步修改配置来实现对 service1 新版本的增量发布，使用 &lt;code&gt;clusters&lt;/code&gt; 数组替代原来的 &lt;code&gt;cluster&lt;/code&gt; 键值对，从而实现将 25% 的流量转发到该服务的新版本上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- match:
    prefix: &amp;quot;/service/1&amp;quot;
  route:
    weighted_clusters:
      clusters:
      - name: service1a
        weight: 25
      - name: service1
        weight: 75
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后重启该示例服务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker-compose down --remove-orphans
$ docker-compose up --build -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时如果客户端发出的请求没有携带头文件，就会有 25% 的流量转发到 service 1a。&lt;/p&gt;

&lt;p&gt;增量部署是个非常强大的功能，它还可以和监控配合使用，以确保服务的版本差异（或者后端服务的架构差异）不会对该服务的版本更新产生不良影响。如果想模拟新版本的成功发布，可以将 service1a 的权重设置为 &lt;code&gt;100&lt;/code&gt;，然后所有的流量都会被转发到 service 1a。同样，如果新发布的版本有缺陷，你可以通过将 service1a 的权重设置为 &lt;code&gt;0&lt;/code&gt; 来回滚到之前的版本。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-3-最佳实践-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 最佳实践&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;学会了如何配置基于请求头的路由和加权负载均衡之后，就可以在生产或测试环境中进行实践了。首先需要将&lt;strong&gt;部署&lt;/strong&gt;和&lt;strong&gt;发布&lt;/strong&gt;这两个流程分离，部署了新版本之后，你就可以通过配置基于请求头的路由来让你的团队在内部进行测试，同时又不影响用户的使用。一旦测试通过，就可以通过滚动发布模式（逐步增加权重，如 1%，5%，10%，50% &amp;hellip;）来优雅地发布新版本。&lt;/p&gt;

&lt;p&gt;通过将&lt;strong&gt;部署&lt;/strong&gt;和&lt;strong&gt;发布&lt;/strong&gt;这两个流程分离，使用基于请求头的路由在新版本发布之前进行测试，然后通过滚动部署模式来增量发布，你的团队将会从中受益匪浅。&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
    <item>
      <title>HTTP 路由解析</title>
      <link>https://www.yangcs.net/posts/routing-basics/</link>
      <pubDate>Fri, 29 Jun 2018 09:57:33 +0000</pubDate>
      
      <guid>https://www.yangcs.net/posts/routing-basics/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;p&gt;本文将更详细地讨论 Envoy 的 HTTP 路由，如果你已经看过了我的上篇文章：&lt;a href=&#34;https://www.yangcs.net/posts/run-envoy-on-your-laptop/&#34; target=&#34;_blank&#34;&gt;在你的笔记本上运行 Envoy&lt;/a&gt;，现在就可以更深入地了解如何在静态文件中配置路由（Route）、集群（Cluster）和监听器（Listener）了。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-1-相关组件-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;1. 相关组件&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;路由&#34;&gt;路由&lt;/h3&gt;

&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;路由&lt;/span&gt; 是一组将虚拟主机与集群相匹配的规则，通过路由你可以很轻松地创建流量切换规则。路由的定义方式有两种：通过静态配置文件定义或通过路由发现服务（&lt;code&gt;RDS&lt;/code&gt;）进行配置。&lt;/p&gt;

&lt;h3 id=&#34;集群&#34;&gt;集群&lt;/h3&gt;

&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;集群&lt;/span&gt; 是一组逻辑上相似的上游主机，它接收来自 Envoy 的流量。集群可以通过负载均衡策略来提高基础架构的弹性。集群可以通过静态文件进行配置，也可以通过集群发现服务（&lt;code&gt;CDS&lt;/code&gt;）API 动态获取。&lt;/p&gt;

&lt;h3 id=&#34;监听器&#34;&gt;监听器&lt;/h3&gt;

&lt;p&gt;&lt;span id=&#34;inline-blue&#34;&gt;监听器&lt;/span&gt; 是可以接受来自下游客户端的连接的命名网络位置（例如，端口，unix域套接字等）。Envoy 公开一个或多个下游主机连接的侦听器。同样，监听器可以通过静态定义，也可以通过监听器发现服务（LDS）动态获取。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-2-配置路由-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;2. 配置路由&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Envoy 的路由定义将 &lt;code&gt;域 + URL&lt;/code&gt; 映射到集群。在上一篇文章中，我们定义了两个集群（service1 和 service2），每一个集群都匹配一个单独的 URL（&lt;code&gt;/service1&lt;/code&gt; 和 &lt;code&gt;/service2&lt;/code&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;virtual_hosts:
  - name: backend
    domains:
    - &amp;quot;*&amp;quot;
    routes:
    - match:
        prefix: &amp;quot;/service/1&amp;quot;
      route:
        cluster: service1
    - match:
        prefix: &amp;quot;/service/2&amp;quot;
      route:
        cluster: service2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;集群从 DNS 中获取集群成员数据，并对集群中的所有主机使用&lt;strong&gt;轮询&lt;/strong&gt;的方式进行负载均衡。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;clusters:
  - name: service1
      connect_timeout: 0.25s
      type: strict_dns
      lb_policy: round_robin
      http2_protocol_options: {}
      hosts:
      - socket_address:
          address: service1
          port_value: 80
  - name: service2
      connect_timeout: 0.25s
      type: strict_dns
      lb_policy: round_robin
      http2_protocol_options: {}
      hosts:
      - socket_address:
          address: service2
          port_value: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-3-配置监听器-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;3. 配置监听器&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;路由的配置包含在监听器的配置中，现在我们再回过头来看一下监听器的配置。监听器通过&lt;strong&gt;监听器过滤器&lt;/strong&gt;（Listener filter）来操作路由配置中定义的两个服务。监听器的 API 非常简单，它的作用是在不更改 Envoy 的核心功能的情况下添加更多的集成功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 80
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        config:
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: backend
              domains:
              - &amp;quot;*&amp;quot;
              routes:
              - match:
                  prefix: &amp;quot;/service/1&amp;quot;
                route:
                  cluster: service1
              - match:
                  prefix: &amp;quot;/service/2&amp;quot;
                route:
                  cluster: service2
          http_filters:
          - name: envoy.router
            config: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-4-动态发现路由-集群和监听器-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;4. 动态发现路由、集群和监听器&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;到目前为止我们都是通过静态配置文件来配置路由和集群，但你也可以通过 &lt;code&gt;RDS&lt;/code&gt; 和 &lt;code&gt;CDS&lt;/code&gt; 来动态更新路由和集群。特别是当你的基础架构规模非常大时，你可以通过配置动态服务发现的规则来简化你的重复配置成本，并且可以将同一套动态服务发现规则应用于多个 Envoy 集群。&lt;/p&gt;

&lt;p&gt;现在你已经了解了如何配置基本的路由、集群和监听器，下一节我们将学习如何在增量部署中设置更复杂的流量切换和过滤规则。&lt;/p&gt;

&lt;h2 id=&#34;p-id-h2-5-参考-p&#34;&gt;&lt;p id=&#34;h2&#34;&gt;5. 参考&lt;/p&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://servicemesher.github.io/envoy/&#34; target=&#34;_blank&#34;&gt;Envoy 官方文档中文版&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;style&gt;
#h2{
    margin-bottom:2em;
    margin-right: 5px;
    padding: 8px 15px;
    letter-spacing: 2px;
    background-image: linear-gradient(to right bottom, rgb(0, 188, 212), rgb(63, 81, 181));
    background-color: rgb(63, 81, 181);
    color: rgb(255, 255, 255);
    border-left: 10px solid rgb(51, 51, 51);
    border-radius:5px;
    text-shadow: rgb(102, 102, 102) 1px 1px 1px;
    box-shadow: rgb(102, 102, 102) 1px 1px 2px;
}
#note {
    font-size: 1.5rem;
    font-style: italic;
    padding: 0 1rem;
    margin: 2.5rem 0;
    position: relative;
    background-color: #fafeff;
    border-top: 1px dotted #9954bb;
    border-bottom: 1px dotted #9954bb;
}
#note-title {
    padding: 0.2rem 0.5rem;
    background: #9954bb;
    color: #FFF;
    position: absolute;
    left: 0;
    top: 0.25rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    border-radius: 4px;
    -webkit-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -moz-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -ms-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    -o-transform: rotate(-5deg) translateX(-10px) translateY(-25px);
    transform: rotate(-5deg) translateX(-10px) translateY(-25px);
}
#inline-yellow {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #f0ad4e;
}
#inline-green {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #5cb85c;
}
#inline-blue {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #2780e3;
}
#inline-purple {
display:inline;
padding:.2em .6em .3em;
font-size:80%;
font-weight:bold;
line-height:1;
color:#fff;
text-align:center;
white-space:nowrap;
vertical-align:baseline;
border-radius:0;
background-color: #9954bb;
}
#div-border-left-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #df3e3e;
}
#div-border-left-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #f0ad4e;
}
#div-border-left-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #5cb85c;
}
#div-border-left-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #2780e3;
}
#div-border-left-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-left-width: 5px;
border-radius: 3px;
border-left-color: #9954bb;
}
#div-border-right-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #df3e3e;
}
#div-border-right-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #f0ad4e;
}
#div-border-right-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #5cb85c;
}
#div-border-right-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #2780e3;
}
#div-border-right-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-right-width: 5px;
border-radius: 3px;
border-right-color: #9954bb;
}
#div-border-top-red {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #df3e3e;
}
#div-border-top-yellow {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #f0ad4e;
}
#div-border-top-green {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #5cb85c;
}
#div-border-top-blue {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #2780e3;
}
#div-border-top-purple {
display: block;
padding: 10px;
margin: 10px 0;
border: 1px solid #ccc;
border-top-width: 5px;
border-radius: 3px;
border-top-color: #9954bb;
}
&lt;/style&gt;</description>
    </item>
    
  </channel>
</rss>
